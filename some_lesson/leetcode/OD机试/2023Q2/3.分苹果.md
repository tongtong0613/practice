**题目**
```
A、B两个人把苹果分为两堆，A希望按照他的计算规则等 分苹果 ，他的计算规则是按照二进制加法计算，并且不计算进位 12+5=9（1100 + 010
9），B的计算规则是十进制加法，包括正常进位，B希望在满足A的情况下获取苹果重量最多。
输入苹果的数量和每个苹果重量，输出满足A的情况下B获取的苹果总重量。
如果无法满足A的要求，输出-1。
数据范围
1 <= 总苹果数量 <= 20000
1 <= 每个苹果重量 <= 10000
```
**输入描述：**
```
输入第一行是苹果数量：3
输入第二行是每个苹果重量：3 5 6
```
**输出描述：**
```
输出第一行是B获取的苹果总重量：11
```
**示例1**
```
输入
3
3 5 6
输出
11
示例2 输入输出示例仅供调试，后台判题数据一般不包含示例
输入
8
7258 6579 2602 6716 3050 3564 5396 1773
输出
35165
```
**思路**
```
1：先审题，A的目标是 等分，也就是目标是一人一半。
2：不进位的二进制加法，等同于二进制的异或操作。
3：B要先满足 A 的 需求，那么肯定要先判定所有苹果在不进位的 二进制加法 前提下能否等分，等分那就意味着分出来的两堆苹果异或的结果为 0。
4：如果可以等分，那么取出最小的苹果分给 A 即可。因为所有苹果异或的结果是0，所以任意拿出1个，分成另一堆， 那么这两堆的重量，按照A的算法去算，必然是相等的。
5：如果不能等分，则直接返回 -1。
```
**代码**
```python
class Solution:
    def solve(self, nums):
        total_a = 0
        total_b = 0
        min_value = float('inf')
        for num in nums:
            total_a ^= num
            total_b += num
            min_value = min(min_value, num)
        if total_a != 0:
            return -1
        else:
            return total_b - min_value

s = Solution()
print(s.solve([7258, 6579, 2602, 6716, 3050, 3564, 5396, 1773]))
```