1. **猴子吃桃 二分法**

**题目描述**
孙悟空爱吃蟠桃，有一天趁着蟠桃园守卫不在来偷吃。已知蟠桃园有 N 棵桃树，每颗树上都有桃子，守卫将在 H 小时后回来。
孙悟空可以决定他吃蟠桃的速度K（个/小时），每个小时选一颗桃树，并从树上吃掉 K 个，如果树上的桃子少于 K 个，则全部吃掉，并且这一小时剩
不再吃桃。
孙悟空喜欢慢慢吃，但又想在守卫回来前吃完桃子。
请返回孙悟空可以在 H 小时内吃掉所有桃子的最小速度 K（K为整数）。如果以任何速度都吃不完所有桃子，则返回0。
**输入描述**
第一行输入为 N 个数字，N 表示桃树的数量，这 N 个 数字表示 每颗桃树上蟠桃的数量。
第二行输入为一个数字，表示守卫离开的时间 H。
其中数字通过空格分割，N、H为正整数，每颗树上都有蟠桃，且 0 < N < 10000，0 < H < 10000。
**输出描述**
吃掉所有蟠桃的最小速度 K，无解或输入异常时输出 0。
**用例**
输入 2 3 4 5
4
输出 5
说明 无
输入 2 3 4 5
3
输出 0
说明 无
输入 30 11 23 4 20
6
输出 23
说明 无
**代码**
```python
class Solution:
    def solve(self, trees, n):
        if n < len(trees):
            return 0
        l, r = 1, max(trees)
        while l < r:
            mid = (l + r) >> 1
            if self.get_res(trees, n, mid):
                r = mid
            else:
                l = mid + 1
        return l

    def get_res(self, trees, n, speed):
        total = 0
        for i in range(len(trees)):
            total += (trees[i] + speed - 1) // speed
            if total > n:
                return False
        return True

s = Solution()
print(s.solve([2,3,4,5], 4))
```

2. 猜拳 逻辑分析

**题目描述**
石头剪刀布 游戏有 3 种出拳形状：石头、剪刀、布。分别用字母A、B、C表示。
游戏规则 ：
1. 出拳形状之间的胜负规则如下：
A > B；
B > C；
C > A；
">" 左边一个字母，表示相对优势形状。右边一个字母，表示相对劣势形状。
2. 当本场次中有且仅有一种出拳形状优于其他出拳形状，则该形状的玩家是胜利者。否则认为是平局。
例如1：三个玩家出拳分别是A，B，C。由于三方优势循环（即没有任何一方优于其他出拳者），判断为平局。
例如2：三个玩家出拳分别是A，B，B。出拳A的获胜。
例如3：三个玩家出拳全部是A。判为平局。
3. 当发生平局，没有赢家。有多个胜利者时，同为赢家。


**输入描述**
在一场游戏中，每个玩家的信息为一行。玩家数量不超过1000。每个玩家信息有2个字段，用空格隔开；
1. 玩家ID：一个仅由英文字母和数字组成的字符串
2. 出拳形状：以英文大写字母表示，A、B、C形状。
3. 出拳时间：正整数，越小表示时间越早
例如：
abc1 A
xyz B
解释：玩家abc1出拳为石头（A）。玩家xyz出拳为剪刀（B）


**输出描述**
输出为赢家的玩家ID列表（一个或多个），每个ID一行，按 字符串 升序排列。如果没有赢家，输出为”NULL“字符串。
例如：
abc1

**代码**
```python
def get_res():
    mp = {}
    while True:
        try:
            name, value = input().split()
            if value < 'A' or value > 'C':
                print('NULL')
                return

            if value not in mp:
                mp[value] = [name]
            else:
                mp[value].append(name)
        except:
            break

    kinds = len(mp)
    if kinds == 1 or kinds == 3:
        print('NULL')
    else:
        ans = None
        if 'B' not in mp:
            ans = mp['C']
        elif 'A' not in mp:
            ans = mp['B']
        else:
            ans = mp['A']
        ans.sort()
        for item in ans:
            print(item)

get_res()
```

3. 二叉树计算 dfs

**题目**
```
给出一个二叉树：请由该二叉树生成一个新的二叉树，它满足其树中的每个节点将包含原始树中的左子树和右子树的和。
左子树表示该节点左侧叶子节点为 根节点 的一颗新树；右子树表示该节点右侧叶子节点为根节点的一颗新树。
```
**输入描述**
```
2行整数，第1行表示二叉树的 中序遍历 ，第2行表示二叉树的前序遍历，以空格分割
例如：
7 -2 6 6 9
6 7 -2 9 6
```
**输出描述**
```
1行整数，表示求和树的中序遍历，以空格分割
例如：
-2 0 20 0 6
```
**用例1**
```
输入
1 7 -2 6 6 9
2 6 7 -2 9 6
输出
-2 0 20 0 6
```
**思路**
```
1：二叉树相关的很经典的题目，从前序+中序去 还原二叉树 。
2：本题只是在还原二叉树的基础上要算每一个节点的左右子树和，一个dfs解决问题。
```
**代码**
```python
class TreeNode:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

class Solution:

    def build(self, inorder, preorder):
        if not inorder and not preorder:
            return
        root = TreeNode(preorder[0])
        index = inorder.index(preorder[0])
        root.left = self.build(inorder[:index], preorder[1:index+1])
        root.right = self.build(inorder[index+1:], preorder[index+1:])
        return root

    def solve(self, inorder, preorder):
        root = self.build(inorder, preorder)
        res = []
        def dfs(root):
            if not root:
                return 0
            tmp = root.value
            left = dfs(root.left)
            res.append(left)
            index = len(res)
            right = dfs(root.right)
            res[index-1] += right
            return left + right + tmp

        dfs(root)
        return res

s = Solution()
print(s.solve([7,-2,6,6,9], [6,7,-2,9,6]))
```

5. 分月饼 分治

**题目描述**
中秋节，公司分 月饼 ，m 个员工，买了 n 个月饼，m ≤ n，每个员工至少分 1 个月饼，但可以分多个，
单人分到最多月饼的个数是 Max1 ，单人分到第二多月饼个数是 Max2 ，Max1 - Max2 ≤ 3 ，
单人分到第 n - 1 多月饼个数是 Max(n-1)，单人分到第n多月饼个数是 Max(n) ，Max(n-1) – Max(n) ≤ 3,
问有多少种分月饼的方法？
**输入描述**
每一行输入m n，表示m个员工，n个月饼，m ≤ n
**输出描述**
输出有多少种月饼分法
**题目解析**
本题类似于 整数划分问题 ，即将一个正整数n，分解为m个正整数的方案数。
这类问题一般不会有太大的数量级，比如将10000分解为10个整数，那方案数就太多了。
本题给了一个限制条件，那就是，如果将分解后的m个正整数升序的话，相邻元素之间的差值不能超过3。
另外，分解方案不在意m个正整数的顺序，比如 1 2 1 和 1 1 2算一种方案。
我这里考虑使用分治递归求解。
分治递归可以想象成一棵树，这颗树有m层。
第0层相当于序号0个员工，该层有多个节点，每个节点的值即为序号0个员工可能分得的月饼数量。
题目说，每个员工至少分得1个月饼，因此序号0个员工分得月饼数至少为1。
为了保证不产生重复方案，因此我们默认当前求解的升序的m个正整数序列，因此序号0个员工分得的月饼数不能超过均值，即 n / m，因为一旦序号0个员工分得的月饼超过均值，则其后面的员工必然会有分得小于均值月饼数的情况。
因此第0个员工分得的月饼数范围是 1 ~ n / m
接下来是第1层，相当于序号1员工，该员工分得的月饼数取决于上一层的员工：
为了保证升序，序号1员工分得的月饼最少数量即序号0员工分得的月饼数量
同时，题目限定相邻员工之间，月饼数差距不能超过3，因此序号1员工最多分得的月饼数量 = 序号0员工分得月饼数量 + 3
另外为了保证后面员工分得月饼数一定不小于序号1员工，因此序号1员工分得的月饼数量不能超过 (剩余月饼数量 ➗ 剩余员工数量) ，其中：
1. 剩余月饼数量 = n - 序号0员工分得的月饼数
2. 剩余员工数量 = m - 1
接下来层数同理，直到第m-1层，即分配到最后一个员工，此时最后一个员工将分得剩余所有月饼，如果最后一个员工和倒数第二个员工月饼数差距bu超过3，即可判断当前递归分支对应的分配方案可行与否

**代码**
```python
from functools import cache
import sys
 
# 这题递归可能栈溢出，Python的递归深度要搞大一点，考试时如果10000不行，再加大一点
sys.setrecursionlimit(10000)
 
# 输入获取
m, n = map(int, input().split())
 
 
# 递归
@cache
def recursive(level, low, high, remain):
    """
    :param level: 第几个员工
    :param low: 当前员工至少分得几个月饼
    :param high: 当前员工至多分得几个月饼
    :param remain: 分月饼给当前员工前，月饼的剩余数量
    """
    # 分到最后一个员工时，我们应该将剩余月饼都给他
    if level == m - 1:
        # 因此最后一个员工的月饼数量就是remain，而倒数第二个员工的月饼数量是low（本轮递归的min参数，即上一轮员工分得的月饼数量）
        if remain - low <= 3:
            # 如果二者差距不超过maxDiff，则分月饼方案可行
            return 1
 
        # 否则方案不可行
        return 0
 
    # ans记录可行方案数
    ans = 0
 
    # i 是当前员工可以分得的月饼数量
    for i in range(low, high + 1):
        remain -= i
        # 下一个员工至少分得 i 个月饼（当前员工分得的月饼数量），至多分得 i + maxDiff
        # 同时下一个员工分得的月饼数量不能超过：均分月饼数量（即剩余月饼总数 / 剩余员工总数），否则破坏去重策略（为了保证分月饼的方案不重复，我们这里保证后面的员工分得月饼数不小于前面员工）
        ans += recursive(level + 1, i, min(i + 3, remain // (m - level - 1)), remain)
        remain += i
 
    return ans
 
 
# 算法入口
def getResult():
    if m == 1:
        # 如果只有一个员工分月饼，那么就只有一种方案
        return 1
    else:
        # 如果有多个员工分月饼，为了保证分月饼的方案不重复，我们这里保证 员工i的月饼数量 <= 员工i+1的月饼数量
        # 因此对于第0个员工，至少分得1个月饼，至多分得n/m个月饼（均分数量）
        return recursive(0, 1, n // m, n)
 
 
# 算法调用
print(getResult())
```

6. 连续出牌数量 回溯

**题目描述**
有这么一款单人卡牌游戏，牌面由颜色和数字组成，颜色为红、黄、蓝、绿中的一种，数字为0-9中的一个。游戏开始时玩家从手牌中选取一张卡牌打
如果玩家手中有和他上一次打出的手牌颜色或者数字相同的手牌，他可以继续将该手牌打出，直至手牌打光或者没有符合条件可以继续打出的手牌。
现给定一副手牌，请找到最优的出牌策略，使打出的手牌最多。
**输入描述**
输入为两行
第一行是每张手牌的数字，数字由空格分隔，
第二行为对应的每张手牌的颜色，用r y b g这4个字母分别代表4种颜色，字母也由空格分隔。
手牌数量不超过10。
**输出描述**
输出一个数字，即最多能打出的手牌的数量。
**用例**
输入 1 4 3 4 5
r y b b r
输出 3
说明 如果打（1, r）-> (5, r)，那么能打两张。
如果打（4，y) -> (4, b) -> (3, b)，那么能打三张。
输入 1 2 3 4
r y b l
输出 1
说明 没有能够连续出牌的组合，只能在开始时打出一张手牌，故输出1
**代码**
```python
class Solution:

    def solve(self, nums, colors):

        ans = 0
        used = [False] * len(nums)

        def dfs(cnt, used, last):
            nonlocal ans
            ans = max(ans, cnt)
            if False not in used:
                return

            for i in range(len(nums)):
                if not used[i]:
                    if last and last[0] != nums[i] and last[1] != colors[i]:
                        continue
                    used[i] = True
                    dfs(cnt+1, used, [nums[i], colors[i]])
                    used[i] = False
            return ans

        return dfs(0, used, None)


s = Solution()
print(s.solve([1,4,3,4,5], ['r', 'y', 'b', 'b', 'r']))
```

7. 攀登者 逻辑分析

**题目描述**
攀登者喜欢寻找各种地图，并且尝试攀登到最高的山峰。
地图表示为一维数组，数组的索引代表水平位置，数组的元素代表相对海拔高度。其中数组元素0代表地面。
例如：[0,1,2,4,3,1,0,0,1,2,3,1,2,1,0]，代表如下图所示的地图，地图中有两个山脉位置分别为 1,2,3,4,5 和 8,9,10,11,12,13，最高峰高度分别为 4,3。最高峰位置分别为3,10。
一个山脉可能有多座山峰(高度大于相邻位置的高度，或在地图边界且高度大于相邻的高度)。
登山时会消耗登山者的体力(整数)，
上山时，消耗相邻高度差两倍的体力
下山时，消耗相邻高度差一倍的体力
平地不消耗体力
登山者体力消耗到零时会有生命危险。
例如，上图所示的山峰：
从索引0，走到索引1，高度差为1，需要消耗 2 * 1 = 2 的体力，
从索引2，走到索引3，高度差为2，需要消耗 2 * 2 = 4 的体力。
从索引3，走到索引4，高度差为1，需要消耗 1 * 1 = 1 的体力。
攀登者想要评估一张地图内有多少座山峰可以进行攀登，且可以安全返回到地面，且无生命危险。
例如上图中的数组，有3个 不同的 山峰，登上位置在3的山可以从位置0或者位置6开始，从位置0登到山顶需要消耗体力 1 * 2 + 1 * 2 + 2 * 2 = 8，从山顶返回到地面0需要消耗体力 2 * 1 + 1 * 1 + 1 * 1 = 4 的体力，按照登山路线 0 → 3 → 0 需要消耗体力12。攀登者至少需要12以上的体力（大于12）才能安全返回。
**输入描述**
第一行输入为地图一维数组
第二行输入为攀登者的体力
**输出描述**
确保可以安全返回地面，且无生命危险的情况下，地图中有多少山峰可以攀登。
**代码**
```python
# 输入获取
heights = list(map(int, input().split(",")))
strength = int(input())
 
 
def climb(idxs, direction):
    # 找到第一个地面位置
    j = 0
    while j < len(heights) and heights[j] != 0:
        j += 1
 
    # 上山体力消耗
    # upCost = 0
    # 下山体力消耗
    # downCost = 0
 
    # 攀登体力总消耗（包括上山，下山）
    cost = 0
 
    for i in range(j + 1, len(heights)):
        # 如果遇到了新的地面，则从新的地面位置重新计算攀登消耗的体力
        if heights[i] == 0:
            cost = 0
            # upCost = 0
            # downCost = 0
            continue
 
        # diff记录高度差
        diff = heights[i] - heights[i - 1]
 
        if diff > 0:
            # 如果过程是上坡
            cost += diff * 3
            # upCost += diff * 2  # 则上山时，体力消耗 = 高度差 * 2
            # downCost += diff  # 相反的下山时，体力消耗 = 高度差 * 1
 
            # 由于 height[i] > heights[i-1]，因此如果 height[i] > heights[i+1] 的话，位置 i 就是山顶
            if i + 1 >= len(heights) or heights[i] > heights[i + 1]:
                # 计算攀登此山顶的上山下山消耗的体力和
                if cost < strength:
                    # if upCost + downCost <= strength:
                    # 如果不超过自身体力，则可以攀登
                    if direction:
                        idxs.add(i)
                    else:
                        idxs.add(len(heights) - i - 1)  # 需要注意，逆序heights数组后，我们对于的山峰位置需要反转
 
        elif diff < 0:
            # 如果过程是下坡
            cost -= diff * 3
            # upCost -= diff  # 则上山时，体力消耗 = 高度差 * 1
            # downCost -= diff * 2  # 相反的下山时，体力消耗 = 高度差 * 2
            # heights[i] < heights[i-1]，因此位置i不可能是山顶
 
 
# 算法入口
def getResult():
    # 记录可攀登的山峰索引
    idxs = set()
 
    # 正向攀登
    climb(idxs, True)
 
    # 逆序攀登
    heights.reverse()
    climb(idxs, False)
 
    return len(idxs)
 
 
# 算法调用
print(getResult())
```

8. 园区参观路径 dfs

**题目描述**
园区某部门举办了Family Day，邀请员工及其家属参加；
将公司园区视为一个矩形，起始园区设置在左上角，终点园区设置在右下角；
家属参观园区时，只能向右和向下园区前进，求从起始园区到终点园区会有多少条 不同的 参观路径。
**输入描述**
第一行为园区的长和宽；
后面每一行表示该园区是否可以参观，0表示可以参观，1表示不能参观
**输出描述**
输出为不同的路径数量
**用例**
输入
3 3
0 0 0
0 1 0
0 0 0
输出 2
说明 无
**代码**
```python
class Solution:

    def solve(self, m, n, matrix):
        ans = 0

        def dfs(x, y):
            nonlocal ans
            if x == m - 1 and y == n - 1:
                ans += 1
                return

            for dx, dy in [(0, 1), (1, 0)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] != 1:
                    dfs(nx, ny)

        dfs(0, 0)
        return ans


s = Solution()
print(s.solve(3,3,[[0,0,0],[0,0,0],[0,0,0]]))
```

9. 部门人力分配 二分+双指针

**题目描述**
部门在进行需求开发时需要进行人力安排。
当前部门需要完成 N 个需求，需求用 requirements 表述，requirements[i] 表示第 i 个需求的工作量大小，单位：人月。
这部分需求需要在 M 个月内完成开发，进行人力安排后每个月人力时固定的。
目前要求每个月最多有2个需求开发，并且每个月需要完成的需求不能超过部门人力。
请帮助部门评估在满足需求开发进度的情况下，每个月需要的最小人力是多少？
**输入描述**
输入为 M 和 requirements，M 表示需求开发时间要求，requirements 表示每个需求工作量大小，N 为 requirements长度，
1 ≤ N/2 ≤ M ≤ N ≤ 10000
1 ≤ requirements[i] ≤ 10^9
**输出描述**
对于每一组 测试数据 ，输出部门需要人力需求，行末无多余的空格
**用例**
输入 3
3 5 3 4
输出 6
说明
输入数据两行，
第一行输入数据3表示开发时间要求，
第二行输入数据表示需求工作量大小，
输出数据一行，表示部门人力需求。
当选择人力为6时，2个需求量为3的工作可以在1个月里
完成，其他2个工作各需要1个月完成。可以在3个月内完
成所有需求。
当选择人力为5时，4个工作各需要1个月完成，一共需要
4个月才能完成所有需求。
因此6是部门最小的人力需求。
**代码**
```python
class Solution:

    def solve(self, n, nums):
        l, r = max(nums), max(nums) + min(nums)
        while l < r:
            mid = (l + r) >> 1
            if self.get_res(mid, nums, n):
                r = mid
            else:
                l = mid + 1
        return l

    def get_res(self, target, nums, n):
        nums.sort()
        cnt = 0
        l, r = 0, len(nums) - 1
        while l < r:
            if nums[l] + nums[r] <= target:
                l += 1
                r -= 1
                cnt += 1
            else:
                r -= 1
                cnt += 1
        cnt += 1 if l == r else 0
        return True if cnt <= n else False


s = Solution()
print(s.solve(3,[3,5,3,4]))
```

10. 结对编程 二叉搜索树/暴力

**题目描述**
某部门计划通过结队编程来进行 项目开发 ，
已知该部门有 N 名员工，每个员工有 独一无二 的职级，每三个员工形成一个小组进行结队编程，结队分组规则如下：
从部门中选出序号分别为 i、j、k 的3名员工，他们的职级分贝为 level[i]，level[j]，level[k]，
结队小组满足 level[i] < level[j] < level[k] 或者 level[i] > level[j] > level[k]，
其中 0 ≤ i < j < k < n。
请你按上述条件计算可能组合的小组数量。同一员工可以参加多个小组。
**输入描述**
第一行输入：员工总数 n
第二行输入：按序号依次排列的员工的职级 level，中间用空格隔开
限制：
1 ≤ n ≤ 6000
1 ≤ level[i] ≤ 10^5
**输出描述**
可能结队的小组数量
**用例**
输入 4
1 2 3 4
输出 4
说明 可能结队成的组合(1,2,3)、(1,2,4)、(1,3,4)、(2,3,4)
输入 3
5 4 7
输出 0
说明 根据结队条件，我们无法为该部门组建小组
**代码**
```python
class Solution:

    def solve(self, n, nums):
        total = 0
        for i in range(1, n-1):
            leftsmallercnt = 0
            leftbiggercnt = 0
            for j in range(i):
                if nums[j] < nums[i]:
                    leftsmallercnt += 1
                else:
                    leftbiggercnt += 1
            rightsmallercnt = 0
            rightbiggercnt = 0
            for k in range(i+1, n):
                if nums[k] < nums[i]:
                    rightsmallercnt += 1
                else:
                    rightbiggercnt += 1
            total += leftsmallercnt * rightbiggercnt + leftbiggercnt * rightsmallercnt
        return total


s = Solution()
print(s.solve(4,[1,2,3,4]))
```

11. 数据单元的替换 递归

**题目描述**
将一个 csv 格式的数据文件中包含有单元格引用的内容替换为对应单元格内容的实际值。
comma separated values(CSV) 逗号分隔值，csv 格式的数据文件使用逗号 "," 作为分隔符将各单元的内容进行分隔。
**输入描述**
1. 输入只有一行数据，用逗号分隔每个单元格，行尾没有逗号。最多26个单元格，对应编号A~Z。
2. 每个单元格的内容包含字母和数字，以及使用 '<>' 分隔的单元格引用，例如：<A>表示引用第一个单元的值。
3. 每个单元格的内容，在替换前和替换后均不超过100个字符。
4. 引用单元格的位置不受限制，允许排在后面的单元格被排在前面的单元格引用。
5. 不存在循环引用的情况，比如下面这种场景是不存在的：
A单元恪：aCd<B>8U
B单元格：KAy<A>uZq0
6. 不存在多重 '<>' 的情况，一个单元只能引用一个其他单元格。比如下面这种场景是不存在的：
A单元格：aCdOu
B单元格：kAydzco
C单元格：y<<A><B>>d
**输出描述**
输出替换后的结果
**用例**
输入 1,2<A>00
输出 1,2100
说明 第二个单元中有对A单元的引用，A单元格的值为1，替换时，将
A单元的内容替代<A>的位置，并和其他内容合并。
输入 1<B>2,1
输出 112,1
说明 第一个单元中有对B单元的引用，B单元格的值为1，耆换时，将
第二个数据第单元的内容替代<B>的位置，并和其他内容合并
**代码**
```python
import re
 
regexp = re.compile(r"(<.*?>)")
 
# 输入获取
cells = input().split(",")
 
 
def changeCell(index):
    # 通过正则匹配出单元格内容中"引用字符串"
    matchers = regexp.findall(cells[index])
 
    # reference记录引用字符串
    for reference in matchers:
        # 引用单元格编号只能是A~Z的字母，即引用引用字符串长度只能是3，比如"<A>"
        if len(reference) != 3:
            return False
 
        # 引用单元格的编号
        reference_cellNum = reference[1]
        # 当前单元格的编号
        self_cellNum = chr(65 + index)
 
        # 引用单元格编号只能是A~Z的字母，且不能自引用
        if reference_cellNum < 'A' or reference_cellNum > 'Z' or reference_cellNum == self_cellNum:
            return False
 
        # 引用单元格的数组索引， 'A' -> 0  ... 'Z' -> 25
        reference_index = ord(reference_cellNum) - 65
 
        # 引用单元格编号不存在
        if reference_index >= len(cells):
            return False
 
        if not changeCell(reference_index):
            return False
 
        # 将单元格内容中的引用部分，替换为被引用的单元格的内容
        cells[index] = cells[index].replace(reference, cells[reference_index])
 
    return True
 
 
# 算法入口
def getResult():
    if len(cells) > 26:
        # 最多26个单元格，对应编号A~Z
        return "-1"
 
    for i in range(len(cells)):
        # 替换单元格中的引用
        if not changeCell(i):
            # 替换失败，则返回-1
            return "-1"
 
        if len(cells[i]) > 100:
            # 每个单元格的内容，在替换前和替换后均不超过100个字符
            return "-1"
 
        if not re.match(r"^[a-zA-Z0-9]+$", cells[i]):
            # 每个单元格的内容包含字母和数字
            return "-1"
 
    return ",".join(cells)
 
 
# 算法调用
print(getResult())
```

12. 高效货运 完全背包/暴力枚举

**题目描述**
老李是货运公司承运人，老李的货车额定载货重量为 wt。
现有两种货物：
货物 A 单件重量为 wa，单件运费利润为 pa
货物 B 单件重量为 wb，单件运费利润为 pb
老李每次发车时载货总重量刚好为货车额定的载货重量 wt，车上必须同时有货物 A 和货物 B ，货物A、B不可切割。
老李单次满载运输可获得的最高利润是多少？
**输入描述**
第一列输入为货物 A 的单件重量 wa
0 < wa < 10000
第二列输入为货物 B 的单件重量 wb
0 < wb < 10000
第三列输入为货车的额定载重 wt
0 < wt < 100000
第四列输入为货物 A 的单件运费利润 pa
0 < pa < 1000
第五列输入为货物 B 的单件运费利润 pb
0 < pb < 1000
**输出描述**
单次满载运输的最高利润
**用例**
输入 10 8 36 15 7
输出 44
说明 无
输入 1 1 2 1 1
输出 2
说明 无
**代码**
```python
class Solution:

    def solve(self, wa, wb, target, va, vb):
        target -= wa + wb
        total = va + vb
        w = [wa, wb]
        v = [va, vb]
        dp = [float('-inf')] * (target + 1)
        dp[0] = 0
        for i in range(2):
            for j in range(w[i], target+1):
                    dp[j] = max(dp[j], dp[j-w[i]] + v[i])
        return dp[-1] + total

s = Solution()
print(s.solve(1,1,2,1,1))
```

13. 找数字 位运算

**题目描述**
小扇和小船今天又玩起来了 数字游戏 ，
小船给小扇一个正整数 n（1 ≤ n ≤ 1e9），小扇需要找到一个比 n 大的数字 m，使得 m 和 n 对应的二进制中 1 的个数要相同，如：
4对应二进制100
8对应二进制1000
其中1的个数都为1个
现在求 m 的 最小值 。
**输入描述**
输入一个正整数 n（1 ≤ n ≤ 1e9）
**输出描述**
输出一个正整数 m
**用例**
输入 2
输出 4
说明
2的二进制10，
4的 二进制位 100，
1的个数相同，且4是满足条件的最小数
输入 7
输出 11
说明
7的二进制111，
11的二进制位1011，
1的个数相同，且11是满足条件的最小数
**代码**
```python
class Solution:

    def solve(self, n):
        tmp = n
        index = 0
        flag = False
        while n:
            if n & 1:
                flag = True
            elif not n & 1 and flag:
                break
            index += 1
            n >>= 1
        return tmp + 2 ** (index - 1)


s = Solution()
print(s.solve(2))
```

14. 中文分词模拟器 逻辑分析

**题目**
```
给定一个连续不包含空格的 字符串 ，该字符串仅包含英文小写字母及英文标点符号(逗号、分号、句号)，同时给定词库，对该字符串进行精确分
说明:
1.精确分词: 字符串分词后，不会出现重叠
即"ilovechina",不同词库可分割为",love,china”，“ilove,china”不能分割出现重叠的"ilove,china"i 出现重叠。
2.标点符号不成词，仅用于断句
3.词库: 根据外部 知识库 统计出来的常用词汇例:
dictionary =["i",“love”,“china”,“lovechina”,“ilove”]
4.分词原则: 采用分词顺序优先且最长匹配原则
“llovechina”假设分词结果[i,ilove,lo,love,ch,china,lovechina],则输出[ilove,china]
错误输出: [i,lovechina],原因:“ilove”>优先于"lovechina"成词
错误输出: [i,love,china],原因:“love”>"遵循最长匹配原则
```
**输入描述**
```
第一行输入待分词语句 S
第二行输入中文词库
字符串 S 长度限制: 0 < S.length < 256
词库长度限制: 1 < length < 100000
```
**输出描述**
```
按顺序输出分词结果
```
**示例1：**
```
输入：
ilovechina
i,love,china,ch,na,ve,lo,this,is,the,word
输出：
i,love,china
```
**示例2：**
```
输入：
iat
i,love,china,ch,na,ve,lo,this,is,the,word,beauti,tiful,ful
输出：
i,a,t
```
**示例3：**
```
输入：
ilovechina,thewordisbeautiful
i,love,china,ch,na,ve,lo,this,is,the,word,beauti,tiful,ful
输出：
i,love,china,the,word,is,beauti,fu
```
**代码**
```python
import re
 
# 输入获取
sentences = list(filter(lambda x: x != "", re.split(r"[,.;]", input())))
words = list(filter(lambda x: x != "", re.split(r"[,.;]", input())))
 
 
def getResult():
    # wordSet 记录词库词汇
    wordSet = set(words)
    # ans记录最终分词结果
    ans = []
 
    while len(sentences) > 0:
        # 待分词的句子
        sentence = sentences.pop(0)
 
        r = len(sentence)
        while r > 0:
            # 截取句子 [0,r) 范围子串词汇, 这样的就能实现优先最长匹配，并且由于是必须从0索引开始截取，因此满足了分词顺序优先
            fragment = sentence[0:r]
 
            # 若词库中是否存在该子串词汇
            if fragment in wordSet:
                # 则将对应子串词汇纳入结果
                ans.append(fragment)
                wordSet.remove(fragment)  # 我理解词库中每个词汇只能使用一次，因此这里将词库中使用过的词汇移除
 
                # 若子串词汇只是句子部分，则句子剩余部分还要继续去词库中查找
                if r < len(sentence):
                    sentences.insert(0, sentence[r:])
 
                break
 
            r -= 1
 
        # 没有在词库中找到对应子串词汇，则输出单个字母
        if r == 0:
            # 注意，这里只放一个字母到结果中，句子剩余部分继续去词库中查找
            ans.append(sentence[0])
 
            if len(sentence) > 1:
                sentences.insert(0, sentence[1:])
 
    return ",".join(ans)
 
 
print(getResult())
```

15. 符号运算 栈

**题目描述**
给定一个表达式，求其分数计算结果。
表达式的限制如下：
1. 所有的输入数字皆为正整数（包括0）
2. 仅支持四则运算（+-*/）和括号
3. 结果为整数或分数，分数必须化为最简格式（比如6，3/4，7/8，90/7）
4. 除数可能为0，如果遇到这种情况，直接输出"ERROR"
5. 输入和最终计算结果中的数字都不会超出整型范围
用例输入一定合法，不会出现 括号匹配 的情况
**输入描述**
字符串 格式的表达式，仅支持+-*/，数字可能超过两位，可能带有空格，没有负数
长度小于200个字符
**输出描述**
表达式结果，以最简格式表达
如果结果为整数，那么直接输出整数
如果结果为负数，那么分子分母不可再约分，可以为假分数，不可表达为带分数
结果可能是负数，符号放在前面
**用例**
输入 1 + 5 * 7 / 8
输出 43/8
说明 无
输入 1 / (0 - 5)
输出 -1/5
说明 符号需要提到最前面
输入 1 * (3*4/(8-(7+0)))
输出 12
说明 注意括号可以多重嵌套
**代码**
```python
class Num:
    def __init__(self, up, down):
        self.up = up
        self.down = down

class Sign:
    def __init__(self, value):
        self.value = value
        if value in ['*', '/']:
            self.pri = 3
        elif value in ['+', '-']:
            self.pri = 2
        else:
            self.pri = 1

class Solution:

    def solve(self, strs):
        sign_stack, num_stack, num_cache = [], [], []
        for x in strs:
            if x.isdigit():
                num_cache.append(x)
            else:
                sign = Sign(x)
                if sign.value == '(':
                    sign_stack.append(sign)
                    continue
                elif sign.value == ')':
                    if num_cache:
                        num = Num(int(''.join(num_cache)), 1)
                        num_cache = []
                        num_stack.append(num)
                    while sign_stack[-1].value != '(':
                        num2 = num_stack.pop()
                        num1 = num_stack.pop()
                        pre_sign = sign_stack.pop()
                        cur_num = self.get_cal(num1, num2, pre_sign)
                        if cur_num == 'ERROR':
                            return cur_num
                        num_stack.append(cur_num)
                    sign_stack.pop()
                    continue

                num = Num(int(''.join(num_cache)), 1)
                num_cache = []
                num_stack.append(num)
                while sign_stack and sign.pri <= sign_stack[-1].pri:
                    num2 = num_stack.pop()
                    num1 = num_stack.pop()
                    pre_sign = sign_stack.pop()
                    cur_num = self.get_cal(num1, num2, pre_sign)
                    if cur_num == 'ERROR':
                        return cur_num
                    num_stack.append(cur_num)
                sign_stack.append(sign)



        while sign_stack and num_stack:
            num2 = num_stack.pop()
            num1 = num_stack.pop()
            pre_sign = sign_stack.pop()
            cur_num = self.get_cal(num1, num2, pre_sign)
            if cur_num == 'ERROR':
                return cur_num
            num_stack.append(cur_num)
        final_num = num_stack[0]
        if final_num.up < 0 and final_num.down < 0:
            final_sign = ''
        elif final_num.up > 0 and final_num.down > 0:
            final_sign = ''
        else:
            final_sign = '-'
        gcd_num = self.gcd(abs(final_num.up), abs(final_num.down))
        if abs(final_num.down) == gcd_num:
            return final_sign + str(abs(final_num.up) // gcd_num)
        else:
            return final_sign + str(abs(final_num.up) // gcd_num) + '/' + str(abs(final_num.down) // gcd_num)

    def gcd(self, a, b):
        while b:
            a, b = b, a % b
        return a

    def get_cal(self, num1, num2, sign):
        if sign.value == '+':
            cur_up = num1.up * num2.down + num1.down * num2.up
            cur_down = num1.down * num2.down
        elif sign.value == '-':
            cur_up = num1.up * num2.down - num1.down * num2.up
            cur_down = num1.down * num2.down
        elif sign.value == '*':
            cur_up = num1.up * num2.up
            cur_down = num1.down * num2.down
        else:
            if num2.up == 0:
                return 'ERROR'
            cur_up = num1.up * num2.down
            cur_down = num1.down * num2.up
        return Num(cur_up, cur_down)


s = Solution()
print(s.solve('1*(3*4/(8-(7+6)))'))
```

16. 根据IP查找城市 逻辑分析

**题目**
```
某业务需要根据终端的 IP地址 获取该终端归属的城市，可以根据公开的IP地址池信息查询归属城市地址池格式如下: 城市名=起始IP，结束IP
起始和结束地址按照英文逗号分隔，多个地址段采用英文分号分隔。比如:
City1=1.1.1.1,1.1.1.2;City1=1.1.1.1,1.1.1.16;City2=3.3.3.3,4.4.4.4;City3=2.2.2.2,6.6.6.6一个城市可以有多个IP段，比如City1有2个IP段城市间也可
包含关系，如City3的IP段包含City2的IP段范围
现在要根据输入的IP列表，返回最佳匹配的城市列表
注:最佳匹配即包含待查询P且长度最小的IP段，比如例子中
3.4.4.4 最佳匹配是City2=3.3.3.3,4.4.4.4，
5.5.5.5的最佳匹配是City3=2.2.2.2,6.6.6.6
```
**输入描述**
```
输入共2行。
第一行为城市的IP段列表，多个IP段采用英文分号， 分隔，IP段列表最大不超过500000。城市名称只包含 英文字母 、数字和下划线。最多不超
100000个。IP段包含关系可能有多层，但不超过100层。
第二行为查询的IP列表，多个IP采用英文逗号“，分隔，最多不超过10000条
```
**输出描述**
```
最佳匹配的城市名列表，采用英文逗号，分隔，城市列表长度应该跟查询的IP列表长度一致。
备注
。无论是否查到匹配正常都要输出分隔符。举例: 假如输入IP列表为IPa,IPb，两个IP均未有匹配城市，此时输出为","即只有一个逗号分隔符，两个
空;
可以假定用例中的所有输入均合法，IP地址均为合法的ipv4地址，满足(1/255),(0/255)(0/255,0/255)的格式，且可以假定用例中不会出现组播和广播
```
**示例1：**
```
输入:
City1=1.1.1.1,1.1.1.2;City1=1.1.1.1,1.1.1.16;City2=3.3.3.3,4.4.4.4;City3=2.2.2.2,6.6.6.6
3.4.4.4,5.5.5.5
输出：
City2,City3
```
**思路**
```
1：题目比较核心的一个点：【起始IP，结束IP】，这里我们首先要做的一个事，就是拿到这个区间内的所有IP，一般的ip表达是 xxx.xxx.xxx.xxx 数字组成，每个数字的最大上限为255，这样我们其实可以用一个8位的二进制数组来表达每个数组，再将四个数字的对应二进制数组合并，这样我
以得到一个正整数，用这个正整数，我们就可以很方便的获取对应其中的IP了。
```
**代码**
```python
class Solution:
    def trans(self, ip):
        ips = [int(x) for x in ip.split('.')]
        ans = 0
        for i in range(4):
            ans <<= 8
            ans |= ips[i]
        return ans

    def solve(self, citys, targets):
        mp = {}
        city_name = set()
        citys_list = citys.split(';')
        for city in citys_list:
            name = city.split('=')[0]
            city_name.add(name)
            ip_range = city.split('=')[1]
            start, end = self.trans(ip_range.split(',')[0]), self.trans(ip_range.split(',')[1])
            if name not in mp:
                mp[name] = [[start, end]]
            else:
                mp[name].append([start, end])
        target_list = targets.split(',')
        ans = ''
        for target in target_list:
            out = ''
            size = float('inf')
            cur_city = None
            target_num = self.trans(target)
            for city in city_name:
                for range in mp[city]:
                    if range[0] <= target_num and range[1] >= target_num:
                        if range[1] - range[0] < size:
                            size = range[1] - range[0]
                            out = city
                        elif range[1] - range[0] == size:
                            if city > cur_city:
                                out = city
                                cur_city = city
            ans += out + ','
        return ans[:-1]


s = Solution()
print(s.solve('City1=1.1.1.1,1.1.1.2;City1=1.1.1.1,1.1.1.16;City2=3.3.3.3,4.4.4.4;City3=2.2.2.2,6.6.6.6',
              '3.4.4.4,5.5.5.5'))
```

17. 文件缓存系统 哈希表+双向链表

**题目描述**
请设计一个文件 缓存系统 ，该文件缓存系统可以指定缓存的最大值（单位为字节）。
文件缓存系统有两种操作：
存储文件（put）
读取文件（get）
操作命令为：
put fileName fileSize
get fileName
存储文件是把文件放入文件缓存系统中；
读取文件 是从文件缓存系统中访问已存在，如果文件不存在，则不作任何操作。
当缓存空间不足以存放新的文件时，根据规则删除文件，直到剩余空间满足新的文件大小位置，再存放新文件。
具体的删除规则为：
文件访问过后，会更新文件的最近访问时间和总的访问次数，当缓存不够时，按照第一优先顺序为访问次数从少到多，第二顺序为时间从老到新的方式
件。
**输入描述**
第一行为缓存 最大值 m（整数，取值范围为 0 < m ≤ 52428800）
第二行为文件操作序列个数 n（0 ≤ n ≤ 300000）
从第三行起为文件操作序列，每个序列单独一行，文件操作定义为：
op file_name file_size
file_name 是文件名，file_size 是文件大小
**输出描述**
输出当前文件缓存中的文件名列表，文件名用英文逗号分隔，按字典顺序排序，如：
a,c
如果文件缓存中没有文件，则输出NONE
备注
1. 如果新文件的文件名和文件缓存中已有的文件名相同，则不会放在缓存中
2. 新的文件第一次存入到文件缓存中时，文件的总访问次数不会变化，文件的最近访问时间会更新到最新时间
3. 每次文件访问后，总访问次数加1，最近访问时间更新到最新时间
4. 任何两个文件的最近访问时间不会重复
5. 文件名不会为空，均为小写字母，最大长度为10
6. 缓存空间不足时，不能存放新文件
7. 每个文件大小都是大于 0 的整数
**用例**
输入
50
6
put a 10
put b 20
get a
get a
get b
put c 30
输出 a,c
说明 无
输入
50
1
get file
输出 NONE
说明 无
**代码**
**LFU**
```python
class Node:
    def __init__(self, key=None, value=None, freq=None):
        self.key = key
        self.value = value
        self.freq = freq
        self.next = None
        self.pre = None

class Solution:
    def __init__(self, capacity):
        self.keymap = {}
        self.freqmap = {}
        self.capacity = capacity
        self.cur_capacity = 0
        self.min_freq = 1
        self.head = []
        self.tail = []

    def solve(self, n, operations):
        for i in range(n):
            op = operations[i].split(' ')
            if len(op) == 2:
                self.get(op[1])
            elif len(op) == 3:
                self.put(op[1], int(op[2]))
        return ','.join(sorted(list(self.keymap.keys())))


    def insert_to_tail(self, node, freq):
        node.next = self.tail[freq-1]
        node.pre = self.tail[freq-1].pre
        self.tail[freq-1].pre.next = node
        self.tail[freq-1].pre = node


    def change_node_freq(self, node, pre_freq, cur_freq):
        if cur_freq not in self.freqmap:
            self.head.append(Node())
            self.tail.append(Node())
            self.head[-1].next = self.tail[-1]
            self.tail[-1].pre = self.head[-1]
            self.freqmap[cur_freq] = self.head[-1]
        if pre_freq:
            node.pre.next = node.next
            node.next.pre = node.pre
            if self.min_freq == pre_freq and not self.head[pre_freq - 1].next.value:
                self.min_freq = cur_freq
        if cur_freq < self.min_freq:
            self.min_freq = cur_freq
        self.insert_to_tail(node, cur_freq)

    def get(self, key):
        res = self.keymap.get(key, -1)
        if res == -1:
            pass
        else:
            res.freq += 1
            self.change_node_freq(res, res.freq - 1, res.freq)
            print(res.value)

    def remove_node(self):
        node = self.head[self.min_freq - 1].next
        node.pre.next = node.next
        node.next.pre = node.pre
        del self.keymap[node.key]
        if node.next.value == None:
            max_freq = max(list(self.freqmap.keys()))
            for i in range(1, max_freq+1):
                if self.head[i-1].next.value:
                    self.min_freq = i
                    break
            else:
                self.min_freq = 0

        return node.value

    def put(self, key, value):
        if key not in self.keymap:
            while self.cur_capacity + value > self.capacity:
                self.cur_capacity -= self.remove_node()
            new_node = Node(key, value, 1)
            self.change_node_freq(new_node, None, 1)
            self.cur_capacity += value
            self.keymap[key] = new_node


s = Solution(50)
print(s.solve(6, ['put a 10', 'put b 20', 'get a', 'get a', 'get b', 'put c 30']))
```

**LRU**
```python
class ListNode:
    def __init__(self, key=None, value=None):
        self.key = key
        self.value = value
        self.next = None
        self.pre = None

class LRUCache:

    def __init__(self, capacity: int):
        # 哈希表存储 key: node
        self.hashmap = {}
        # 容量
        self.capacity = capacity
        # 头节点
        self.head = ListNode()
        # 尾节点
        self.tail = ListNode()
        # 连接头尾节点
        self.head.next = self.tail
        self.tail.pre = self.head

    def move_to_tail(self, key):
        # 从哈希表中获取key对应node
        node = self.hashmap[key]
        # 断开node
        node.pre.next = node.next
        node.next.pre = node.pre
        # node插入尾节点之前
        node.next = self.tail
        node.pre = self.tail.pre
        self.tail.pre = node
        node.pre.next = node

    def get(self, key: int) -> int:
        # 从哈希表获取key对应结果
        res = self.hashmap.get(key, -1)
        if res == -1:
            # 不存在返回-1
            return -1
        else:
            # 将key对应node移到末尾
            self.move_to_tail(key)
            # 返回结果
            return res.value

    def put(self, key: int, value: int) -> None:
        # 如果key已存在在哈希表中
        if key in self.hashmap:
            # 更新哈希表key对应node的value
            self.hashmap[key].value = value
            # 将key对应node移到末尾
            self.move_to_tail(key)
        # key不存在于哈希表中
        else:
            # 如果当前哈希表长度已达到最大容量，需要删除一个最长未使用节点，也就是头节点的下一个节点
            if len(self.hashmap) == self.capacity:
                # 从哈希表中删除头节点下一个节点key对应的数据
                self.hashmap.pop(self.head.next.key)
                # 双向链表中删除该节点
                self.head.next = self.head.next.next
                self.head.next.pre = self.head
            # 定义一个新节点
            node = ListNode(key, value)
            # key: node 存储于哈希表中
            self.hashmap[key] = node
            # 新节点插入到尾节点之前
            node.next = self.tail
            node.pre = self.tail.pre
            self.tail.pre = node
            node.pre.next = node
```

18. 员工派遣 二分法

**题目**
```
某公司部门需要派遣员工去国外做项目。
现在，代号为 x 的国家和代号为 y 的国家分别需要 cntx 名和 cnty 名员工部门每个员工有一个员工号 (1,2,3,......)，工号连续，从 1开始。部长派遣
则: 规则1: 从 1,k中选择员工派遣出去
规则2: 编号为 x的倍数的员工不能去 x国，编号为 y 的倍数的员工不能去y 国
问题
找到最小的k，使得可以将编号在 [1,k] 中的员工分配给 x 国和 y 国，且满足 x 国和 y 国的需求
```
**输入描述**
```
四个整数 x,y,cntx,cnty。
2 < x < y < 30000
x和y 一定是 质数
1 < cntx, cnty < 10^9
cntx + cnty < 10^9
```
**输出描述**
```
满足条件的最小的 k
```
**示例1：**
```
输入：
2 3 3 1
输出：
5
说明: 输入中：
2 表示国家代号 2
3 表示国家代号 3
3 表示国家 2 需要3 个人
1 表示国家 3 需要1个人
输出的5表示k最小为5
```
**思路**
```
1：C卷的场景题特别多，我们需要阅读题干来获取题目想表达的真是题意。这个题目的最后一句：【使得可以将编号在 [1,k] 中的员工分配给 x 国
且满足 x 国和 y 国的需求】，其实核心就是规则2：【编号为 x的倍数的员工不能去 x国，编号为 y 的倍数的员工不能去y 国】
2：那这样的话，其实就是求1~k中，是x的倍数的个数（可以去y国），和是y的倍数的个数（可以去x国），如果既不是x也不是y的倍数，也需要纳
3：首先，1~k中能够被x整除的数个数为 k/x, 能够被y整除的个数为k/y，这个属于数学的前置知识了。其次，1~k中,既能被x整除，也能够被y整除的
就是 k/x*y。这样的话，既不是x也不是y的倍数，就是 k-k/x-k/y-k/x*y。
4：我们主要求的就是【既不是x也不是y的倍数】，因为这个数可以分给两者。从直觉上来说，k越大，肯定数字越多，满足条件的可能性也就越大
们可以使用二分法来判定当前的数字是否满足条件。
```
**代码**
```python
class Solution:

    def solve(self, x, y, cx, cy):
        left = 0
        right = pow(10, 9)
        while left < right:
            mid = (left + right) >> 1
            # cx - mid//y + mid//(x*y) 求的是x用y的倍数去填，但是不用公倍数，还需要几个非x y倍数的人
            # cy - mid//x + mid//(x*y) 求的是y用x的倍数去填，但是不用公倍数，还需要几个非x y倍数的人
            # 负数代表另一家公司倍数的人够用，不需要额外的人，为0
            target = max(0, cx - mid//y + mid//(x*y)) + max(0, cy - mid//x + mid//(x*y))
            # 如果非x y倍数的人大于等于需要的，右边界更新为mid
            if mid - mid//x - mid//y + mid//(x*y) >= target:
                right = mid
            else:
                left = mid + 1
        return left

s = Solution()
print(s.solve(2,3,3,1))
```

19. 跳格子3 动态规划

**题目**
```
小明和朋友们一起玩跳格子游戏，每个格子上有特定的分数score = [1 -1-6 7 -17 7]，从起点score[0]开始，每次最大的步长为k，请你返回小明跳到
score[n-1]时，能得到的最大得分。
注
格子的总长度和步长的区间在[1，100000]
每个格了的分数在[-10000,10000]区间中
```
**输入描述**
```
6//第一行输入总的格了数量
1 -1 -6 7 -17 7/第二行输入每个格子的分数score[i]
2//第三行输入最大跳的步长k
```
**输出描述：**
```
一个整数代表最大得分。
```
**示例1：**
```
输入：
6
1 -1 -6 7 -17 7
2
输出：
14
```
**代码**
```python
class Solution:

    def solve(self, nums, k):
        n = len(nums)
        dp = [float('-inf')] * n
        dp[0] = nums[0]
        for i in range(1, k):
            dp[i] = nums[i] + max(dp[:i])
        for j in range(k, n):
            dp[j] = nums[j] + max(dp[j-k:j])
        return dp[-1]


s = Solution()
print(s.solve([1,-1,-6,7,-17,7], 2))
```

20. 贪吃的猴子 逻辑分析

**题目**
```
一只贪吃的猴子，来到一个果园，发现许多串香蕉排成一行，每串香蕉上有若干根香蕉。每串香蕉的根数由数组numbers给出。猴子获取香蕉，每
从行的开头或者未尾获取，并且只能获取N次，求猴子最多能获取多少根香蕉。
```
**输入描述**
```
第一行为数组numbers的长度
第二行为数组numbers的值每个数字通过空格分开
第三行输入为N，表示获取的次数
```
**输出描述**
```
按照题目要求能获取的最大数值
```
**示例1**
```
输入
7
1 2 2 7 3 6 1
3
输出
10
```
**示例2**
```
输入
3
1 2 3
3
输出
6
说明
全部 获取所有 的香蕉，因此最终根数为1+2+3 = 6
```
**示例3：**
```
输入
4
4 2 2 3
2
输出
7
说明
第一次获取香蕉为行的开头，第二次获取为行的末尾，因此最终根数为4+3 =7
```
**代码**
```python
class Solution:

    def solve(self, n, bananas, m):
        tmp = 0
        for i in range(m):
            tmp += bananas[i]
        res = tmp
        left = m-1
        right = n-1
        while left >= 0:
            tmp += bananas[right] - bananas[left]
            if tmp > res:
                res = tmp
            left -= 1
            right -= 1
        return res

s = Solution()
print(s.solve(6, [2,4,3,2,10,1], 2))
```

21. 项目排期 二分+回溯

**题目描述**
项目组共有 N 个开发人员，项目经理接到了 M 个独立的需求，每个需求的工作量不同，且每个需求只能由一个开发人员独立完成，不能多人合作。
假定各个需求直接无任何先后 依赖关系 ，请设计算法帮助项目经理进行工作安排，使整个项目能用最少的时间交付。
**输入描述**
第一行输入为 M 个需求的工作量，单位为天，用逗号隔开。
例如：
X1 X2 X3 ... Xm
表示共有 M 个需求，每个需求的工作量分别为X1天，X2天，...，Xm天。其中：
0 < M < 30
0 < Xm < 200
第二行输入为项目组人员数量N
例如：
5
表示共有5名员工，其中 0 < N < 10
**输出描述**
最快完成所有工作的天数
例如：
25
表示最短需要25天完成所有工作
**用例**
输入
6,2,7,7,9,3,2,1,3,11,4
2
输出
28
**代码**
```python

# 输入获取
balls = list(map(int, input().split()))
n = int(input())
 
 
def check(index, buckets, limit):
    """
    :param index: 要被装入球的（balls）索引
    :param buckets: 桶数组，buckets[i]记录第i个桶的已经使用的容量
    :param limit: 每个桶的最大容量，即限制
    :return: k个桶（每个桶容量limit）是否可以装下所有balls
    """
    if index == len(balls):
        # 如果balls已经取完，则说明k个limit容量的桶，可以装完所有balls
        return True
 
    # select是当前要装的球
    selected = balls[index]
 
    # 遍历桶
    for i in range(len(buckets)):
        # 剪枝优化
        if i > 0 and buckets[i] == buckets[i - 1]:
            continue
 
        # 如果当前桶装了当前选择的球后不超过容量限制，则可以装入
        if selected + buckets[i] <= limit:
            buckets[i] += selected
            # 递归装下一个球
            if check(index + 1, buckets, limit):
                return True
            # 如果这种策略无法装完所有球，则回溯
            buckets[i] -= selected
 
    return False
 
 
# 算法入口
def getResult():
    # 这里对balls降序，有利于降低后面回溯操作的复杂度
    balls.sort(reverse=True)
 
    # 分范围：即每个桶的容量最小，最大值
    low = balls[0]  # 桶至少要有max(balls)的容量
    high = sum(balls)  # 当只有一个桶时，此时该桶容量要装下所有balls
 
    # 记录题解
    ans = high
 
    # 二分找中间值作为桶容量
    while low <= high:
        mid = (low + high) >> 1
 
        if check(0, [0] * n, mid):
            # 如果k个mid容量的桶，可以装完所有balls，那么mid容量就是一个可能解，但不一定是最优解，我们应该尝试更小的桶容量
            ans = mid
            high = mid - 1
        else:
            # 如果k个mid容量的桶，无法装完所有balls，那么说明桶容量取小了，我们应该尝试更大的桶容量
            low = mid + 1
 
    return ans
 
 
# 算法调用
print(getResult())
 
```

22. 亲子游戏 BFS

**题目描述**
宝宝和妈妈参加亲子游戏，在一个二维矩阵（N*N）的格子地图上，宝宝和妈妈抽签决定各自的位置，地图上每个格子有 不同的 糖果数量，部分格子有障碍物。
游戏规则 是妈妈必须在最短的时间（每个单位时间只能走一步）到达宝宝的位置，路上的所有糖果都可以拿走，不能走障碍物的格子，只能上下左右走。
请问妈妈在最短到达宝宝位置的时间内最多拿到多少糖果（优先考虑最短时间到达的情况下尽可能多拿糖果）。
**输入描述**
第一行输入为 N，N 表示二维矩阵的大小
之后 N 行，每行有 N 个值，表格矩阵每个位置的值，其中：
-3：妈妈
-2：宝宝
-1：障碍
≥0：糖果数（0表示没有糖果，但是可以走）
**输出描述**
输出妈妈在最短到达宝宝位置的时间内最多拿到多少糖果，行末无多余空格
备注
地图最大 50*50
**用例**
输入
4
3 2 1 -3
1 -1 1 1
1 1 -1 2
-2 1 2 3
输出 9
说明
此地图有两条 最短路径 可到达宝宝位置，绿色线和黄
色线都是最短路径6步，但黄色拿到的糖果更多，9个。
输入
4
3 2 1 -3
-1 -1 1 1
1 1 -1 2
-2 1 -1 3
输出 -1
说明
此地图妈妈无法到达宝宝位置
**代码**
```python
class Solution:

    def solve(self, n, matrix):
        queue = []
        total = 0
        for x in range(n):
            for y in range(n):
                if matrix[x][y] == -3:
                    queue.append([x, y, 0])
                    break
        flag = False
        while queue:

            if not flag:
                for _ in range(len(queue)):
                    node = queue.pop(0)
                    matrix[node[0]][node[1]] = -1
                    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nx, ny = node[0] + dx, node[1] + dy
                        if 0 <= nx < n and 0 <= ny < n and matrix[nx][ny] != -1:
                            queue.append([nx, ny, matrix[nx][ny] + node[2]])
                            if matrix[nx][ny] == -2:
                                flag = True
            else:
                for _ in range(len(queue)):
                    node = queue.pop(0)
                    if matrix[node[0]][node[1]] == -2:
                        total = max(total, node[2] + 2)
        return total if total else -1


s = Solution()
print(s.solve(4, [[3,2,1,-3], [-1,-1,1,1],[1,1,-1,2],[-2,1,-1,3]]))
```

23. 可处理的最大任务数 优先队列

*题目**
```
在某个项目中有多个任务(用 tasks 数组表示) 需要您进行处理，其中 tasks[i] = [si, ei] 你可以在 s[i] <= day <= e[i]中的任意天处理该任务。请返回你
理的最大任务数。
注:一天可以完成一个任务的处理
```
**输入描述:** 
```
第一行为任务数量n,1<= n<= 100000。
后面n行表示各任务的开始时间和终止时间，用 si和ei表示，1= si<= ei<=100000.
```
**输出描述:**
```
输出为一个整数，表示可以处理的最大任务数
```
**示例1**
```
输入:
3
1 1
1 2
1 3
输出:
3
说明: 第一天处理任务 1，第二天处理任务 2，第三天处理任务 3。
```
**解析**
```
1、统计输入的所有任务的时间段，仅按照结束时间降序，得到数组ranges
2、定义一个优先队列pq，仅用于保存任务的开始时间（开始时间越大，优先级越高），我们可以认为优先队列中保存的任务（的开始时间）对应的结束时间都是相同的，我们定义这个公共结束时间为pq_end
3、遍历ranges，得到每一个任务的开始，结束时间range：[start, end]，然后比较遍历到任务的end 和 优先队列中所有任务的公共结束时间pq_end：
如果 end < pq_end，则在end ~ pq_end 这段间隔时间内，我们可以从pq中挑选出pq_end - end 个 较短任务进行执行，执行前需要检查 对应任务的开始时间 start <= pq_end，若不满足则不执行。每执行一个任务，则pq_end -= 1，count += 1（count是已执行的任务数量）。当pq_end == end时，则将当前遍历的任务的start 加入 优先队列。
```
**代码**
```python
import heapq
import sys
 
# 输入获取
n = int(input())
ranges = [list(map(int, input().split())) for _ in range(n)]
 
 
# 算法入口
def getResult():
    # 将所有任务按照结束时间降序
    ranges.sort(key=lambda x: -x[1])
 
    # 优先队列中记录的是任务的开始时间，并且开始时间越大，优先级越高
    # 由于heapq默认是数值越小，优先级越大，因此这里存入负数的开始时间到pq
    pq = []
 
    # 优先队列中记录的是结束时间相同的任务的开始时间，pq_end就是优先队列中任务的相同结束时间
    pq_end = sys.maxsize
 
    # 最大任务数
    count = 0
 
    # 当前任务的开始和结束时间
    for start, end in ranges:
        # 如果当前任务的结束时间 小于 优先队列中记录的任务的结束时间，则两个结束时间之间的间隔时间段，可以处理一些紧急任务
        while len(pq) > 0 and end < pq_end:
            # 这里的紧急任务即指时间短的任务，即开始时间比较大的任务
            if -heapq.heappop(pq) <= pq_end:
                # 如果紧急任务的开始时间未超过其结束时间，则可以执行
                count += 1
                pq_end -= 1  # 一个时刻只执行一个任务
 
        # 间隔时间消耗完后，优先队列中的任务的结束时间全部更新为当前任务的结束时间
        heapq.heappush(pq, -start)
        pq_end = end
 
    # 收尾处理
    while len(pq) > 0:
        if -heapq.heappop(pq) <= pq_end:
            count += 1
            pq_end -= 1
 
    return count
 
 
# 算法调用
print(getResult())
```

24. 推荐多样性 逻辑分析

**题目**
```
推荐多样性需要从多个列表中选择元素，一次性要返回N屏数据(窗口数量)，每屏展示K个元素(窗口大小)，选择策略
1.各个列表元素需要做穿插处理，即先从第一个列表中为每屏选择一元素，再从第二个列表中为每屏选择一个元素，依次类推
2.每个列表的元素尽量均分为N份，如果不够N个，也要全部分配完，比如下面的例子:
(1)从第一个列表中选择4条0 12 3，分别放到4个窗口中
(2)从第二个列表中选择4条10 11 12 13，分别放到4个窗口中
(3)从第三个列表中选择4条20 21 22 23，分别放到4个窗口
(4)再从第一个列表中选择4条4 5 6 7，分别放到4个窗口中
(5)再从第一个列表中选择，由于数量不足4条，取剩下的2条，放到窗1和窗口2(6)再从第二个列表中选择，由于数量不足4条并且总的元素数达到窗
求，取18 19放到窗口3和窗口4
```
**输入描述**
```
第一行输入为N，表示需要输出的窗口数量，取值范围[1,10]
第二行输入为K，表示每个窗口需要的 元素数量 Q，取值范用[1,100]之后的行数不定(行数取值范围[1,10]，表示每个列表输出的元素列表。元素之
格分隔，已经过准序外理，每人列表输出的元素数量取值范围[1,100]
```
**输出描述**
```
输出元素列表，元素数量=窗口数量“窗口大小，元素之间以空格分隔，多个窗口合并为一个列表输出，参考样例:先输出窗口1的元素列表，再输出
元素列表，再输出窗口3的元素列表，最后输出窗口4的元素列表
```
**示例1**
```
输入
4
7
0 1 2 3 4 5 6 7 8 9
10 11 12 13 14 15 16 17 18 19
20 21 22 23 24 25 26 27 28 29
输出
0 10 20 4 14 24 8 1 11 21 5 15 25 9 2 12 22 6 16 26 18 3 13 23 7 17 27 19
说明：
1.每个列表会保证元素数最满足窗口要求，不需要考虑元素不足情况
2.每个列表的元素已去重，不需要考虑元素重复情况
3.每个列表的元素列表均不为空，不需要考虑列表为空情况
4.每个列表的元素列表已经过排序处理，输出结果要保证不改变同一个列表的元素顺序
5.每个列表的元素数量可能是 不同的
```

**代码**
```python
# 输入获取
n = int(input())
k = int(input())
 
lists = []
while True:
    try:
        lists.append(list(map(int, input().split())))
    except:
        break
 
 
# 算法入口
def getResult():
    # 窗口矩阵，k行n列，每一列对应一个窗口，这里将二维矩阵一维化，方便后面赋值
    windows = [0] * (k * n)
    # 窗口矩阵中正在赋值的索引位置
    idx = 0
    # 正在从第level个列表中取值
    level = 0
 
    # 当窗口矩阵填满后，结束循环
    while idx < len(windows):
        # 当前轮次是否发生了"借"动作
        flag = False
 
        # 从第level个列表中取前n个元素
        for _ in range(n):
            windows[idx] = lists[level].pop(0)
            idx += 1
 
            # 如果第level个列表没有元素了，则继续切到下一个列表中"借"
            if len(lists[level]) == 0 and len(lists) > 1:
                lists.pop(level)  # 删除空列表
                level %= len(lists)  # 防止越界
                flag = True  # 发生了"借"动作
 
        #  如果没有发生"借"动作，则需要切到下一行
        if not flag:
            level = (level + 1) % len(lists)  # 防止越界
 
    ans = []
 
    # 遍历列号
    for j in range(n):
        # 遍历行号
        for i in range(k):
            # 按列收集元素
            ans.append(windows[i * n + j])
 
    return " ".join(map(str, ans))
 
 
# 算法调用
print(getResult())
```

25. 