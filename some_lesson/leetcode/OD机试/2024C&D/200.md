1. **猴子吃桃 二分法**

**题目描述**
```
孙悟空爱吃蟠桃，有一天趁着蟠桃园守卫不在来偷吃。已知蟠桃园有 N 棵桃树，每颗树上都有桃子，守卫将在 H 小时后回来。
孙悟空可以决定他吃蟠桃的速度K（个/小时），每个小时选一颗桃树，并从树上吃掉 K 个，如果树上的桃子少于 K 个，则全部吃掉，并且这一小时剩
不再吃桃。
孙悟空喜欢慢慢吃，但又想在守卫回来前吃完桃子。
请返回孙悟空可以在 H 小时内吃掉所有桃子的最小速度 K（K为整数）。如果以任何速度都吃不完所有桃子，则返回0。
```
**输入描述**
```
第一行输入为 N 个数字，N 表示桃树的数量，这 N 个 数字表示 每颗桃树上蟠桃的数量。
第二行输入为一个数字，表示守卫离开的时间 H。
其中数字通过空格分割，N、H为正整数，每颗树上都有蟠桃，且 0 < N < 10000，0 < H < 10000。
```
**输出描述**
```
吃掉所有蟠桃的最小速度 K，无解或输入异常时输出 0。
```
**用例**
```
输入 2 3 4 5
4
输出 5
说明 无
输入 2 3 4 5
3
输出 0
说明 无
输入 30 11 23 4 20
6
输出 23
说明 无
```
**代码**
```python
class Solution:
    def solve(self, trees, n):
        if n < len(trees):
            return 0
        l, r = 1, max(trees)
        while l < r:
            mid = (l + r) >> 1
            if self.get_res(trees, n, mid):
                r = mid
            else:
                l = mid + 1
        return l

    def get_res(self, trees, n, speed):
        total = 0
        for i in range(len(trees)):
            total += (trees[i] + speed - 1) // speed
            if total > n:
                return False
        return True

s = Solution()
print(s.solve([2,3,4,5], 4))
```

2. 猜拳 逻辑分析

**题目描述**
```
石头剪刀布 游戏有 3 种出拳形状：石头、剪刀、布。分别用字母A、B、C表示。
游戏规则 ：
1. 出拳形状之间的胜负规则如下：
A > B；
B > C；
C > A；
">" 左边一个字母，表示相对优势形状。右边一个字母，表示相对劣势形状。
2. 当本场次中有且仅有一种出拳形状优于其他出拳形状，则该形状的玩家是胜利者。否则认为是平局。
例如1：三个玩家出拳分别是A，B，C。由于三方优势循环（即没有任何一方优于其他出拳者），判断为平局。
例如2：三个玩家出拳分别是A，B，B。出拳A的获胜。
例如3：三个玩家出拳全部是A。判为平局。
3. 当发生平局，没有赢家。有多个胜利者时，同为赢家。
```

**输入描述**
```
在一场游戏中，每个玩家的信息为一行。玩家数量不超过1000。每个玩家信息有2个字段，用空格隔开；
1. 玩家ID：一个仅由英文字母和数字组成的字符串
2. 出拳形状：以英文大写字母表示，A、B、C形状。
3. 出拳时间：正整数，越小表示时间越早
例如：
abc1 A
xyz B
解释：玩家abc1出拳为石头（A）。玩家xyz出拳为剪刀（B）
```

**输出描述**
```
输出为赢家的玩家ID列表（一个或多个），每个ID一行，按 字符串 升序排列。如果没有赢家，输出为”NULL“字符串。
例如：
abc1
```
**代码**
```python
def get_res():
    mp = {}
    while True:
        try:
            name, value = input().split()
            if value < 'A' or value > 'C':
                print('NULL')
                return

            if value not in mp:
                mp[value] = [name]
            else:
                mp[value].append(name)
        except:
            break

    kinds = len(mp)
    if kinds == 1 or kinds == 3:
        print('NULL')
    else:
        ans = None
        if 'B' not in mp:
            ans = mp['C']
        elif 'A' not in mp:
            ans = mp['B']
        else:
            ans = mp['A']
        ans.sort()
        for item in ans:
            print(item)

get_res()
```

3. 二叉树计算 dfs

**题目**
```
给出一个二叉树：请由该二叉树生成一个新的二叉树，它满足其树中的每个节点将包含原始树中的左子树和右子树的和。
左子树表示该节点左侧叶子节点为 根节点 的一颗新树；右子树表示该节点右侧叶子节点为根节点的一颗新树。
```
**输入描述**
```
2行整数，第1行表示二叉树的 中序遍历 ，第2行表示二叉树的前序遍历，以空格分割
例如：
7 -2 6 6 9
6 7 -2 9 6
```
**输出描述**
```
1行整数，表示求和树的中序遍历，以空格分割
例如：
-2 0 20 0 6
```
**用例1**
```
输入
1 7 -2 6 6 9
2 6 7 -2 9 6
输出
-2 0 20 0 6
```
**思路**
```
1：二叉树相关的很经典的题目，从前序+中序去 还原二叉树 。
2：本题只是在还原二叉树的基础上要算每一个节点的左右子树和，一个dfs解决问题。
```
**代码**
```python
class TreeNode:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

class Solution:

    def build(self, inorder, preorder):
        if not inorder and not preorder:
            return
        root = TreeNode(preorder[0])
        index = inorder.index(preorder[0])
        root.left = self.build(inorder[:index], preorder[1:index+1])
        root.right = self.build(inorder[index+1:], preorder[index+1:])
        return root

    def solve(self, inorder, preorder):
        root = self.build(inorder, preorder)
        res = []
        def dfs(root):
            if not root:
                return 0
            tmp = root.value
            left = dfs(root.left)
            res.append(left)
            index = len(res)
            right = dfs(root.right)
            res[index-1] += right
            return left + right + tmp

        dfs(root)
        return res

s = Solution()
print(s.solve([7,-2,6,6,9], [6,7,-2,9,6]))
```

5. 分月饼 分治

**题目描述**
```
中秋节，公司分 月饼 ，m 个员工，买了 n 个月饼，m ≤ n，每个员工至少分 1 个月饼，但可以分多个，
单人分到最多月饼的个数是 Max1 ，单人分到第二多月饼个数是 Max2 ，Max1 - Max2 ≤ 3 ，
单人分到第 n - 1 多月饼个数是 Max(n-1)，单人分到第n多月饼个数是 Max(n) ，Max(n-1) – Max(n) ≤ 3,
问有多少种分月饼的方法？
```
**输入描述**
```
每一行输入m n，表示m个员工，n个月饼，m ≤ n
```
**输出描述**
```
输出有多少种月饼分法
```
**题目解析**
```
本题类似于 整数划分问题 ，即将一个正整数n，分解为m个正整数的方案数。
这类问题一般不会有太大的数量级，比如将10000分解为10个整数，那方案数就太多了。
本题给了一个限制条件，那就是，如果将分解后的m个正整数升序的话，相邻元素之间的差值不能超过3。
另外，分解方案不在意m个正整数的顺序，比如 1 2 1 和 1 1 2算一种方案。
我这里考虑使用分治递归求解。
分治递归可以想象成一棵树，这颗树有m层。
第0层相当于序号0个员工，该层有多个节点，每个节点的值即为序号0个员工可能分得的月饼数量。
题目说，每个员工至少分得1个月饼，因此序号0个员工分得月饼数至少为1。
为了保证不产生重复方案，因此我们默认当前求解的升序的m个正整数序列，因此序号0个员工分得的月饼数不能超过均值，即 n / m，因为一旦序号0个员工分得的月饼超过均值，则其后面的员工必然会有分得小于均值月饼数的情况。
因此第0个员工分得的月饼数范围是 1 ~ n / m
接下来是第1层，相当于序号1员工，该员工分得的月饼数取决于上一层的员工：
为了保证升序，序号1员工分得的月饼最少数量即序号0员工分得的月饼数量
同时，题目限定相邻员工之间，月饼数差距不能超过3，因此序号1员工最多分得的月饼数量 = 序号0员工分得月饼数量 + 3
另外为了保证后面员工分得月饼数一定不小于序号1员工，因此序号1员工分得的月饼数量不能超过 (剩余月饼数量 ➗ 剩余员工数量) ，其中：
1. 剩余月饼数量 = n - 序号0员工分得的月饼数
2. 剩余员工数量 = m - 1
接下来层数同理，直到第m-1层，即分配到最后一个员工，此时最后一个员工将分得剩余所有月饼，如果最后一个员工和倒数第二个员工月饼数差距bu超过3，即可判断当前递归分支对应的分配方案可行与否
```
**代码**
```python
from functools import cache
import sys
 
# 这题递归可能栈溢出，Python的递归深度要搞大一点，考试时如果10000不行，再加大一点
sys.setrecursionlimit(10000)
 
# 输入获取
m, n = map(int, input().split())
 
 
# 递归
@cache
def recursive(level, low, high, remain):
    """
    :param level: 第几个员工
    :param low: 当前员工至少分得几个月饼
    :param high: 当前员工至多分得几个月饼
    :param remain: 分月饼给当前员工前，月饼的剩余数量
    """
    # 分到最后一个员工时，我们应该将剩余月饼都给他
    if level == m - 1:
        # 因此最后一个员工的月饼数量就是remain，而倒数第二个员工的月饼数量是low（本轮递归的min参数，即上一轮员工分得的月饼数量）
        if remain - low <= 3:
            # 如果二者差距不超过maxDiff，则分月饼方案可行
            return 1
 
        # 否则方案不可行
        return 0
 
    # ans记录可行方案数
    ans = 0
 
    # i 是当前员工可以分得的月饼数量
    for i in range(low, high + 1):
        remain -= i
        # 下一个员工至少分得 i 个月饼（当前员工分得的月饼数量），至多分得 i + maxDiff
        # 同时下一个员工分得的月饼数量不能超过：均分月饼数量（即剩余月饼总数 / 剩余员工总数），否则破坏去重策略（为了保证分月饼的方案不重复，我们这里保证后面的员工分得月饼数不小于前面员工）
        ans += recursive(level + 1, i, min(i + 3, remain // (m - level - 1)), remain)
        remain += i
 
    return ans
 
 
# 算法入口
def getResult():
    if m == 1:
        # 如果只有一个员工分月饼，那么就只有一种方案
        return 1
    else:
        # 如果有多个员工分月饼，为了保证分月饼的方案不重复，我们这里保证 员工i的月饼数量 <= 员工i+1的月饼数量
        # 因此对于第0个员工，至少分得1个月饼，至多分得n/m个月饼（均分数量）
        return recursive(0, 1, n // m, n)
 
 
# 算法调用
print(getResult())
```

6. 连续出牌数量 回溯

**题目描述**
```
有这么一款单人卡牌游戏，牌面由颜色和数字组成，颜色为红、黄、蓝、绿中的一种，数字为0-9中的一个。游戏开始时玩家从手牌中选取一张卡牌打
如果玩家手中有和他上一次打出的手牌颜色或者数字相同的手牌，他可以继续将该手牌打出，直至手牌打光或者没有符合条件可以继续打出的手牌。
现给定一副手牌，请找到最优的出牌策略，使打出的手牌最多。
```
**输入描述**
```
输入为两行
第一行是每张手牌的数字，数字由空格分隔，
第二行为对应的每张手牌的颜色，用r y b g这4个字母分别代表4种颜色，字母也由空格分隔。
手牌数量不超过10。
```
**输出描述**
```
输出一个数字，即最多能打出的手牌的数量。
```
**用例**
```
输入 1 4 3 4 5
r y b b r
输出 3
说明 如果打（1, r）-> (5, r)，那么能打两张。
如果打（4，y) -> (4, b) -> (3, b)，那么能打三张。
输入 1 2 3 4
r y b l
输出 1
说明 没有能够连续出牌的组合，只能在开始时打出一张手牌，故输出1
```
**代码**
```python
class Solution:

    def solve(self, nums, colors):

        ans = 0
        used = [False] * len(nums)

        def dfs(cnt, used, last):
            nonlocal ans
            ans = max(ans, cnt)
            if False not in used:
                return

            for i in range(len(nums)):
                if not used[i]:
                    if last and last[0] != nums[i] and last[1] != colors[i]:
                        continue
                    used[i] = True
                    dfs(cnt+1, used, [nums[i], colors[i]])
                    used[i] = False
            return ans

        return dfs(0, used, None)


s = Solution()
print(s.solve([1,4,3,4,5], ['r', 'y', 'b', 'b', 'r']))
```

7. 攀登者 逻辑分析

**题目描述**
```
攀登者喜欢寻找各种地图，并且尝试攀登到最高的山峰。
地图表示为一维数组，数组的索引代表水平位置，数组的元素代表相对海拔高度。其中数组元素0代表地面。
例如：[0,1,2,4,3,1,0,0,1,2,3,1,2,1,0]，代表如下图所示的地图，地图中有两个山脉位置分别为 1,2,3,4,5 和 8,9,10,11,12,13，最高峰高度分别为 4,3。最高峰位置分别为3,10。
一个山脉可能有多座山峰(高度大于相邻位置的高度，或在地图边界且高度大于相邻的高度)。
登山时会消耗登山者的体力(整数)，
上山时，消耗相邻高度差两倍的体力
下山时，消耗相邻高度差一倍的体力
平地不消耗体力
登山者体力消耗到零时会有生命危险。
例如，上图所示的山峰：
从索引0，走到索引1，高度差为1，需要消耗 2 * 1 = 2 的体力，
从索引2，走到索引3，高度差为2，需要消耗 2 * 2 = 4 的体力。
从索引3，走到索引4，高度差为1，需要消耗 1 * 1 = 1 的体力。
攀登者想要评估一张地图内有多少座山峰可以进行攀登，且可以安全返回到地面，且无生命危险。
例如上图中的数组，有3个 不同的 山峰，登上位置在3的山可以从位置0或者位置6开始，从位置0登到山顶需要消耗体力 1 * 2 + 1 * 2 + 2 * 2 = 8，从山顶返回到地面0需要消耗体力 2 * 1 + 1 * 1 + 1 * 1 = 4 的体力，按照登山路线 0 → 3 → 0 需要消耗体力12。攀登者至少需要12以上的体力（大于12）才能安全返回。
```
**输入描述**
```
第一行输入为地图一维数组
第二行输入为攀登者的体力
```
**输出描述**
```
确保可以安全返回地面，且无生命危险的情况下，地图中有多少山峰可以攀登。
```
**代码**
```python
# 输入获取
heights = list(map(int, input().split(",")))
strength = int(input())
 
 
def climb(idxs, direction):
    # 找到第一个地面位置
    j = 0
    while j < len(heights) and heights[j] != 0:
        j += 1
 
    # 上山体力消耗
    # upCost = 0
    # 下山体力消耗
    # downCost = 0
 
    # 攀登体力总消耗（包括上山，下山）
    cost = 0
 
    for i in range(j + 1, len(heights)):
        # 如果遇到了新的地面，则从新的地面位置重新计算攀登消耗的体力
        if heights[i] == 0:
            cost = 0
            # upCost = 0
            # downCost = 0
            continue
 
        # diff记录高度差
        diff = heights[i] - heights[i - 1]
 
        if diff > 0:
            # 如果过程是上坡
            cost += diff * 3
            # upCost += diff * 2  # 则上山时，体力消耗 = 高度差 * 2
            # downCost += diff  # 相反的下山时，体力消耗 = 高度差 * 1
 
            # 由于 height[i] > heights[i-1]，因此如果 height[i] > heights[i+1] 的话，位置 i 就是山顶
            if i + 1 >= len(heights) or heights[i] > heights[i + 1]:
                # 计算攀登此山顶的上山下山消耗的体力和
                if cost < strength:
                    # if upCost + downCost <= strength:
                    # 如果不超过自身体力，则可以攀登
                    if direction:
                        idxs.add(i)
                    else:
                        idxs.add(len(heights) - i - 1)  # 需要注意，逆序heights数组后，我们对于的山峰位置需要反转
 
        elif diff < 0:
            # 如果过程是下坡
            cost -= diff * 3
            # upCost -= diff  # 则上山时，体力消耗 = 高度差 * 1
            # downCost -= diff * 2  # 相反的下山时，体力消耗 = 高度差 * 2
            # heights[i] < heights[i-1]，因此位置i不可能是山顶
 
 
# 算法入口
def getResult():
    # 记录可攀登的山峰索引
    idxs = set()
 
    # 正向攀登
    climb(idxs, True)
 
    # 逆序攀登
    heights.reverse()
    climb(idxs, False)
 
    return len(idxs)
 
 
# 算法调用
print(getResult())
```

8. 园区参观路径 dfs

**题目描述**
```
园区某部门举办了Family Day，邀请员工及其家属参加；
将公司园区视为一个矩形，起始园区设置在左上角，终点园区设置在右下角；
家属参观园区时，只能向右和向下园区前进，求从起始园区到终点园区会有多少条 不同的 参观路径。
```
**输入描述**
```
第一行为园区的长和宽；
后面每一行表示该园区是否可以参观，0表示可以参观，1表示不能参观
```
**输出描述**
```
输出为不同的路径数量
```
**用例**
```
输入
3 3
0 0 0
0 1 0
0 0 0
输出 2
说明 无
```
**代码**
```python
class Solution:

    def solve(self, m, n, matrix):
        ans = 0

        def dfs(x, y):
            nonlocal ans
            if x == m - 1 and y == n - 1:
                ans += 1
                return

            for dx, dy in [(0, 1), (1, 0)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] != 1:
                    dfs(nx, ny)

        dfs(0, 0)
        return ans


s = Solution()
print(s.solve(3,3,[[0,0,0],[0,0,0],[0,0,0]]))
```

9. 部门人力分配 二分+双指针

**题目描述**
```
部门在进行需求开发时需要进行人力安排。
当前部门需要完成 N 个需求，需求用 requirements 表述，requirements[i] 表示第 i 个需求的工作量大小，单位：人月。
这部分需求需要在 M 个月内完成开发，进行人力安排后每个月人力时固定的。
目前要求每个月最多有2个需求开发，并且每个月需要完成的需求不能超过部门人力。
请帮助部门评估在满足需求开发进度的情况下，每个月需要的最小人力是多少？
```
**输入描述**
```
输入为 M 和 requirements，M 表示需求开发时间要求，requirements 表示每个需求工作量大小，N 为 requirements长度，
1 ≤ N/2 ≤ M ≤ N ≤ 10000
1 ≤ requirements[i] ≤ 10^9
```
**输出描述**
```
对于每一组 测试数据 ，输出部门需要人力需求，行末无多余的空格
```
**用例**
```
输入 3
3 5 3 4
输出 6
说明
输入数据两行，
第一行输入数据3表示开发时间要求，
第二行输入数据表示需求工作量大小，
输出数据一行，表示部门人力需求。
当选择人力为6时，2个需求量为3的工作可以在1个月里
完成，其他2个工作各需要1个月完成。可以在3个月内完
成所有需求。
当选择人力为5时，4个工作各需要1个月完成，一共需要
4个月才能完成所有需求。
因此6是部门最小的人力需求。
```
**代码**
```python
class Solution:

    def solve(self, n, nums):
        l, r = max(nums), max(nums) + min(nums)
        while l < r:
            mid = (l + r) >> 1
            if self.get_res(mid, nums, n):
                r = mid
            else:
                l = mid + 1
        return l

    def get_res(self, target, nums, n):
        nums.sort()
        cnt = 0
        l, r = 0, len(nums) - 1
        while l < r:
            if nums[l] + nums[r] <= target:
                l += 1
                r -= 1
                cnt += 1
            else:
                r -= 1
                cnt += 1
        cnt += 1 if l == r else 0
        return True if cnt <= n else False


s = Solution()
print(s.solve(3,[3,5,3,4]))
```

10. 结对编程 二叉搜索树/暴力

**题目描述**
```
某部门计划通过结队编程来进行 项目开发 ，
已知该部门有 N 名员工，每个员工有 独一无二 的职级，每三个员工形成一个小组进行结队编程，结队分组规则如下：
从部门中选出序号分别为 i、j、k 的3名员工，他们的职级分贝为 level[i]，level[j]，level[k]，
结队小组满足 level[i] < level[j] < level[k] 或者 level[i] > level[j] > level[k]，
其中 0 ≤ i < j < k < n。
请你按上述条件计算可能组合的小组数量。同一员工可以参加多个小组。
```
**输入描述**
```
第一行输入：员工总数 n
第二行输入：按序号依次排列的员工的职级 level，中间用空格隔开
限制：
1 ≤ n ≤ 6000
1 ≤ level[i] ≤ 10^5
```
**输出描述**
```
可能结队的小组数量
```
**用例**
```
输入 4
1 2 3 4
输出 4
说明 可能结队成的组合(1,2,3)、(1,2,4)、(1,3,4)、(2,3,4)
输入 3
5 4 7
输出 0
说明 根据结队条件，我们无法为该部门组建小组
```
**代码**
```python
class Solution:

    def solve(self, n, nums):
        total = 0
        for i in range(1, n-1):
            leftsmallercnt = 0
            leftbiggercnt = 0
            for j in range(i):
                if nums[j] < nums[i]:
                    leftsmallercnt += 1
                else:
                    leftbiggercnt += 1
            rightsmallercnt = 0
            rightbiggercnt = 0
            for k in range(i+1, n):
                if nums[k] < nums[i]:
                    rightsmallercnt += 1
                else:
                    rightbiggercnt += 1
            total += leftsmallercnt * rightbiggercnt + leftbiggercnt * rightsmallercnt
        return total


s = Solution()
print(s.solve(4,[1,2,3,4]))
```

11. 数据单元的替换 递归

**题目描述**
```
将一个 csv 格式的数据文件中包含有单元格引用的内容替换为对应单元格内容的实际值。
comma separated values(CSV) 逗号分隔值，csv 格式的数据文件使用逗号 "," 作为分隔符将各单元的内容进行分隔。
```
**输入描述**
```
1. 输入只有一行数据，用逗号分隔每个单元格，行尾没有逗号。最多26个单元格，对应编号A~Z。
2. 每个单元格的内容包含字母和数字，以及使用 '<>' 分隔的单元格引用，例如：<A>表示引用第一个单元的值。
3. 每个单元格的内容，在替换前和替换后均不超过100个字符。
4. 引用单元格的位置不受限制，允许排在后面的单元格被排在前面的单元格引用。
5. 不存在循环引用的情况，比如下面这种场景是不存在的：
A单元恪：aCd<B>8U
B单元格：KAy<A>uZq0
6. 不存在多重 '<>' 的情况，一个单元只能引用一个其他单元格。比如下面这种场景是不存在的：
A单元格：aCdOu
B单元格：kAydzco
C单元格：y<<A><B>>d
```
**输出描述**
```
输出替换后的结果
```
**用例**
```
输入 1,2<A>00
输出 1,2100
说明 第二个单元中有对A单元的引用，A单元格的值为1，替换时，将
A单元的内容替代<A>的位置，并和其他内容合并。
输入 1<B>2,1
输出 112,1
说明 第一个单元中有对B单元的引用，B单元格的值为1，耆换时，将
第二个数据第单元的内容替代<B>的位置，并和其他内容合并
```
**代码**
```python
import re
 
regexp = re.compile(r"(<.*?>)")
 
# 输入获取
cells = input().split(",")
 
 
def changeCell(index):
    # 通过正则匹配出单元格内容中"引用字符串"
    matchers = regexp.findall(cells[index])
 
    # reference记录引用字符串
    for reference in matchers:
        # 引用单元格编号只能是A~Z的字母，即引用引用字符串长度只能是3，比如"<A>"
        if len(reference) != 3:
            return False
 
        # 引用单元格的编号
        reference_cellNum = reference[1]
        # 当前单元格的编号
        self_cellNum = chr(65 + index)
 
        # 引用单元格编号只能是A~Z的字母，且不能自引用
        if reference_cellNum < 'A' or reference_cellNum > 'Z' or reference_cellNum == self_cellNum:
            return False
 
        # 引用单元格的数组索引， 'A' -> 0  ... 'Z' -> 25
        reference_index = ord(reference_cellNum) - 65
 
        # 引用单元格编号不存在
        if reference_index >= len(cells):
            return False
 
        if not changeCell(reference_index):
            return False
 
        # 将单元格内容中的引用部分，替换为被引用的单元格的内容
        cells[index] = cells[index].replace(reference, cells[reference_index])
 
    return True
 
 
# 算法入口
def getResult():
    if len(cells) > 26:
        # 最多26个单元格，对应编号A~Z
        return "-1"
 
    for i in range(len(cells)):
        # 替换单元格中的引用
        if not changeCell(i):
            # 替换失败，则返回-1
            return "-1"
 
        if len(cells[i]) > 100:
            # 每个单元格的内容，在替换前和替换后均不超过100个字符
            return "-1"
 
        if not re.match(r"^[a-zA-Z0-9]+$", cells[i]):
            # 每个单元格的内容包含字母和数字
            return "-1"
 
    return ",".join(cells)
 
 
# 算法调用
print(getResult())
```

12. 高效货运 完全背包/暴力枚举

**题目描述**
```
老李是货运公司承运人，老李的货车额定载货重量为 wt。
现有两种货物：
货物 A 单件重量为 wa，单件运费利润为 pa
货物 B 单件重量为 wb，单件运费利润为 pb
老李每次发车时载货总重量刚好为货车额定的载货重量 wt，车上必须同时有货物 A 和货物 B ，货物A、B不可切割。
老李单次满载运输可获得的最高利润是多少？
```
**输入描述**
```
第一列输入为货物 A 的单件重量 wa
0 < wa < 10000
第二列输入为货物 B 的单件重量 wb
0 < wb < 10000
第三列输入为货车的额定载重 wt
0 < wt < 100000
第四列输入为货物 A 的单件运费利润 pa
0 < pa < 1000
第五列输入为货物 B 的单件运费利润 pb
0 < pb < 1000
```
**输出描述**
```
单次满载运输的最高利润
```
**用例**
```
输入 10 8 36 15 7
输出 44
说明 无
输入 1 1 2 1 1
输出 2
说明 无
```
**代码**
```python
class Solution:

    def solve(self, wa, wb, target, va, vb):
        target -= wa + wb
        total = va + vb
        w = [wa, wb]
        v = [va, vb]
        dp = [float('-inf')] * (target + 1)
        dp[0] = 0
        for i in range(2):
            for j in range(w[i], target+1):
                    dp[j] = max(dp[j], dp[j-w[i]] + v[i])
        return dp[-1] + total

s = Solution()
print(s.solve(1,1,2,1,1))
```

13. 找数字 位运算

**题目描述**
```
小扇和小船今天又玩起来了 数字游戏 ，
小船给小扇一个正整数 n（1 ≤ n ≤ 1e9），小扇需要找到一个比 n 大的数字 m，使得 m 和 n 对应的二进制中 1 的个数要相同，如：
4对应二进制100
8对应二进制1000
其中1的个数都为1个
现在求 m 的 最小值 。
```
**输入描述**
```
输入一个正整数 n（1 ≤ n ≤ 1e9）
```
**输出描述**
```
输出一个正整数 m
```
**用例**
```
输入 2
输出 4
说明
2的二进制10，
4的 二进制位 100，
1的个数相同，且4是满足条件的最小数
输入 7
输出 11
说明
7的二进制111，
11的二进制位1011，
1的个数相同，且11是满足条件的最小数
```
**代码**
```python
class Solution:

    def solve(self, n):
        tmp = n
        index = 0
        flag = False
        while n:
            if n & 1:
                flag = True
            elif not n & 1 and flag:
                break
            index += 1
            n >>= 1
        return tmp + 2 ** (index - 1)


s = Solution()
print(s.solve(2))
```

14. 中文分词模拟器 逻辑分析

**题目**
```
给定一个连续不包含空格的 字符串 ，该字符串仅包含英文小写字母及英文标点符号(逗号、分号、句号)，同时给定词库，对该字符串进行精确分
说明:
1.精确分词: 字符串分词后，不会出现重叠
即"ilovechina",不同词库可分割为",love,china”，“ilove,china”不能分割出现重叠的"ilove,china"i 出现重叠。
2.标点符号不成词，仅用于断句
3.词库: 根据外部 知识库 统计出来的常用词汇例:
dictionary =["i",“love”,“china”,“lovechina”,“ilove”]
4.分词原则: 采用分词顺序优先且最长匹配原则
“llovechina”假设分词结果[i,ilove,lo,love,ch,china,lovechina],则输出[ilove,china]
错误输出: [i,lovechina],原因:“ilove”>优先于"lovechina"成词
错误输出: [i,love,china],原因:“love”>"遵循最长匹配原则
```
**输入描述**
```
第一行输入待分词语句 S
第二行输入中文词库
字符串 S 长度限制: 0 < S.length < 256
词库长度限制: 1 < length < 100000
```
**输出描述**
```
按顺序输出分词结果
```
**示例1：**
```
输入：
ilovechina
i,love,china,ch,na,ve,lo,this,is,the,word
输出：
i,love,china
```
**示例2：**
```
输入：
iat
i,love,china,ch,na,ve,lo,this,is,the,word,beauti,tiful,ful
输出：
i,a,t
```
**示例3：**
```
输入：
ilovechina,thewordisbeautiful
i,love,china,ch,na,ve,lo,this,is,the,word,beauti,tiful,ful
输出：
i,love,china,the,word,is,beauti,fu
```
**代码**
```python
import re
 
# 输入获取
sentences = list(filter(lambda x: x != "", re.split(r"[,.;]", input())))
words = list(filter(lambda x: x != "", re.split(r"[,.;]", input())))
 
 
def getResult():
    # wordSet 记录词库词汇
    wordSet = set(words)
    # ans记录最终分词结果
    ans = []
 
    while len(sentences) > 0:
        # 待分词的句子
        sentence = sentences.pop(0)
 
        r = len(sentence)
        while r > 0:
            # 截取句子 [0,r) 范围子串词汇, 这样的就能实现优先最长匹配，并且由于是必须从0索引开始截取，因此满足了分词顺序优先
            fragment = sentence[0:r]
 
            # 若词库中是否存在该子串词汇
            if fragment in wordSet:
                # 则将对应子串词汇纳入结果
                ans.append(fragment)
                wordSet.remove(fragment)  # 我理解词库中每个词汇只能使用一次，因此这里将词库中使用过的词汇移除
 
                # 若子串词汇只是句子部分，则句子剩余部分还要继续去词库中查找
                if r < len(sentence):
                    sentences.insert(0, sentence[r:])
 
                break
 
            r -= 1
 
        # 没有在词库中找到对应子串词汇，则输出单个字母
        if r == 0:
            # 注意，这里只放一个字母到结果中，句子剩余部分继续去词库中查找
            ans.append(sentence[0])
 
            if len(sentence) > 1:
                sentences.insert(0, sentence[1:])
 
    return ",".join(ans)
 
 
print(getResult())
```

15. 符号运算 栈

**题目描述**
```
给定一个表达式，求其分数计算结果。
表达式的限制如下：
1. 所有的输入数字皆为正整数（包括0）
2. 仅支持四则运算（+-*/）和括号
3. 结果为整数或分数，分数必须化为最简格式（比如6，3/4，7/8，90/7）
4. 除数可能为0，如果遇到这种情况，直接输出"ERROR"
5. 输入和最终计算结果中的数字都不会超出整型范围
用例输入一定合法，不会出现 括号匹配 的情况
```
**输入描述**
```
字符串 格式的表达式，仅支持+-*/，数字可能超过两位，可能带有空格，没有负数
长度小于200个字符
```
**输出描述**
```
表达式结果，以最简格式表达
如果结果为整数，那么直接输出整数
如果结果为负数，那么分子分母不可再约分，可以为假分数，不可表达为带分数
结果可能是负数，符号放在前面
```
**用例**
```
输入 1 + 5 * 7 / 8
输出 43/8
说明 无
输入 1 / (0 - 5)
输出 -1/5
说明 符号需要提到最前面
输入 1 * (3*4/(8-(7+0)))
输出 12
说明 注意括号可以多重嵌套
```
**代码**
```python
class Num:
    def __init__(self, up, down):
        self.up = up
        self.down = down

class Sign:
    def __init__(self, value):
        self.value = value
        if value in ['*', '/']:
            self.pri = 3
        elif value in ['+', '-']:
            self.pri = 2
        else:
            self.pri = 1

class Solution:

    def solve(self, strs):
        sign_stack, num_stack, num_cache = [], [], []
        for x in strs:
            if x.isdigit():
                num_cache.append(x)
            else:
                sign = Sign(x)
                if sign.value == '(':
                    sign_stack.append(sign)
                    continue
                elif sign.value == ')':
                    if num_cache:
                        num = Num(int(''.join(num_cache)), 1)
                        num_cache = []
                        num_stack.append(num)
                    while sign_stack[-1].value != '(':
                        num2 = num_stack.pop()
                        num1 = num_stack.pop()
                        pre_sign = sign_stack.pop()
                        cur_num = self.get_cal(num1, num2, pre_sign)
                        if cur_num == 'ERROR':
                            return cur_num
                        num_stack.append(cur_num)
                    sign_stack.pop()
                    continue

                num = Num(int(''.join(num_cache)), 1)
                num_cache = []
                num_stack.append(num)
                while sign_stack and sign.pri <= sign_stack[-1].pri:
                    num2 = num_stack.pop()
                    num1 = num_stack.pop()
                    pre_sign = sign_stack.pop()
                    cur_num = self.get_cal(num1, num2, pre_sign)
                    if cur_num == 'ERROR':
                        return cur_num
                    num_stack.append(cur_num)
                sign_stack.append(sign)



        while sign_stack and num_stack:
            num2 = num_stack.pop()
            num1 = num_stack.pop()
            pre_sign = sign_stack.pop()
            cur_num = self.get_cal(num1, num2, pre_sign)
            if cur_num == 'ERROR':
                return cur_num
            num_stack.append(cur_num)
        final_num = num_stack[0]
        if final_num.up < 0 and final_num.down < 0:
            final_sign = ''
        elif final_num.up > 0 and final_num.down > 0:
            final_sign = ''
        else:
            final_sign = '-'
        gcd_num = self.gcd(abs(final_num.up), abs(final_num.down))
        if abs(final_num.down) == gcd_num:
            return final_sign + str(abs(final_num.up) // gcd_num)
        else:
            return final_sign + str(abs(final_num.up) // gcd_num) + '/' + str(abs(final_num.down) // gcd_num)

    def gcd(self, a, b):
        while b:
            a, b = b, a % b
        return a

    def get_cal(self, num1, num2, sign):
        if sign.value == '+':
            cur_up = num1.up * num2.down + num1.down * num2.up
            cur_down = num1.down * num2.down
        elif sign.value == '-':
            cur_up = num1.up * num2.down - num1.down * num2.up
            cur_down = num1.down * num2.down
        elif sign.value == '*':
            cur_up = num1.up * num2.up
            cur_down = num1.down * num2.down
        else:
            if num2.up == 0:
                return 'ERROR'
            cur_up = num1.up * num2.down
            cur_down = num1.down * num2.up
        return Num(cur_up, cur_down)


s = Solution()
print(s.solve('1*(3*4/(8-(7+6)))'))
```

16. 根据IP查找城市 逻辑分析

**题目**
```
某业务需要根据终端的 IP地址 获取该终端归属的城市，可以根据公开的IP地址池信息查询归属城市地址池格式如下: 城市名=起始IP，结束IP
起始和结束地址按照英文逗号分隔，多个地址段采用英文分号分隔。比如:
City1=1.1.1.1,1.1.1.2;City1=1.1.1.1,1.1.1.16;City2=3.3.3.3,4.4.4.4;City3=2.2.2.2,6.6.6.6一个城市可以有多个IP段，比如City1有2个IP段城市间也可
包含关系，如City3的IP段包含City2的IP段范围
现在要根据输入的IP列表，返回最佳匹配的城市列表
注:最佳匹配即包含待查询P且长度最小的IP段，比如例子中
3.4.4.4 最佳匹配是City2=3.3.3.3,4.4.4.4，
5.5.5.5的最佳匹配是City3=2.2.2.2,6.6.6.6
```
**输入描述**
```
输入共2行。
第一行为城市的IP段列表，多个IP段采用英文分号， 分隔，IP段列表最大不超过500000。城市名称只包含 英文字母 、数字和下划线。最多不超
100000个。IP段包含关系可能有多层，但不超过100层。
第二行为查询的IP列表，多个IP采用英文逗号“，分隔，最多不超过10000条
```
**输出描述**
```
最佳匹配的城市名列表，采用英文逗号，分隔，城市列表长度应该跟查询的IP列表长度一致。
备注
。无论是否查到匹配正常都要输出分隔符。举例: 假如输入IP列表为IPa,IPb，两个IP均未有匹配城市，此时输出为","即只有一个逗号分隔符，两个
空;
可以假定用例中的所有输入均合法，IP地址均为合法的ipv4地址，满足(1/255),(0/255)(0/255,0/255)的格式，且可以假定用例中不会出现组播和广播
```
**示例1：**
```
输入:
City1=1.1.1.1,1.1.1.2;City1=1.1.1.1,1.1.1.16;City2=3.3.3.3,4.4.4.4;City3=2.2.2.2,6.6.6.6
3.4.4.4,5.5.5.5
输出：
City2,City3
```
**思路**
```
1：题目比较核心的一个点：【起始IP，结束IP】，这里我们首先要做的一个事，就是拿到这个区间内的所有IP，一般的ip表达是 xxx.xxx.xxx.xxx 数字组成，每个数字的最大上限为255，这样我们其实可以用一个8位的二进制数组来表达每个数组，再将四个数字的对应二进制数组合并，这样我
以得到一个正整数，用这个正整数，我们就可以很方便的获取对应其中的IP了。
```
**代码**
```python
class Solution:
    def trans(self, ip):
        ips = [int(x) for x in ip.split('.')]
        ans = 0
        for i in range(4):
            ans <<= 8
            ans |= ips[i]
        return ans

    def solve(self, citys, targets):
        mp = {}
        city_name = set()
        citys_list = citys.split(';')
        for city in citys_list:
            name = city.split('=')[0]
            city_name.add(name)
            ip_range = city.split('=')[1]
            start, end = self.trans(ip_range.split(',')[0]), self.trans(ip_range.split(',')[1])
            if name not in mp:
                mp[name] = [[start, end]]
            else:
                mp[name].append([start, end])
        target_list = targets.split(',')
        ans = ''
        for target in target_list:
            out = ''
            size = float('inf')
            cur_city = None
            target_num = self.trans(target)
            for city in city_name:
                for range in mp[city]:
                    if range[0] <= target_num and range[1] >= target_num:
                        if range[1] - range[0] < size:
                            size = range[1] - range[0]
                            out = city
                        elif range[1] - range[0] == size:
                            if city > cur_city:
                                out = city
                                cur_city = city
            ans += out + ','
        return ans[:-1]


s = Solution()
print(s.solve('City1=1.1.1.1,1.1.1.2;City1=1.1.1.1,1.1.1.16;City2=3.3.3.3,4.4.4.4;City3=2.2.2.2,6.6.6.6',
              '3.4.4.4,5.5.5.5'))
```

17. 文件缓存系统 哈希表+双向链表

**题目描述**
```
请设计一个文件 缓存系统 ，该文件缓存系统可以指定缓存的最大值（单位为字节）。
文件缓存系统有两种操作：
存储文件（put）
读取文件（get）
操作命令为：
put fileName fileSize
get fileName
存储文件是把文件放入文件缓存系统中；
读取文件 是从文件缓存系统中访问已存在，如果文件不存在，则不作任何操作。
当缓存空间不足以存放新的文件时，根据规则删除文件，直到剩余空间满足新的文件大小位置，再存放新文件。
具体的删除规则为：
文件访问过后，会更新文件的最近访问时间和总的访问次数，当缓存不够时，按照第一优先顺序为访问次数从少到多，第二顺序为时间从老到新的方式
件。
```
**输入描述**
```
第一行为缓存 最大值 m（整数，取值范围为 0 < m ≤ 52428800）
第二行为文件操作序列个数 n（0 ≤ n ≤ 300000）
从第三行起为文件操作序列，每个序列单独一行，文件操作定义为：
op file_name file_size
file_name 是文件名，file_size 是文件大小
```
**输出描述**
```
输出当前文件缓存中的文件名列表，文件名用英文逗号分隔，按字典顺序排序，如：
a,c
如果文件缓存中没有文件，则输出NONE
备注
1. 如果新文件的文件名和文件缓存中已有的文件名相同，则不会放在缓存中
2. 新的文件第一次存入到文件缓存中时，文件的总访问次数不会变化，文件的最近访问时间会更新到最新时间
3. 每次文件访问后，总访问次数加1，最近访问时间更新到最新时间
4. 任何两个文件的最近访问时间不会重复
5. 文件名不会为空，均为小写字母，最大长度为10
6. 缓存空间不足时，不能存放新文件
7. 每个文件大小都是大于 0 的整数
```
**用例**
```
输入
50
6
put a 10
put b 20
get a
get a
get b
put c 30
输出 a,c
说明 无
输入
50
1
get file
输出 NONE
说明 无
```
**代码**
**LFU**
```python
class Node:
    def __init__(self, key=None, value=None, freq=None):
        self.key = key
        self.value = value
        self.freq = freq
        self.next = None
        self.pre = None

class Solution:
    def __init__(self, capacity):
        self.keymap = {}
        self.freqmap = {}
        self.capacity = capacity
        self.cur_capacity = 0
        self.min_freq = 1
        self.head = []
        self.tail = []

    def solve(self, n, operations):
        for i in range(n):
            op = operations[i].split(' ')
            if len(op) == 2:
                self.get(op[1])
            elif len(op) == 3:
                self.put(op[1], int(op[2]))
        return ','.join(sorted(list(self.keymap.keys())))


    def insert_to_tail(self, node, freq):
        node.next = self.tail[freq-1]
        node.pre = self.tail[freq-1].pre
        self.tail[freq-1].pre.next = node
        self.tail[freq-1].pre = node


    def change_node_freq(self, node, pre_freq, cur_freq):
        if cur_freq not in self.freqmap:
            self.head.append(Node())
            self.tail.append(Node())
            self.head[-1].next = self.tail[-1]
            self.tail[-1].pre = self.head[-1]
            self.freqmap[cur_freq] = self.head[-1]
        if pre_freq:
            node.pre.next = node.next
            node.next.pre = node.pre
            if self.min_freq == pre_freq and not self.head[pre_freq - 1].next.value:
                self.min_freq = cur_freq
        if cur_freq < self.min_freq:
            self.min_freq = cur_freq
        self.insert_to_tail(node, cur_freq)

    def get(self, key):
        res = self.keymap.get(key, -1)
        if res == -1:
            pass
        else:
            res.freq += 1
            self.change_node_freq(res, res.freq - 1, res.freq)
            print(res.value)

    def remove_node(self):
        node = self.head[self.min_freq - 1].next
        node.pre.next = node.next
        node.next.pre = node.pre
        del self.keymap[node.key]
        if node.next.value == None:
            max_freq = max(list(self.freqmap.keys()))
            for i in range(1, max_freq+1):
                if self.head[i-1].next.value:
                    self.min_freq = i
                    break
            else:
                self.min_freq = 0

        return node.value

    def put(self, key, value):
        if key not in self.keymap:
            while self.cur_capacity + value > self.capacity:
                self.cur_capacity -= self.remove_node()
            new_node = Node(key, value, 1)
            self.change_node_freq(new_node, None, 1)
            self.cur_capacity += value
            self.keymap[key] = new_node


s = Solution(50)
print(s.solve(6, ['put a 10', 'put b 20', 'get a', 'get a', 'get b', 'put c 30']))
```

**LRU**
```python
class ListNode:
    def __init__(self, key=None, value=None):
        self.key = key
        self.value = value
        self.next = None
        self.pre = None

class LRUCache:

    def __init__(self, capacity: int):
        # 哈希表存储 key: node
        self.hashmap = {}
        # 容量
        self.capacity = capacity
        # 头节点
        self.head = ListNode()
        # 尾节点
        self.tail = ListNode()
        # 连接头尾节点
        self.head.next = self.tail
        self.tail.pre = self.head

    def move_to_tail(self, key):
        # 从哈希表中获取key对应node
        node = self.hashmap[key]
        # 断开node
        node.pre.next = node.next
        node.next.pre = node.pre
        # node插入尾节点之前
        node.next = self.tail
        node.pre = self.tail.pre
        self.tail.pre = node
        node.pre.next = node

    def get(self, key: int) -> int:
        # 从哈希表获取key对应结果
        res = self.hashmap.get(key, -1)
        if res == -1:
            # 不存在返回-1
            return -1
        else:
            # 将key对应node移到末尾
            self.move_to_tail(key)
            # 返回结果
            return res.value

    def put(self, key: int, value: int) -> None:
        # 如果key已存在在哈希表中
        if key in self.hashmap:
            # 更新哈希表key对应node的value
            self.hashmap[key].value = value
            # 将key对应node移到末尾
            self.move_to_tail(key)
        # key不存在于哈希表中
        else:
            # 如果当前哈希表长度已达到最大容量，需要删除一个最长未使用节点，也就是头节点的下一个节点
            if len(self.hashmap) == self.capacity:
                # 从哈希表中删除头节点下一个节点key对应的数据
                self.hashmap.pop(self.head.next.key)
                # 双向链表中删除该节点
                self.head.next = self.head.next.next
                self.head.next.pre = self.head
            # 定义一个新节点
            node = ListNode(key, value)
            # key: node 存储于哈希表中
            self.hashmap[key] = node
            # 新节点插入到尾节点之前
            node.next = self.tail
            node.pre = self.tail.pre
            self.tail.pre = node
            node.pre.next = node
```

18. 员工派遣 二分法

**题目**
```
某公司部门需要派遣员工去国外做项目。
现在，代号为 x 的国家和代号为 y 的国家分别需要 cntx 名和 cnty 名员工部门每个员工有一个员工号 (1,2,3,......)，工号连续，从 1开始。部长派遣
则: 规则1: 从 1,k中选择员工派遣出去
规则2: 编号为 x的倍数的员工不能去 x国，编号为 y 的倍数的员工不能去y 国
问题
找到最小的k，使得可以将编号在 [1,k] 中的员工分配给 x 国和 y 国，且满足 x 国和 y 国的需求
```
**输入描述**
```
四个整数 x,y,cntx,cnty。
2 < x < y < 30000
x和y 一定是 质数
1 < cntx, cnty < 10^9
cntx + cnty < 10^9
```
**输出描述**
```
满足条件的最小的 k
```
**示例1：**
```
输入：
2 3 3 1
输出：
5
说明: 输入中：
2 表示国家代号 2
3 表示国家代号 3
3 表示国家 2 需要3 个人
1 表示国家 3 需要1个人
输出的5表示k最小为5
```
**思路**
```
1：C卷的场景题特别多，我们需要阅读题干来获取题目想表达的真是题意。这个题目的最后一句：【使得可以将编号在 [1,k] 中的员工分配给 x 国
且满足 x 国和 y 国的需求】，其实核心就是规则2：【编号为 x的倍数的员工不能去 x国，编号为 y 的倍数的员工不能去y 国】
2：那这样的话，其实就是求1~k中，是x的倍数的个数（可以去y国），和是y的倍数的个数（可以去x国），如果既不是x也不是y的倍数，也需要纳
3：首先，1~k中能够被x整除的数个数为 k/x, 能够被y整除的个数为k/y，这个属于数学的前置知识了。其次，1~k中,既能被x整除，也能够被y整除的
就是 k/x*y。这样的话，既不是x也不是y的倍数，就是 k-k/x-k/y-k/x*y。
4：我们主要求的就是【既不是x也不是y的倍数】，因为这个数可以分给两者。从直觉上来说，k越大，肯定数字越多，满足条件的可能性也就越大
们可以使用二分法来判定当前的数字是否满足条件。
```
**代码**
```python
class Solution:

    def solve(self, x, y, cx, cy):
        left = 0
        right = pow(10, 9)
        while left < right:
            mid = (left + right) >> 1
            # cx - mid//y + mid//(x*y) 求的是x用y的倍数去填，但是不用公倍数，还需要几个非x y倍数的人
            # cy - mid//x + mid//(x*y) 求的是y用x的倍数去填，但是不用公倍数，还需要几个非x y倍数的人
            # 负数代表另一家公司倍数的人够用，不需要额外的人，为0
            target = max(0, cx - mid//y + mid//(x*y)) + max(0, cy - mid//x + mid//(x*y))
            # 如果非x y倍数的人大于等于需要的，右边界更新为mid
            if mid - mid//x - mid//y + mid//(x*y) >= target:
                right = mid
            else:
                left = mid + 1
        return left

s = Solution()
print(s.solve(2,3,3,1))
```

19. 跳格子3 动态规划

**题目**
```
小明和朋友们一起玩跳格子游戏，每个格子上有特定的分数score = [1 -1-6 7 -17 7]，从起点score[0]开始，每次最大的步长为k，请你返回小明跳到
score[n-1]时，能得到的最大得分。
注
格子的总长度和步长的区间在[1，100000]
每个格了的分数在[-10000,10000]区间中
```
**输入描述**
```
6//第一行输入总的格了数量
1 -1 -6 7 -17 7/第二行输入每个格子的分数score[i]
2//第三行输入最大跳的步长k
```
**输出描述：**
```
一个整数代表最大得分。
```
**示例1：**
```
输入：
6
1 -1 -6 7 -17 7
2
输出：
14
```
**代码**
```python
class Solution:

    def solve(self, nums, k):
        n = len(nums)
        dp = [float('-inf')] * n
        dp[0] = nums[0]
        for i in range(1, k):
            dp[i] = nums[i] + max(dp[:i])
        for j in range(k, n):
            dp[j] = nums[j] + max(dp[j-k:j])
        return dp[-1]


s = Solution()
print(s.solve([1,-1,-6,7,-17,7], 2))
```

20. 贪吃的猴子 逻辑分析

**题目**
```
一只贪吃的猴子，来到一个果园，发现许多串香蕉排成一行，每串香蕉上有若干根香蕉。每串香蕉的根数由数组numbers给出。猴子获取香蕉，每
从行的开头或者未尾获取，并且只能获取N次，求猴子最多能获取多少根香蕉。
```
**输入描述**
```
第一行为数组numbers的长度
第二行为数组numbers的值每个数字通过空格分开
第三行输入为N，表示获取的次数
```
**输出描述**
```
按照题目要求能获取的最大数值
```
**示例1**
```
输入
7
1 2 2 7 3 6 1
3
输出
10
```
**示例2**
```
输入
3
1 2 3
3
输出
6
说明
全部 获取所有 的香蕉，因此最终根数为1+2+3 = 6
```
**示例3：**
```
输入
4
4 2 2 3
2
输出
7
说明
第一次获取香蕉为行的开头，第二次获取为行的末尾，因此最终根数为4+3 =7
```
**代码**
```python
class Solution:

    def solve(self, n, bananas, m):
        tmp = 0
        for i in range(m):
            tmp += bananas[i]
        res = tmp
        left = m-1
        right = n-1
        while left >= 0:
            tmp += bananas[right] - bananas[left]
            if tmp > res:
                res = tmp
            left -= 1
            right -= 1
        return res

s = Solution()
print(s.solve(6, [2,4,3,2,10,1], 2))
```

21. 项目排期 二分+回溯

**题目描述**
```
项目组共有 N 个开发人员，项目经理接到了 M 个独立的需求，每个需求的工作量不同，且每个需求只能由一个开发人员独立完成，不能多人合作。
假定各个需求直接无任何先后 依赖关系 ，请设计算法帮助项目经理进行工作安排，使整个项目能用最少的时间交付。
```
**输入描述**
```
第一行输入为 M 个需求的工作量，单位为天，用逗号隔开。
例如：
X1 X2 X3 ... Xm
表示共有 M 个需求，每个需求的工作量分别为X1天，X2天，...，Xm天。其中：
0 < M < 30
0 < Xm < 200
第二行输入为项目组人员数量N
例如：
5
表示共有5名员工，其中 0 < N < 10
```
**输出描述**
```
最快完成所有工作的天数
例如：
25
表示最短需要25天完成所有工作
```
**用例**
```
输入
6,2,7,7,9,3,2,1,3,11,4
2
输出
28
```
**代码**
```python

# 输入获取
balls = list(map(int, input().split()))
n = int(input())
 
 
def check(index, buckets, limit):
    """
    :param index: 要被装入球的（balls）索引
    :param buckets: 桶数组，buckets[i]记录第i个桶的已经使用的容量
    :param limit: 每个桶的最大容量，即限制
    :return: k个桶（每个桶容量limit）是否可以装下所有balls
    """
    if index == len(balls):
        # 如果balls已经取完，则说明k个limit容量的桶，可以装完所有balls
        return True
 
    # select是当前要装的球
    selected = balls[index]
 
    # 遍历桶
    for i in range(len(buckets)):
        # 剪枝优化
        if i > 0 and buckets[i] == buckets[i - 1]:
            continue
 
        # 如果当前桶装了当前选择的球后不超过容量限制，则可以装入
        if selected + buckets[i] <= limit:
            buckets[i] += selected
            # 递归装下一个球
            if check(index + 1, buckets, limit):
                return True
            # 如果这种策略无法装完所有球，则回溯
            buckets[i] -= selected
 
    return False
 
 
# 算法入口
def getResult():
    # 这里对balls降序，有利于降低后面回溯操作的复杂度
    balls.sort(reverse=True)
 
    # 分范围：即每个桶的容量最小，最大值
    low = balls[0]  # 桶至少要有max(balls)的容量
    high = sum(balls)  # 当只有一个桶时，此时该桶容量要装下所有balls
 
    # 记录题解
    ans = high
 
    # 二分找中间值作为桶容量
    while low <= high:
        mid = (low + high) >> 1
 
        if check(0, [0] * n, mid):
            # 如果k个mid容量的桶，可以装完所有balls，那么mid容量就是一个可能解，但不一定是最优解，我们应该尝试更小的桶容量
            ans = mid
            high = mid - 1
        else:
            # 如果k个mid容量的桶，无法装完所有balls，那么说明桶容量取小了，我们应该尝试更大的桶容量
            low = mid + 1
 
    return ans
 
 
# 算法调用
print(getResult())
 
```

22. 亲子游戏 BFS

**题目描述**
```
宝宝和妈妈参加亲子游戏，在一个二维矩阵（N*N）的格子地图上，宝宝和妈妈抽签决定各自的位置，地图上每个格子有 不同的 糖果数量，部分格子有障碍物。
游戏规则 是妈妈必须在最短的时间（每个单位时间只能走一步）到达宝宝的位置，路上的所有糖果都可以拿走，不能走障碍物的格子，只能上下左右走。
请问妈妈在最短到达宝宝位置的时间内最多拿到多少糖果（优先考虑最短时间到达的情况下尽可能多拿糖果）。
```
**输入描述**
```
第一行输入为 N，N 表示二维矩阵的大小
之后 N 行，每行有 N 个值，表格矩阵每个位置的值，其中：
-3：妈妈
-2：宝宝
-1：障碍
≥0：糖果数（0表示没有糖果，但是可以走）
```
**输出描述**
```
输出妈妈在最短到达宝宝位置的时间内最多拿到多少糖果，行末无多余空格
备注
地图最大 50*50
```
**用例**
```
输入
4
3 2 1 -3
1 -1 1 1
1 1 -1 2
-2 1 2 3
输出 9
说明
此地图有两条 最短路径 可到达宝宝位置，绿色线和黄
色线都是最短路径6步，但黄色拿到的糖果更多，9个。
输入
4
3 2 1 -3
-1 -1 1 1
1 1 -1 2
-2 1 -1 3
输出 -1
说明
此地图妈妈无法到达宝宝位置
```
**代码**
```python
class Solution:

    def solve(self, n, matrix):
        queue = []
        total = 0
        for x in range(n):
            for y in range(n):
                if matrix[x][y] == -3:
                    queue.append([x, y, 0])
                    break
        flag = False
        while queue:

            if not flag:
                for _ in range(len(queue)):
                    node = queue.pop(0)
                    matrix[node[0]][node[1]] = -1
                    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nx, ny = node[0] + dx, node[1] + dy
                        if 0 <= nx < n and 0 <= ny < n and matrix[nx][ny] != -1:
                            queue.append([nx, ny, matrix[nx][ny] + node[2]])
                            if matrix[nx][ny] == -2:
                                flag = True
            else:
                for _ in range(len(queue)):
                    node = queue.pop(0)
                    if matrix[node[0]][node[1]] == -2:
                        total = max(total, node[2] + 2)
        return total if total else -1


s = Solution()
print(s.solve(4, [[3,2,1,-3], [-1,-1,1,1],[1,1,-1,2],[-2,1,-1,3]]))
```

23. 可处理的最大任务数 优先队列

*题目**
```
在某个项目中有多个任务(用 tasks 数组表示) 需要您进行处理，其中 tasks[i] = [si, ei] 你可以在 s[i] <= day <= e[i]中的任意天处理该任务。请返回你
理的最大任务数。
注:一天可以完成一个任务的处理
```
**输入描述:** 
```
第一行为任务数量n,1<= n<= 100000。
后面n行表示各任务的开始时间和终止时间，用 si和ei表示，1= si<= ei<=100000.
```
**输出描述:**
```
输出为一个整数，表示可以处理的最大任务数
```
**示例1**
```
输入:
3
1 1
1 2
1 3
输出:
3
说明: 第一天处理任务 1，第二天处理任务 2，第三天处理任务 3。
```
**解析**
```
1、统计输入的所有任务的时间段，仅按照结束时间降序，得到数组ranges
2、定义一个优先队列pq，仅用于保存任务的开始时间（开始时间越大，优先级越高），我们可以认为优先队列中保存的任务（的开始时间）对应的结束时间都是相同的，我们定义这个公共结束时间为pq_end
3、遍历ranges，得到每一个任务的开始，结束时间range：[start, end]，然后比较遍历到任务的end 和 优先队列中所有任务的公共结束时间pq_end：
如果 end < pq_end，则在end ~ pq_end 这段间隔时间内，我们可以从pq中挑选出pq_end - end 个 较短任务进行执行，执行前需要检查 对应任务的开始时间 start <= pq_end，若不满足则不执行。每执行一个任务，则pq_end -= 1，count += 1（count是已执行的任务数量）。当pq_end == end时，则将当前遍历的任务的start 加入 优先队列。
```
**代码**
```python
import heapq
import sys
 
# 输入获取
n = int(input())
ranges = [list(map(int, input().split())) for _ in range(n)]
 
 
# 算法入口
def getResult():
    # 将所有任务按照结束时间降序
    ranges.sort(key=lambda x: -x[1])
 
    # 优先队列中记录的是任务的开始时间，并且开始时间越大，优先级越高
    # 由于heapq默认是数值越小，优先级越大，因此这里存入负数的开始时间到pq
    pq = []
 
    # 优先队列中记录的是结束时间相同的任务的开始时间，pq_end就是优先队列中任务的相同结束时间
    pq_end = sys.maxsize
 
    # 最大任务数
    count = 0
 
    # 当前任务的开始和结束时间
    for start, end in ranges:
        # 如果当前任务的结束时间 小于 优先队列中记录的任务的结束时间，则两个结束时间之间的间隔时间段，可以处理一些紧急任务
        while len(pq) > 0 and end < pq_end:
            # 这里的紧急任务即指时间短的任务，即开始时间比较大的任务
            if -heapq.heappop(pq) <= pq_end:
                # 如果紧急任务的开始时间未超过其结束时间，则可以执行
                count += 1
                pq_end -= 1  # 一个时刻只执行一个任务
 
        # 间隔时间消耗完后，优先队列中的任务的结束时间全部更新为当前任务的结束时间
        heapq.heappush(pq, -start)
        pq_end = end
 
    # 收尾处理
    while len(pq) > 0:
        if -heapq.heappop(pq) <= pq_end:
            count += 1
            pq_end -= 1
 
    return count
 
 
# 算法调用
print(getResult())
```

24. 推荐多样性 逻辑分析

**题目**
```
推荐多样性需要从多个列表中选择元素，一次性要返回N屏数据(窗口数量)，每屏展示K个元素(窗口大小)，选择策略
1.各个列表元素需要做穿插处理，即先从第一个列表中为每屏选择一元素，再从第二个列表中为每屏选择一个元素，依次类推
2.每个列表的元素尽量均分为N份，如果不够N个，也要全部分配完，比如下面的例子:
(1)从第一个列表中选择4条0 12 3，分别放到4个窗口中
(2)从第二个列表中选择4条10 11 12 13，分别放到4个窗口中
(3)从第三个列表中选择4条20 21 22 23，分别放到4个窗口
(4)再从第一个列表中选择4条4 5 6 7，分别放到4个窗口中
(5)再从第一个列表中选择，由于数量不足4条，取剩下的2条，放到窗1和窗口2(6)再从第二个列表中选择，由于数量不足4条并且总的元素数达到窗
求，取18 19放到窗口3和窗口4
```
**输入描述**
```
第一行输入为N，表示需要输出的窗口数量，取值范围[1,10]
第二行输入为K，表示每个窗口需要的 元素数量 Q，取值范用[1,100]之后的行数不定(行数取值范围[1,10]，表示每个列表输出的元素列表。元素之
格分隔，已经过准序外理，每人列表输出的元素数量取值范围[1,100]
```
**输出描述**
```
输出元素列表，元素数量=窗口数量“窗口大小，元素之间以空格分隔，多个窗口合并为一个列表输出，参考样例:先输出窗口1的元素列表，再输出
元素列表，再输出窗口3的元素列表，最后输出窗口4的元素列表
```
**示例1**
```
输入
4
7
0 1 2 3 4 5 6 7 8 9
10 11 12 13 14 15 16 17 18 19
20 21 22 23 24 25 26 27 28 29
输出
0 10 20 4 14 24 8 1 11 21 5 15 25 9 2 12 22 6 16 26 18 3 13 23 7 17 27 19
说明：
1.每个列表会保证元素数最满足窗口要求，不需要考虑元素不足情况
2.每个列表的元素已去重，不需要考虑元素重复情况
3.每个列表的元素列表均不为空，不需要考虑列表为空情况
4.每个列表的元素列表已经过排序处理，输出结果要保证不改变同一个列表的元素顺序
5.每个列表的元素数量可能是 不同的
```

**代码**
```python
# 输入获取
n = int(input())
k = int(input())
 
lists = []
while True:
    try:
        lists.append(list(map(int, input().split())))
    except:
        break
 
 
# 算法入口
def getResult():
    # 窗口矩阵，k行n列，每一列对应一个窗口，这里将二维矩阵一维化，方便后面赋值
    windows = [0] * (k * n)
    # 窗口矩阵中正在赋值的索引位置
    idx = 0
    # 正在从第level个列表中取值
    level = 0
 
    # 当窗口矩阵填满后，结束循环
    while idx < len(windows):
        # 当前轮次是否发生了"借"动作
        flag = False
 
        # 从第level个列表中取前n个元素
        for _ in range(n):
            windows[idx] = lists[level].pop(0)
            idx += 1
 
            # 如果第level个列表没有元素了，则继续切到下一个列表中"借"
            if len(lists[level]) == 0 and len(lists) > 1:
                lists.pop(level)  # 删除空列表
                level %= len(lists)  # 防止越界
                flag = True  # 发生了"借"动作
 
        #  如果没有发生"借"动作，则需要切到下一行
        if not flag:
            level = (level + 1) % len(lists)  # 防止越界
 
    ans = []
 
    # 遍历列号
    for j in range(n):
        # 遍历行号
        for i in range(k):
            # 按列收集元素
            ans.append(windows[i * n + j])
 
    return " ".join(map(str, ans))
 
 
# 算法调用
print(getResult())
```

25. 两个字符串间的最短路径问题 动态规划

**题目描述**
```
给定两个 字符串 ，分别为字符串 A 与字符串 B。
例如 A字符串为 "ABCABBA"，B字符串为 "CBABAC" 可以得到下图 m * n 的 二维数组 ，定义原点为(0,0)，终点为(m,n)，水平与垂直的每一条边距
射成坐标系如下图。
从原点 (0,0) 到 (0,A) 为水平边，距离为1，从 (0,A) 到 (A,C) 为垂直边，距离为1；
假设两个字符串同一位置的两个字符相同，则可以作一个斜边，如 (A,C) 到 (B,B) 最短距离为斜边，距离同样为1。
作出所有的斜边如下图，(0,0) 到 (B,B) 的距离为：1 个水平边 + 1 个垂直边 + 1 个斜边 = 3。
```
**输入描述**
```
空格分割的两个字符串 A 与字符串 B
字符串不为"空串"
字符格式满足正则规则：[A-Z]
字符串长度 < 10000
```
**输出描述**
```
原点到终点的最短距离
```
**用例**
```
输入 ABC ABC
输出 3
说明 无
输入 ABCABBA CBABAC
输出 9
说明 无
```
**代码**
```python
class Solution:

    def solve(self, str1, str2):
        dp = [i for i in range(len(str1) + 1)]
        pre = dp[0]
        for j in range(len(str2)):
            for i in range(len(str1) + 1):
                tmp = dp[i]
                if i == 0:
                    dp[i] += 1
                else:
                    if str2[j] == str1[i-1]:
                        dp[i] = pre + 1
                    else:
                        dp[i] = min(dp[i-1], dp[i]) + 1
                pre = tmp
        return dp[-1]


s = Solution()
print(s.solve('ABCABBA', 'CBABAC'))
```

26. 跳马 BFS

**题目描述**
```
马是象棋（包括 中国象棋 和国际象棋）中的棋子，走法是每步直一格再斜一格，即先横着或者直者走一格，然后再斜着走一个对角线，可进可退，
界，俗称"马走日"字。
给定 m 行 n 列的棋盘（网格图），棋盘上只有棋子象棋中的棋子“马”，并且每个棋子有等级之分，等级为 k 的马可以跳 1~k 步（走的方式与象棋中“马
样，不可以超出棋盘位置），问是否能将所有马跳到同一位置，如果存在，输出最少需要的总步数（每匹马的步数相加），不存在则输出-1。
注：允许不同的马在跳的过程中跳到同一位置，坐标为（x,y）的马跳一次可以跳到的坐标为：(x+1, y+2)，(x+1, y-2)，(x+2, y+1)，(x+2, y-1)，(x-1, y
y-2)，(x-2, y+1)，(x-2, y-1)，的格点上，但是不可以超出棋盘范围。
```
**输入描述**
```
第一行输入m，n，代表 m 行 n 列的网格图棋盘（1 ≤ m, n ≤ 25）
接下来输入 m 行 n 列的网格图棋盘，如果第 i 行，第 j 列的元素为 "." ，代表此格点没有棋子，如果为数字 k（1 ≤ k ≤ 9），代表此格点存在等级为 k 
```
**输出描述**
```
输出最少需要的总步数（每匹马的步数相加），不存在则输出-1。
```
**用例**
```
输入
3 2
..
2.
..
输出 0
说明 只有一匹马，不需要跳动
输入
3 5
47.48
4744.
7....
输出 17
说明 无
```
**代码**
```python
import sys
 
# 输入获取
m, n = map(int, input().split())  # 棋盘行数, 棋盘列数
grid = [input() for _ in range(m)]  # 棋盘矩阵
stepGrid = [[0] * n for _ in range(m)]  # 最小步数和矩阵，stepMap[i][j]记录各个马走到棋盘(i,j)位置的最小步数之和
 
# 记录所有马都可达的公共位置坐标
reach = set()
for i in range(m):
    for j in range(n):
        reach.add(i * n + j)
 
# 马走日的偏移量
offsets = ((1, 2), (1, -2), (2, 1), (2, -1), (-1, 2), (-1, -2), (-2, 1), (-2, -1))
 
 
# 广搜
def bfs(sx, sy, k):
    global reach
 
    # 广搜队列
    # (sx,sy)为马所在初始位置，马到达初始位置需要0步
    queue = [(sx, sy, 0)]
 
    # 记录该马可以访问(sx,sy)位置
    vis = set()
    vis.add(sx * n + sy)  # 二维坐标一维化
 
    # k记录该马剩余可走步数
    while len(queue) > 0 and k > 0:
        # newQueue记录该马花费相同步数的可达的位置（即BFS按层遍历的层）
        newQueue = []
 
        # 按层BFS
        for x, y, step in queue:
            for offsetX, offsetY in offsets:
                # 马走日到达的新位置
                newX = x + offsetX
                newY = y + offsetY
 
                pos = newX * n + newY
 
                # 如果新位置越界或者已访问过，则不能访问
                if newX < 0 or newX >= m or newY < 0 or newY >= n or (pos in vis):
                    continue
 
                # 将新位置加入新层
                newQueue.append((newX, newY, step + 1))
 
                # 该马到达(newX, newY)位置最小步数为step+1, 由于该马首次到达(newX, newY)位置，因此step+1就是最小步数
                stepGrid[newX][newY] += step + 1
 
                # 记录该马访问过该位置，后续如果该马再次访问该位置，则不是最小步数
                vis.add(pos)
 
        queue = newQueue
        k -= 1  # 剩余步数减1
 
    # BFS完后，将公共可达位置reach和当前马可达位置vis取交集，交集部分就是新的公共可达位置
    reach &= vis
 
 
# 算法入口
def getResult():
    # 遍历棋盘
    for i in range(m):
        for j in range(n):
            # 如果棋盘(i,j)位置是马
            if grid[i][j] != '.':
                # 马的等级
                k = int(grid[i][j])
                # 对该马进行BFS走日
                bfs(i, j, k)
 
    # 如果所有马走完，发现没有公共可达位置
    if len(reach) == 0:
        return -1
 
    # 记录所有马都可达位置的最小步数和
    minStep = sys.maxsize
 
    for pos in reach:
        x = pos // n
        y = pos % n
        # (x,y)是所有马都可达的位置，stepMap[x][y]记录所有马到达此位置的步数和
        minStep = min(minStep, stepGrid[x][y])
 
    return minStep
 
 
# 算法调用
print(getResult())
```

27. 字符串拼接 递归+回溯

**题目描述**
```
给定 M（0 < M ≤ 30）个字符（a-z），从中取出任意字符（每个字符只能用一次）拼接成长度为 N（0 < N ≤ 5）的字符串，
要求相同的字符不能相邻，计算出给定的字符列表能拼接出多少种满足条件的字符串，
输入非法或者无法拼接出满足条件的字符串则返回0。
```
**输入描述**
```
给定的字符列表和结果 字符串长度 ，中间使用空格(" ")拼接
```
**输出描述**
```
满足条件的字符串个数
```
**用例**
```
输入 abc 1
输出 3
说明 给定的字符为a,b,c，结果字符串长度为1，可以拼接成a,b,c，共
3种
输入 dde 2
输出 2
说明 给定的字符为dde，结果字符串长度为2，可以拼接成de,ed，共
2种
```
**代码**
```python
class Solution:

    def solve(self, strs, k):
        used = [False] * len(strs)
        ans = 0
        str_list = list(strs)
        str_list.sort()

        def dfs(path, k):
            nonlocal ans
            nonlocal used
            if k == 0:
                ans += 1
            for i in range(len(str_list)):
                if used[i]:
                    continue
                if i > 0 and str_list[i] == str_list[i-1] and not used[i-1]:
                    continue
                if not path or str_list[i] != path[-1]:
                    used[i] = True
                    path.append(str_list[i])
                    dfs(path, k-1)
                    path.pop()
                    used[i] = False

        dfs([], k)
        return ans

s = Solution()
print(s.solve('dede', 3))
```

28. Wonderland 动态规划

**题目描述**
```
Wonderland是小王居住地一家很受欢迎的游乐园。Wonderland目前有4种售票方式，分别为一日票（1天）、三日票（3天）、周票（7天）和月票（3
每种售票方式的价格由一个数组给出，每种票据在票面时限内可以无限制地进行游玩。例如：
小王在第10日买了一张三日票，小王可以在第10日、第11日和第12日进行无限制地游玩。
小王计划在接下来一年多次游玩该游乐园。小王计划地游玩日期将由一个数组给出。
现在，请您根据给出地售票价格数组和小王计划游玩日期数组，返回游玩计划所需要地最低消费。
```
**输入描述**
```
输入为2个数组：
售票价格数组为costs，costs.length = 4，默认顺序为一日票、三日票、周票和月票。
小王计划游玩日期数组为days，1 ≤ days.length ≤ 365，1 ≤ days[i] ≤ 365，默认顺序为升序。
```
**输出描述**
```
完成游玩计划的最低消费。
```
**用例**
```
输入 5 14 30 100
1 3 5 20 21 200 202 230
输出 40
```
**说明**
```
根据售票价格数组和游玩日期数组给出的信息，发现每次去玩的
时候买一张一日票是最省钱的，所以小王会卖8张一日票，每张5
元，最低花费是40元。
题目解析
本题可以使用 动态规划 求解。
定义一个dp数组，dp[i] 的含义是：前 i 天，完成所有游玩日的最少花费金额。
dp[i] 可以由前面的 dp状态 推导而来：
如果第 i 天不是游玩日，即第 i 天不需要考虑花钱买票，那么：dp[i] = dp[i-1]
如果第 i 天是游玩日，那么此时有四种选择：
1. 如果第 i 天被购买的"一日票"有效期覆盖，那么：dp[i] = dp[i-1] + costs[0]，其中：
dp[i - 1] 是前 i-1 天的花费
costs[0] 是第 i 天的花费，即第 i 天买了当天有效的"一日票"
2. 如果第 i 天被购买的"三日票"有效期覆盖，那么：dp[i] = ( i ≥ 3 ? dp[i-3] : 0 ) + costs[1]
我们可以认为在第 i - 2 天购买了"三日票"，其有效期覆盖第 i-2 天，第i-1天，第i天，这段时间的花费是 costs[1]
而第 i-2 天之前，即：第0天~第i-3天的花费是dp[i-3]，此时需要注意 i - 3 可能为负数，如果为负数，则表示第 i-2 天之前没有花费，即为0
3. 如果第 i 天被购买的"七日票"有效期覆盖，那么：dp[i] = ( i ≥ 7 ？dp[i-7] : 0) + costs[2]
原理同上
4. 如果第 i 天被购买的"月票"有效期覆盖，那么：dp[i] = ( i ≥ 30 ？dp[i-30] : 0) + costs[3]
原理同上
因此，如果第 i 天是游玩日，那么我们可以选择上面四种花费中最小的花费。
最后只需要返回 dp[maxDay] 即可，其中maxDay为最大的游玩日，即为days[days.length - 1]。
```
**代码**
```python
class Solution:

    def solve(self, prices, days):
        dp = [0] * (days[-1] + 1)
        index = 0
        for i in range(1, days[-1] + 1):
            if i == days[index]:
                buy1 = prices[0] + dp[i-1]
                buy3 = prices[1] + (dp[i-3] if i >= 3 else 0)
                buy7 = prices[2] + (dp[i-7] if i >= 7 else 0)
                buy30 = prices[3] + (dp[i-30] if i >= 30 else 0)
                dp[i] = min(buy1, buy3, buy7, buy30)
                index += 1
            else:
                dp[i] = dp[i-1]
        return dp[-1]


s = Solution()
print(s.solve([5,14,30,100], [1,3,5,20,21,200,202,230]))
```

29. 伐木工 动态规划

**题目**
```
一根X米长的树木，伐木工切割成不同长度的木材后进行交易，交易价格为每根木头长度的乘积。规定切割后的每根木头长度都为正整数,也可以不
接拿整根树木进行交易。请问伐木工如何尽量少的切割，才能使收益最大化?
```
**输入描述:** 
```
木材的长度(X<=50)
```
**输出描述:** 
```
输出最优收益时的各个树木长度，以空格分割，按升序排列
```
**示例1**
```
输入:
10
输出:
3 3 4
说明:
1.一根2米长的树木，伐木工不切割，为2* 1，收益最大为2
2.一根4米长的树木，伐木工不需要切割为2 *2，省去切割成本，直接整根树木交易，为4*1，收益最大为4
3.一根5米长的树木，伐木工切割为2*3，收益最大为 6
4.一根10米长的树木，伐木工可以切割为方式: 3，4,3，也可以切割为方式二: 3,2，2,3，但方式二伐木工多切割了一次增加切割成本却卖了一样的
此并不是最优收益。
```
**思路**
```
1：收益类的问题，包括 股票交易 类题目，可以直接按照贪心算法往上靠。
```
**代码**
```python
class Solution:

    def solve(self, n):
        dp = [0] * (n+1)
        mem = [[] for _ in range(n+1)]
        for i in range(1, n+1):
            dp[i] = i
            mem[i].append(i)
        for i in range(1, n+1):
            for j in range(1, i):
                if dp[i] > dp[j] * dp[i-j]:
                    continue
                elif dp[i] < dp[j] * dp[i-j]:
                    dp[i] = dp[j] * dp[i-j]
                    mem[i] = mem[j] + mem[i-j]
                else:
                    if len(mem[i]) > len(mem[j]) + len(mem[i-j]):
                        mem[i] = mem[j] + mem[i - j]
        return mem[-1]


s = Solution()
print(s.solve(8))
```

30. 抢7游戏 动态规划

**题目**
```
A、B两个人玩抢7游戏， 游戏规则 为A先报一个起始数字X(10<起始数字<10000)，B报下一个数字Y(X-Y<3), A再报个数字Z(Y-Z<3)，以此类推，
中一个抢到7，抢到7即为胜者;在B赢得 比赛的情况下，一共有多少种组合?
```
**输入描述:** 
```
起始数字M，如100; 10<=M<=10000
```
**输出描述:**
```
B能赢得比赛的 组合次数
```
**示例1**
```
输入:
10
输出：
1
```
**思路**
```
可以倒过来求从B数7到A数起始数字有多少种组合，动态规划
```
**代码**
```python
class Solution:

    def solve(self, n):
        dp = [[0] * (n+1) for _ in range(2)]
        dp[0][7] = 1
        dp[1][7] = 0
        for i in range(8, n+1):
            dp[0][i] = dp[1][i-1] + dp[1][i-2]
            dp[1][i] = dp[0][i-1] + dp[0][i-2]
        return dp[1][-1]


s = Solution()
print(s.solve(100))
```

31. 篮球游戏 双端队列

**题目**
```
幼儿园里有一个放倒的圆桶，它是一个 线性结构 ，允许在桶的右边将篮球放入，可以在桶的左边和右边将篮球取出。每个篮球有单独的编号，老
连续放入一个或多个篮球，小朋友可以在桶左边或右边将篮球取出，当桶只有一个篮球的情况下，必须从左边取出。
如老师按顺序放入1、2、3、4、5共有5 个编号的篮球，那么小朋友可以依次取出编号为1、2、3、4、5或者 3、1、2.4、5 编号的篮球，无法取出
3、2、4 编号的篮球
其中 3、1、2、4、5 的取出场景为:
->连续放入1、2、3号
->从右边取出3号
->从左边取出1号
->从左边取出2号
->放入4号
->从左边取出4号
->放入5号
->从左边取出5号
简答起见，我们以 L 表示左，R表示右，此时取出篮球的依次取出序列为“RLLLL”。
```
**输入描述**
```
每次输入包含一个 测试用例
1.第一行的数字作为老师依次放入的篮球编号
2.第二行的数字作为要检查是否能够按照放入的顺序取出给定的篮球的编号，其中篮球的编号用逗号进行分隔. 其中篮球编号用逗号进行分隔。
```
**输出描述**
```
对干每个篮球的取出席列，如果确实可以获取，请打印出其按照左右方向的操作取出顺序，如果无法获取则打印“NO”
备注
1<篮球编号，篮球个数≤200
篮球上的数字不重复
输出的结果中 LR 必须为大写
```
**示例1：**
```
输入：
4,5,6,7,0,1,2
6,4,0,1,2,5,7
输出：
RLRRRLL
说明：
篮球的取出顺序依次为"右、左、右、右、右、左、左" 
```
**示例2：**
```
输入：
4,5,6,7,0,1,2
6,0,5,1,2,4,7
输出：
NO
```
**代码**
```python
class Solution:

    def solve(self, n1, n2):
        index1 = 0
        index2 = 0
        stack = []
        ans = ''
        while index2 < len(n2) and index1< len(n1):
            while index1< len(n1):
                stack.append(n1[index1])
                index1 += 1
                if stack[-1] == n2[index2]:
                    break
            while stack and (n2[index2] == stack[0] or n2[index2] == stack[-1]):
                if n2[index2] == stack[0]:
                    ans += 'L'
                    stack.pop(0)
                elif n2[index2] == stack[-1]:
                    ans += 'R'
                    stack.pop()
                index2 += 1

        return ans if not stack else 'NO'

s = Solution()
print(s.solve([4,5,6,7,0,1,2], [6,4,0,1,2,5,7]))
```

32. 宽度最小的子矩阵 滑动窗口

**题目**
```
给定一个矩阵，包含N*M个整数，和一个包含K个整数的数组现在要求在这个矩阵中找一个宽度最小的子矩阵，要求子矩阵包含数组中所有的整数
```
**输入描述**
```
第一行输入两个正整数N，M，表示矩阵大小。
接下来N行M列表示矩阵内容。下一行包含一个正整数K。下一行包含K个整数，表示所需包含的数组，K个整数可能存在重复数字。
所有输入数据小于1000。
```
**输出描述**
```
输出包含一个整数，表示满足要求子矩阵的最小宽度，若找不到，输出-1
```
**示例1**
```
输入
2 5
1 2 2 3 1
2 3 2 3 2
3
1 2 3
输出
2
说明
矩阵第0、3列包含了1、2、3，矩阵第3、4列包含了1、2、3
```
**示例2**
```
输入
2 5
1 2 2 3 1
1 3 2 3 4
3
1 1 4
输出
5
说明
矩阵第1,2,3,4,5列包含了1,1,4
```
**思路**
```
1：题目要求：【宽度最小的子矩阵】，我们需要仔细的看题目的示例，从示例中来看，这里的宽度指的是矩阵的列数。注意不要理解错误。
2：既然题目只要求最小的列数，那我们可以把这个矩阵当做成一个可以使用 滑动窗口法 的数组，每次遍历都选择当前列的所有行即可。
```
**代码**
```python
import sys
 
# 输入获取
n, m = map(int, input().split())  # 矩阵 [行数, 列数]
matrix = [list(map(int, input().split())) for _ in range(n)]  # 矩阵
k = int(input())  # 目标数组长度
nums = list(map(int, input().split()))  # 目标数组
 
# cnts[num] 记录的是 目标数组中num元素的个数
cnts = [0] * 1000
for num in nums:
    cnts[num] += 1
 
 
# 算法入口
def getResult():
    # 未完成匹配的元素的个数
    total = k
 
    # 记录最小子矩阵的宽度
    minLen = sys.maxsize
 
    l = 0  # 当前子矩阵的左边界（列号）
    r = 0  # 当前子矩阵的右边界（列号）
 
    # 如果右边界未越界，则可以继续尝试找最小子矩阵
    while r < m:
        # 将第r列所有元素纳入子矩阵
        for i in range(n):
            #  第r列的元素numR
            numR = matrix[i][r]
 
            # cnts[numR] 记录的是 目标数组中numR元素的个数，也可以理解为：目标数组中numR元素剩余未匹配的个数
            # 如果numR不是目标数组元素，则cnts[numR]初始时必然为0，对于非目标数组元素numR, 即使进行了 cnts[numR]--， 也不影响总的未匹配数量 total
            # 如果numR是目标数组元素，则cnts[numR]初始时必然大于0，且随着子矩阵扩大范围，如果子矩阵中包含numR元素个数超过了初始cnts[numR]数量，则超出部分起不到匹配效果，即不能影响总的未匹配数量
            if cnts[numR] > 0:
                total -= 1
            cnts[numR] -= 1
 
        # 纳入r列后，看看总的未匹配元素数量total还有几个，如果total为0，则说明当前子矩阵匹配到了所有目标数组元素
        while total == 0:
            # 若此时子矩阵宽度 r - l + 1 更小，则更新最小子矩阵宽度
            minLen = min(minLen, r - l + 1)
 
            # 由于当前子矩阵已经匹配到所有目标数组元素，因此下一步应该将 l 右移，尝试更小宽度的子矩阵
            for i in range(n):
                # l 右移，相当于当前子矩阵移除了第 l 列所有元素，被移除的元素numL如果是目标数组元素，则对应的未匹配数量应该被恢复
                numL = matrix[i][l]
 
                # 如果当前numL不是目标数组元素，或者当前numL是目标数组元素，但是属于超出部分（这两种情况必然cnts[numL] < 0），则对应numL元素的恢复，不能影响到整体未匹配数量total，
                # 如果当前numL是目标数组元素，且不是超出部分（此时必然cnts[numL] >= 0），则对应numL元素的恢复，会影响到整体未匹配数量total
                if cnts[numL] >= 0:
                    total += 1
                cnts[numL] += 1
 
            # l右移，且下一轮要继续检查l右移后的子矩阵是否依旧能覆盖目标数组所有元素
            l += 1
 
        # r右移
        r += 1
 
    if minLen == sys.maxsize:
        return -1
    else:
        return minLen
 
 
# 算法调用
print(getResult())
```

33. 启动多任务排序 拓扑排序

**题目描述**
```
一个应用启动时，会有多个 初始化 任务需要执行，并且任务之间有依赖关系，例如A任务依赖B任务，那么必须在B任务执行完成之后，才能开始执
现在给出多条任务 依赖关系 的规则，请输入任务的顺序执行序列，规则采用贪婪策略，即一个任务如果没有依赖的任务，则立刻开始执行，如果同
务要执行，则根据任务名称字母顺序排序。
例如：B任务依赖A任务，C任务依赖A任务，D任务依赖B任务和C任务，同时，D任务还依赖E任务。那么执行任务的顺序由先到后是：
A任务，E任务，B任务，C任务，D任务
这里A和E任务都是没有依赖的，立即执行。
```
**输入描述**
```
输入参数每个元素都表示任意两个任务之间的依赖关系，输入参数中符号"->"表示依赖方向，例如：
A->B：表示A依赖B
多个依赖之间用单个空格分隔
```
**输出描述**
```
输出排序后的启动任务列表，多个任务之间用单个空格分隔
用例
输入 A->B C->B
输出 B A C
说明 无
```
**代码**
```python
class Solution:

    def solve(self, input_strs):
        relations = input_strs.split(' ')
        mp = {}
        indegree = {}
        for item in relations:
            child, parent = item.split('->')[0], item.split('->')[1]
            indegree[parent] = indegree.get(parent, 0)
            indegree[child] = indegree.get(child, 0) + 1

            mp[parent] = mp.get(parent, [])
            mp[parent].append(child)

            mp[child] = mp.get(child, [])

        queue = []
        for task in indegree:
            if indegree[task] == 0:
                queue.append(task)

        ans = []
        while queue:
            queue.sort()
            for _ in range(len(queue)):
                cur = queue.pop(0)
                ans.append(cur)
                for cld in mp[cur]:
                    indegree[cld] -= 1
                    if indegree[cld] == 0:
                        queue.append(cld)
        return ans


s = Solution()
print(s.solve('A->B C->B C->D D->E'))
```

34. 贪心歌手 优先队列
**题目描述**
```
一个歌手准备从A城去B城参加演出。
1. 按照合同，他必须在 T 天内赶到
2. 歌手途经 N 座城市
3. 歌手不能往回走
4. 每两座城市之间需要的天数都可以提前获知。
5. 歌手在每座城市都可以在路边卖唱赚钱。
经过调研，歌手提前获知了每座城市卖唱的收入预期：
如果在一座城市第一天卖唱可以赚M，后续每天的收入会减少D（第二天赚的钱是 M - D，第三天是 M - 2D ...）。如果收入减少到 0 就不会再少
6. 歌手到达后的第二天才能开始卖唱。如果今天卖过唱，第二天才能出发。
贪心 的歌手最多可以赚多少钱？
```
**输入描述**
```
第一行两个数字 T 和 N，中间用空格隔开。
T 代表总天数，0 < T < 1000
N 代表路上经过 N 座城市，0 < N < 100
第二行 N+1 个数字，中间用空格隔开。代表每两座城市之间耗费的时间。
其总和 ≤ T。
接下来 N 行，每行两个数字 M 和 D，中间用空格隔开。代表每个城市的输入预期。
0 < M < 1000
0 < D < 100
```
**输出描述**
```
一个数字。代表歌手最多可以赚多少钱。以回车结束。
```
**用例**
```
输入
10 2
1 1 2
120 20
90 10
输出 540
说明
总共10天，路上经过2座城市。
路上共花 1+1+2=4 天
剩余6天最好的计划是在第一座城市待3天，在第二座城市待3
天。
在第一座城市赚的钱：120 + 100 + 80 = 300
在第二座城市赚的钱：90 + 80 + 70 = 240
```
**题目解析**
```
本题歌手必须从A到B，因此输入的第二行各个城市间的花费的路程时间之和roadCost是必须的，即可用于卖唱赚钱的时间 remain 为 T - roadCost。
我们需要规划 remain 时间，合理分配给各个城市，保证时间分配方案能够赚的钱最多。
按照题目意思，每个城市停留的第一天赚m钱，后面每天减少d，
每个城市停留Y天，那么这Y天中赚的钱是严格递减的，且最后一天（第Y天）赚的钱最少
假设歌手目前在X市
如果前面城市没有用完remain时间，那么当天可以停留在X市卖唱赚钱
如果前面城市已经用完remain时间，那么此时需要比较：
1. 歌手选择在X市当天停留卖唱可以赚的钱 x
2. 歌手前面时间中某天赚的最少的钱 y，由于每个城市停留天数中最后一天赚的钱最少，因此这里的y必然是前面某个城市最后一天赚的钱
如果 x > y，则我们应该将前面赚 y 钱的时间，空闲出来，用于当天赚 x 元，这种替换逻辑，不会改变歌手的行程顺序
如果 x <= y，则X市就没有必要待下去了，因为继续待下去赚的钱只会比x少
上面逻辑中，在前面城市（前面时间）中找一个最小赚的钱，非常适合使用 优先队列 。因此我们可以使用优先队列记录已经赚的钱（按天），如果
超出remain限制，那么就取出优先队列中最小赚的钱，和当天停留可以赚的钱比较，如果当天停留可以赚更多钱，则弹出优先队列中最小赚的钱（含义
最少钱的那天时间空出来）。
```
**代码**
```python
class Solution:

    def solve(self, m, n, costs, prices):
        import heapq
        remain = m - sum(costs)
        moneys = []
        index = 1
        pre = prices[0][0]
        while remain:
            if not moneys:
                heapq.heappush(moneys, pre)
            else:
                pre -= prices[0][1]
                heapq.heappush(moneys, max(pre, 0))
            remain -= 1
        while index < len(prices):
            cur = prices[index][0]
            while moneys and moneys[0] < cur:
                heapq.heappop(moneys)
                heapq.heappush(moneys, cur)
                cur = max(0, cur - prices[index][1])
            index += 1
        return sum(moneys)


s = Solution()
print(s.solve(10, 3, [1,1,2,1], [[120, 20], [90, 10], [150,50]]))
```

35. 反射计数 模拟

**题目**
```
给定一个包含 0 和 1 的二维矩阵
给定一个初始位置和速度
1个物体从给定的初始位置触发,在给定的速度下进行移动,遇到矩阵的边缘则发生镜面反射
无论物体经过 0 还是 1，都不影响其速度
请计算并给出经过 t 时间单位后,物体经过 1 点的次数
矩阵以左上角位置为[0,0](列(x),行(行)),例如下面A点坐标为[2,1](第二列,第一行)
001000010000
001000010000
001000010000
001000010000
001000010000
001000010000
001000010000
注意:
1.如果初始位置的点是 1，也计算在内
2.时间的最小单位为1，不考虑小于 1 个时间单位内经过的点
```
**输入描述**
```
第一行为初始信息
<w> <h> <x> <y> <sx> <sy> <t>
第二行开始一共h行,为二维矩阵信息其中
w,h为矩阵的宽和高
x,y为起始位置
sx,sy为初始速度
t为经过的时间
所有输入都是 有效的 ，数据范围如下
0 < w < 100
0<h < 1000 <= X < W
0 <=y < w
-1 <= sx<= 1
-1 <= sy <= 1
0 <= t< 100
```
**输出描述: **
```
经过1的个数
注意初始位置也要计算在内
```
**示例1**
```
输入:
12 7 2 1 1 -1 13
001000010000
001000010000
001000010000
001000010000
001000010000
001000010000
001000010000
输出:
3
说明: 初始位置为(2,1),速度为(1,-1),那么13个时间单位后,经过点1的个数为3
```
**代码**
```python
class Solution:

    def solve(self, w, h, x, y, sx, sy, t, matrix):
        ans = 0
        for _ in range(t+1):
            if matrix[y][x] == 1:
                ans += 1
            if x + sx < 0 or x + sx >= w:
                sx = -sx
            if y + sy < 0 or y + sy >= h:
                sy = -sy
            y += sy
            x += sx
        return ans


s = Solution()
print(s.solve(12,7,2,1,1,-1,13,[
    [0,0,1,0,0,0,0,1,0,0,0,0],
    [0,0,1,0,0,0,0,1,0,0,0,0],
    [0,0,1,0,0,0,0,1,0,0,0,0],
    [0,0,1,0,0,0,0,1,0,0,0,0],
    [0,0,1,0,0,0,0,1,0,0,0,0],
    [0,0,1,0,0,0,0,1,0,0,0,0],
    [0,0,1,0,0,0,0,1,0,0,0,0],
]))
```

36. 模拟目录管理功能 树形结构
**题目**
```
实现一个模拟目录管理功能的软件，输入一个命令序列，输出最后一条命令运行结果。 支持命令:
1)创建目录命令: mkdir 目录名称，如mkdir abc为在当前目录创建abc目录，如果已存在同名目录则不执行任何操作。此命令无输出。
2) 进入目录命令 : cd 目录名称,如cd abc为进入abc目录，特别地，cd ..为返回上级目录，如果目录不存在则不执行任何操作。此命令无输出。
3)查看当前所在路径命令: pwd，输出当前路径 字符串
约束: 1)目录名称仅支持小写字母;mkdir和cd命令的参数仅支持单个目录，如: mkdir bc和cd abc;不支持嵌套路径和绝对路径，如mkdir abc/efg
abc/efg,mkdir /abc/efg,cd /abc/efg是不支持的。
2)目录符号为/，根目录/作为初始目录。
```
**输入描述**
```
输入N行字符串，每一行字符串是一条命令。
```
**输出描述**
```
输出最后一条命令运行结果字符串
```
**示例1**
```
输入
mkdir abc
cd abc
pwd
输出
/abc/
备注
命令行数限制100行以内，目录名称限制10个字符以内。
```
**思路**
```
1：本题第一个核心的考点其实在于对输入有效性的判定。
2：读题目之后可以总结出输入有效性的三个条件，这三个条件，分别要在不同的情况下做特殊处理，但是其实也就两种类型cd和mkdir需要处理：
 1: 长度是否为2
 2: 目录是否满足都是小写字母的条件 cd 特殊条件 ..
 3: 是否存在同名目录
3：第二个核心考点就是保存当前所有的目录关系，用来判断cd和mkdir是否有效。
```
**代码**
```python
class Dic:
    def __init__(self, name, father=None):
        self.name = name
        self.child = []
        self.father = father

class Solution:
    def __init__(self):
        self.current = None

    def validate(self, op):
        flag = True
        if len(op) != 2:
            flag = False
        else:
            if op[0] == 'mkdir':
                for x in op[1]:
                    if not x.islower():
                        flag = False
                        break
                if op[1] in self.current.child:
                    flag = False
            elif op[0] == 'cd':
                if op[1] == '..':
                    if not self.current.father:
                        flag = False
                else:
                    for x in op[1]:
                        if not x.islower():
                            flag = False
                            break
                    all_child = []
                    for child in self.current.child:
                        all_child.append(child.name)
                    if op[1] not in all_child:
                        flag = False
        return flag

    def solve(self, operations):
        root = Dic('', father=None)
        self.current = root
        for operation in operations:
            op = operation.split(' ')
            if op[0] == 'mkdir':
                if self.validate(op):
                    self.current.child.append(Dic(op[1], self.current))
            elif op[0] == 'cd':
                if self.validate(op):
                    if op[1] == '..':
                        self.current = self.current.father
                    else:
                        for x in self.current.child:
                            if x.name == op[1]:
                                self.current = x
            elif op[0] == 'pwd':
                res = []
                node = self.current
                while node:
                    res.append(node.name)
                    node = node.father
                return '/'.join(res[::-1]) + '/'

s = Solution()
print(s.solve(['mkdir Abc', 'cd abc', 'mkdir abc', 'cd abc', 'pwd']))
```

37. 加密算法 dfs
**题目**
```
有一种特殊的 加密算法 ，明文为一段数字串，经过密码本查找转换，生成另一段密文数字串。规则如下
1.明文为一段数字串由0-9组成
2.密码本为数字0-9组成的 二维数组
3.需要按明文串的数字顺序在密码本里找到同样的数字串，密码本里的数字串是由相邻的单元格数字组成，上下和左右是相邻的，注意:对角线不相
一个单元格的数字不能重复使用。
4.每一位明文对应密文即为密码本中找到的单元格所在的行和列序号(序号从0开始)组成的两个数字。如明文第位Data[i]对应密码本单元格为Book[x
明文第i位对应的密文为XY，X和Y之间用空格隔开
如果有多条密文，返回字符序最小的密文。如果密码本无法匹配，返回"error"
请你设计这个加密程序
```
**输入描述**
```
第一行输入1个正整数N,代表明文的长度(1 <= N <= 200)
第二行输入N个明文数字组成的序列Data[i] (整数: 0<= Data[i] <= 9)
第三行1个正整数M,代表密文的长度接下来M行，每行M个数，代表密文矩阵
```
**输出描述**
```
输出 字典序 最小密文.如果无法匹配，输出"error
```
**示例1：**
```
输入：
2
0 3
3
0 0 2
1 3 4
6 6 4
输出：
0 1 1 1
```
**示例2：**
```
输入：
2
0 5
3
0 0 2
1 3 4
6 6 4
输出：
error
```
**代码**
```python
class Solution:

    def solve(self, n, mingwen, m, miwen):
        ans = []

        def dfs(x, y, path, mingwen):
            if not mingwen:
                ans.append(path[:])
                return

            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < m and miwen[nx][ny] == mingwen[0]:
                    dfs(nx, ny, path+[nx, ny], mingwen[1:])


        for i in range(m):
            for j in range(m):
                if miwen[i][j] == mingwen[0]:
                    dfs(i, j, [i, j], mingwen[1:])
        ans.sort()
        return ans[0] if ans else 'error'


s = Solution()
print(s.solve(2, [0,3], 3, [[0,0,2],[3,3,4],[0,3,4]]))
```

38. 田忌赛马 回溯
**题目描述**
给定两个只包含数字的数组a，b，调整数组 a 里面的数字的顺序，使得尽可能多的a[i] > b[i]。
数组a和b中的数字各不相同。
输出所有可以达到最优结果的a数组的结果。
**输入描述**
输入的第一行是数组 a 中的数字，其中只包含数字，每两个数字之间相隔一个空格，a数组大小不超过10。
输入的第二行是数组 b 中的数字，其中只包含数字，每两个数字之间相隔一个空格，b数组大小不超过10。
**输出描述**
输出所有可以达到最优结果的 a 数组的数量。
**用例**
输入 11 8 20
10 13 7
输出 1
说明 最优结果只有一个，a = [11, 20, 8]，故输出1
输入 11 12 20
10 13 7
输出 2
说明 有两个a数组的排列可以达到最优结果，[12, 20, 11] 和 [11, 20,
12]，故输出2
输入 1 2 3
4 5 6
输出 6
说明 a无论如何都会全输，故a任意排列都行，输出所有a数组的排
列，6种排法。
**
```python
class Solution:

    def solve(self, la, lb):
        la.sort()
        max_bigger_cnt = 0
        res = 0
        used = [False] * len(la)

        def dfs(k, bigger):
            nonlocal max_bigger_cnt
            nonlocal res
            if k >= len(lb):
                if bigger > max_bigger_cnt:
                    max_bigger_cnt = bigger
                    res = 1
                elif bigger == max_bigger_cnt:
                    res += 1
                return

            for i in range(len(la)):
                if used[i]:
                    continue
                if i > 0 and la[i-1] == la[i] and not used[i-1]:
                    continue
                used[i] = True
                dfs(k+1, bigger + (1 if la[i] > lb[k] else 0))
                used[i] = False

        dfs(0, 0)
        return res

s = Solution()
print(s.solve([1,2,3],[4,5,6]))
```

39. 每个元音包含偶数次的最长子字符串
**题目描述**
```
给你一个 字符串 s ，请你返回满足以下条件的最长 子字符串 的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。
```
**示例**
```
示例 1
输入：s = "eleetminicoworoep"
输出：13
解释：最长子字符串是 "leetminicowor" ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。
示例 2
输入：s = "leetcodeisgreat"
输出：5
解释：最长子字符串是 "leetc" ，其中包含 2 个 e 。
示例 3
输入：s = "bcbcbc"
输出：6
解释：这个示例中，字符串 "bcbcbc" 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。
提示
1 <= s.length <= 5 x 10^5
s 只包含小写英文字母。
```
**题目解析**
```
本题最简单的思路就是双循环暴力枚举所有子串，然后计算子串内各个元音的数目。
但是这种思路肯定会超时。
我们枚举子串的目的，是为了统计子串中各元音字符的数量，而实现该需求的更优思路是利用前缀和。
前缀和的应用场景有非常鲜明的特点，如求解连续范围内的状态，实际例子有：求解任意区间的和。
本题其实也可以当成前缀和问题来看，我们遍历输入串，每遍历一个字符，则对应位置 i 就有一个前缀状态 preSum[i]，本题preSum[i] 表示 [0, i] 范围
音字符的数量，具体表现为：
preSum[i] = {
 ‘a’：aCount，
 'e'：eCount，
  'i'：iCount，
 'o'：oCount，
 'u'：uCount
}
那么，如果我们要求解范围[i, j]子串的各个元音的数量，即可通过 preSum[j] - preSum[i-1] 得到。
更多前缀和知识请看：算法设计 - 前缀和 & 差分数列_算法设计 - 前缀和 & 差分数列_伏城之外的博客-csdn博客-CSDN博客
但是光靠前缀和，我们还是要枚举所有子串，依旧会超时。
本题要求我们求解最长的子串，子串范围内各个元音数量为偶数。我们假设：
preSum[j] 位置各个元音的数量分别为：aCount偶数，eCount奇数，iCount偶数，oCount偶数，uCount奇数
再假设 [i, j] 范围内各个元音的数量都为偶数，那么此时preSum[i-1]的各个元音的数量应该是多少呢？
答：必然和preSum[j] 对应元音的数量同奇偶性。因为：
奇数 - 奇数 = 偶数
偶数 - 偶数 = 偶数
比如 preSum[j] = {aCount: 8, eCount: 3, iCount: 6, oCount: 4, uCount: 5}；
且 preSum[i-1] = {aCount: 2, eCount: 1, iCount: 4, oCount: 2, uCount: 3}；
那么 [i, j] 范围内，各个元音的数量为：
aCount = 8 - 2 = 6
eCount = 3 - 1 = 2
iCount = 6 - 4 = 2
oCount = 4 - 2 = 2
uCount = 5 - 3 = 2
因此，当我们得到 preSum[j] 后，我们应该在 i - 1 ∈ [0, j - 1] 范围内找到一个 preSum[i-1] 和 preSum[j] 的各个元音同奇偶性的，且 i - 1要最小，这样得
子串才是 [0, j] 范围内一个最长的且各个元音数量都为偶数的子串。
此时，逻辑虽然得到了优化，但是我们依旧要遍历 0 ~ j - 1 范围内的位置 i，且需要对比对应 preSum[i] 和 preSum[j] 的各个元音的奇偶性，这样依然会
接下来要用到状态压缩了。
由于我们只关注各个元音的数量的奇偶性，即每个元音的数量要么为奇数，要么为偶数，假设我们用0表示偶数，用1表示奇数的话。
那么初始 preSum[0] 的各个元音的状态就可以表示为二进制数：00000
各个二进制位和对应元音对应，如上图所示，当二进制位值为0时，表示对应元音数量为偶数个，当二进制位值为1时，表示对应元音数量为奇数个。
这样我们就完成了 preSum[i] 的状态压缩。
那么状态压缩后的preSum[j] 和 preSum[j+1] 如何进行前缀和累进呢？
假设 j+1 位置的字符是 'e'，那么代表，preSum[j] 的二进制数 中 'e' 对应的位的性质反转，即奇变偶，偶变奇。
比如 preSum[j] = 01010，而 s[j+1] 字符是 'e'，则 preSum[j+1] = 00010
此时我们完全可以用异或运算从preSum[j]得出preSum[j+1]
preSum[j + 1] = preSum[j] ^ 01000
其中 01000 代表是新增一个'e'字符，同理
10000 代表新增一个 'a' 字符
01000 代表新增一个 'e' 字符
00100 代表新增一个 'i' 字符
00010 代表新增一个 'o' 字符
00001 代表新增一个 'u' 字符
接下来就是，比较preSum[i] 和 preSum[j] 的各个元音的奇偶性是否一致，就可以直接将对应二进制数进行值比较即可，值相同，则奇偶性一致，否则不
比如：preSum[i-1] = 01010，preSum[j] = 01010，那么二者的各个元音的奇偶性就一致。
当我们完成preSum[i]的状态压缩后，我们就可以定义一个哈希表map来记录某个压缩状态最早出现的位置，map的key时压缩状态，val时该压缩状态的
置。
即：我们求解[0, j]范围前缀子串的压缩状态status = preSum[j]后：
如果map存在key=status，那么status状态最早出现位置为 map[staus]，我们定义 i = map[status]，那么i，j位置的前缀子串内部的各个元音的数量是
的，即 [i+1, j] 范围内子串的各个元音的数量B必然都是偶数，[i+1, j] 范围子串是一个符合要求的子串，我们需要记录该子串的长度 j - (i + 1) + 1 = j 
如果 map 不存在 key == status，那么status状态最早出现的位置就是 j，我们需要记录 map[status] = j
按照逻辑，我们只要遍历一遍字符串s，即可找到最长的目标子串。
```
**代码**
```python
class Solution(object):
    def findTheLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        # "前缀子串"中各个元音的奇偶状态
        # 00000
        # aeiou
        # 元音字母和二进制位的对应关系如上，如果二进制位值位0，代表对应元音字符数量有偶数个，如果二进制位值为1，代表对应元音字符数量有奇数个
        # 初始未遍历时，没有子串，此时各个元音的数量都为0，即偶数个，因此所有二进制位值位0
        status = 0b00000
 
        # map记录某个状态的最早出现位置, -2是一个不可能的位置, 即初始时各个状态都没有出现过
        # 压缩状态用五位二进制数表示，因此最多有32种状态
        map = [-2] * 32
        # 00000 状态对应的十进制数为0，最早出现位置是-1，即未遍历，没有子串时
        map[0] = -1
 
        # 记录最长的符合要求的子串长度
        maxLen = 0
 
        for i in range(len(s)):
            c = s[i]
 
            # 如果遍历的字符s[i]是元音字母，则变更对应二进制位的奇偶性
            if c == 'a':
                status ^= 0b10000
            elif c == 'e':
                status ^= 0b01000
            elif c == 'i':
                status ^= 0b00100
            elif c == 'o':
                status ^= 0b00010
            elif c == 'u':
                status ^= 0b00001
 
            # 如果对应状态的最早出现位置为-2，表示没有出现过对应状态，否则map[status]即status状态最早出现的位置
            if map[status] != -2:
                # 当前位置 i 的状态为status，而最早出现status状态的位置是 map[status]，两个位置同奇偶性，因此他们形成的范围内子串是符合要求的
                maxLen = max(maxLen, i - map[status])
            else:
                # 如果对应状态之前未出现过，则当前位置 i 就是该状态的最早出现位置
                map[status] = i
 
        return maxLen
```

40. 最长子字符串的长度 
**题目描述**
```
给你一个字符串 s，字符串 s 首尾相连成一个环形，请你在环中找出 'l'、'o'、'x' 字符都恰好出现了偶数次最长 子字符串 的长度。
```
**输入描述**
```
输入是一串小写的字母组成的字符串
```
**输出描述**
```
输出是一个整数
备注
1 ≤ s.length ≤ 5 * 10^5
s 只包含小写英文字母
```
**用例**
```
输入 alolobo
输出 6
说明 最长子字符串之一是 "alolob"，它包含 'l'，'o' 各2个，以及 0 个
'x'。
输入 looxdolx
输出 7
说明
最长的子字符串是"oxdolxl"，由于是首尾连接在一起的，所以最
后一个 'x' 和开头的 'l' 是连接在一起的，此字符串包含 2 个 'l'，2
个'o'，2个'x'
输入 bcbcbc
输出 6
说明 这个示例中，字符串 "bcbcbc" 本身就是最长的，因为 'l'、'o'、'x'
都出现了 0 次。
```
**题目解析**
```
本题其实就是
LeetCode - 1371 每个元音包含偶数次的最长子字符串（Java & JS & Python & C）-CSDN博客
的变形体。
看本题前需要先把上面题目搞懂，否则本题解法看不懂。
本题与上面题目的区别在于，本题的主串s是环，即当遍历到s串尾部时，可以继续环动到s串头部
本题如果继续按照前面 leetcode 那题的思路解题，则会发现使用哈希表时，不能只单单记录某个状态的最早出现位置。
而是需要记录某个状态的出现的所有位置（需要按照先后顺序依次记录）。
因为，本题随着绕环运动，黑色部分会逐渐侵蚀掉一些位置，而这些被侵蚀的位置，可能就是某个状态最早出现的位置，当该位置被侵蚀后，我们需要
状态到新的最早出现位置。
如果使用队列记录某个状态出现的所有位置（按照先后顺序依次记录），那么队列头部记录的就是该状态的最早出现位置，如果该位置被侵蚀，那
弹出队头，使用新的队头元素作为对应状态的最早出现位置。
```
**代码**
```python
class Solution:

    def solve(self, strs):
        status = 0b000
        dic = [[] for _ in range(8)]
        dic[0].append(-1)
        maxlen = 0
        for i in range(len(2*strs)):
            c = strs[i % len(strs)]
            if c == 'l':
                status ^= 0b100
            elif c == 'o':
                status ^= 0b010
            elif c == 'x':
                status ^= 0b001

            if i < len(strs):
                dic[status].append(i)

            while len(dic[status]) > 0:
                earliest = dic[status][0]
                if i - earliest > len(strs):
                    dic[status].pop(0)
                else:
                    maxlen = max(maxlen, i-earliest)
                    break
        return maxlen


s = Solution()
print(s.solve('looxdolx'))
```

41. 运输时间 逻辑分析
**题目描述**
```
M（1 ≤ M ≤ 20）辆车需要在一条不能超车的单行道到达终点，起点到终点的距离为 N（1 ≤ N ≤ 400）。
速度快的车追上前车后，只能以前车的速度继续行驶，求最后一辆车到达目的地花费的时间。
注：每辆车固定间隔 1 小时出发，比如第一辆车 0 时出发，第二辆车 1 时出发，依次类推
```
**输入描述**
```
第一行两个数字：M N，分别代表 车辆数 和到终点的距离，以空格分隔
接下来 M 行，每行一个数字 S，代表每辆车的速度。0 < S < 30
```
**输出描述**
```
最后一辆车到达目的地花费的时间
```
**用例**
```
输入
2 11
3
2
输出 5.5
说明 2辆车，距离11，0时出发的车速度快，1时出发的车，到达目的
地花费5.5
```
**题目解析**
```
本题需要注意的是：速度快的车追上前车后，是可以和前车并行的。即本题的：
一条不能超车的单行道
指的应该是"单向"车道，即可能有多条 单向车道 ，支持多辆车并行。
因此本题的解题就很简单了，由于后车不能超过前车，因此：
如果后车正常行驶情况下，比前车更早到达，则会被前车阻碍，此时后车到达终点时刻，和前车一致
如果后车正常行驶情况下，比前车更晚到达，则不会被前车阻碍，此时后车到达终点时刻，就是自己正常行驶到达终点的时刻
本题要求输出的是：到达目的地花费的时间 = 到达时刻 - 出发时刻
```
**代码**
```python
# 输入获取
m, n = map(int, input().split())
 
# 记录前车到达终点的时刻，本题后车不可能比前车更早到达，因此如果后车到达时刻 < 前车到达时刻arrived，则后车也是按照前车arrived时刻达到
arrived = 0
 
for i in range(m):
    # 当前车的速度
    speed = int(input())
    # 当前车到达终点的时刻
    # * 当前车如果比前车更早到达，则被前车阻碍，按前车到达时间算
    # * 当前车如果比前车更晚到达，则不被前车阻碍，按后车到达时间算
    arrived = max(arrived, n / speed + i)  # n*1.0/speed是行驶花费时间； i是第i辆车的出发时间
 
# 到达时刻 - 出发时刻 = 路上花费的时间
cost = arrived - (m - 1)
 
print(cost)  # 实际考试没有精度问题，可以直接输出cost，可以满分
# print("{:g}".format(round(cost, 3)))  # 我这边OJ用例设计时有小数位则至多保留3位，:g 用于去除无效小数位
```

42.  智能驾驶 BFS
**题目**
```
有一辆汽车需要从 m*n 的地图的左上角(起点)开往地图的右下角(终点)，去往每一个地区都需要消耗一定的油量，加油站可进行加油
请你计算汽车确保从起点到达终点时所需的最少初始油量说明:
(1) 智能汽车 可以上下左右四个方向移动1
(2) 地图上的数字取值是 0或-1 或者正整数:
1: 表示加油站，可以加满油，汽车的油箱容量最大为 100;
0: 表示这个地区是障碍物，汽车不能通过
正整数: 表示汽车走过这个地区的耗油量
(3) 如果汽车无论如何都无法到达终点，则返回 -1
```
**输入描述**
```
第一行为两个数字，M，V，表示地图的大小为 M,N(0< M,N < 200)
后面一个M*N 的矩阵，其中的值是 0 或 -1 或正整数，加油站的总数不超过 200个
```
**输出描述**
```
如果汽车无论如何都无法到达终点，则返回-1
如果汽车可以到达终点，则返回最少的初始油量
```
**示例1**
```
输入
2,2
10 ,20
30,40
输出
70
```
**示例2**
```
输入
4,4
10,30,30,20
30,30,-1,10
0,20,20,40
10,-1,30,40
输出
70
```
**示例3**
```
输入
4,5
10,0,30,-1,10
30,0,20,0,20
10,0,10,0,30
10,-1,30,0,10
输出
60
```
**示例4**
```
输入
4,4
10,30,30,20
30,30,20,10
10,20,10,40
10,20,30,40
输出
-1
```
**思路**
```
1：经典的 BFS 、DFS类题目，C卷里出过很多次了。
2：这个题目唯一有点特点的地方就是可以加油，我们用一个变量来保存汽车的油量即可。
```
**代码**
```python
import sys
 
# 输入获取
m, n = map(int, input().split(","))
matrix = [list(map(int, input().split(","))) for _ in range(m)]
 
# 上下左右四个方向对应的偏移量
offsets = ((-1, 0), (1, 0), (0, -1), (0, 1))
 
 
# 记录路径中位置的几个状态
class Node:
    def __init__(self, x, y):
        self.x = x  # 位置横坐标
        self.y = y  # 位置纵坐标
        self.init = 0  # 到达此位置所需的最少初始油量
        self.remain = 0  # 到达此位置时剩余可用油量
        self.flag = False  # 到达此位置前有没有加过油
 
 
# 算法入口
def bfs():
    # 如果左上角和右下角不可达，则直接返回-1
    if matrix[0][0] == 0 or matrix[m - 1][n - 1] == 0:
        return -1
 
    # 广搜队列
    queue = []
 
    # 起始位置
    src = Node(0, 0)
 
    if matrix[0][0] == -1:
        # 如果起始位置就是加油站，则到达(0,0)位置所需初始油量为0，且剩余可用油量为100，且需要标记已加油
        src.init = 0
        src.remain = 100
        src.flag = True
    else:
        # 如果起始位置不是加油站，则到达(0,0)位置所需的初始油量至少为matrix[0][0], 剩余可用油量为0，未加油状态
        src.init = matrix[0][0]
        src.remain = 0
        src.flag = False
 
    queue.append(src)
 
    # dist_init[x][y] 用于记录起点 (0, 0) 到达 (x, y) 的所有可达路径中最优路径（即初始油量需求最少的路径）的初始油量
    # 由于需要记录每个位置的最少需要的初始油量，因此每个位置所需的初始油量初始化为一个较大值
    dist_init = [[sys.maxsize] * n for _ in range(m)]
 
    # dist_remain 用于记录起点 (0,0) 到达 (x,y) 的所有可达路径中最优路径（即初始油量需求最少的路径）的最大剩余可用油量
    # 即如果存在多条最优路径，我们应该选这些路径中到达此位置剩余油量最多的
    dist_remain = [[0] * n for _ in range(m)]
 
    # 起点（0,0）到达自身位置（0,0）所需的最少初始油量和最多剩余油量
    dist_init[0][0] = src.init
    dist_remain[0][0] = src.remain
 
    # 广搜
    while len(queue) > 0:
        cur = queue.pop(0)
 
        # 从当前位置cur开始向上下左右四个方向探路
        for offsetX, offsetY in offsets:
            # 新位置
            newX = cur.x + offsetX
            newY = cur.y + offsetY
 
            # 新位置越界 或者 新位置是障碍，则新位置不可达，继续探索其他方向
            if newX < 0 or newX >= m or newY < 0 or newY >= n or matrix[newX][newY] == 0:
                continue
 
            # 如果新位置可达，则计算到达新位置的三个状态数据
            init = cur.init  # 到达新位置所需的最少初始油量
            remain = cur.remain  # 到达新位置时还剩余的最多可用油量
            flag = cur.flag  # 是否加油了
 
            if matrix[newX][newY] == -1:
                # 如果新位置是加油站，则加满油
                remain = 100
                # 标记加过油了
                flag = True
            else:
                # 如果新位置不是加油站，则需要消耗matrix[newX][newY]个油
                remain -= matrix[newX][newY]
 
            # 如果到达新位置后，剩余油量为负数
            if remain < 0:
                if flag:
                    # 如果之前已经加过油了，则说明到达此路径前是满油状态，因此我们无法从初始油量里面"借"油
                    continue
                else:
                    # 如果之前没有加过油，则超出的油量（-remain），可以从初始油量里面"借"，即需要初始油量 init + (-remain) 才能到达新位置
                    init -= remain
                    # 由于初始油量 init + (-remain) 刚好只能支持汽车到达新位置，因此汽车到达新位置后剩余可用油量为0
                    remain = 0
 
            # 如果到达新位置所需的初始油量超过了满油100，则无法到达新位置
            if init > 100:
                continue
 
            # 如果可达新位置，则继续检查当前路径策略到达新位置(newX, newY)所需的初始油量init是否比其他路径策略更少
            if init > dist_init[newX][newY]:
                # 如果不是，则无需探索新位置(newX, newY)
                continue
 
            # 当前路径策略到达新位置(newX,newY)所需初始油量init更少，或者，init和前面路径策略相同，但是当前路径策略剩余可用油量remain更多
            if init < dist_init[newX][newY] or remain > dist_remain[newX][newY]:
                # 则当前路径策略更优，记录更优路径的状态
                dist_init[newX][newY] = init
                dist_remain[newX][newY] = remain
 
                # 将当前新位置加入BFS队列
                nxt = Node(newX, newY)
                nxt.init = init
                nxt.remain = remain
                nxt.flag = flag
 
                queue.append(nxt)
 
    # dist_init[m - 1][n - 1] 记录的是到达右下角终点位置所需的最少初始油量
    if dist_init[m - 1][n - 1] == sys.maxsize:
        return -1
    else:
        return dist_init[m - 1][n - 1]
 
 
# 算法调用
print(bfs())
```

43.  查找一个有向网络的头节点和尾节点 拓扑排序
**题目描述**
```
给定一个 有向图 ，图中可能包含有环，图使用二维矩阵表示，每一行的第一列表示起始节点，第二列表示终止节点，如 [0, 1] 表示从 0 到 1 的路径
每个节点用正 整数表示 。
求这个数据的首节点与尾节点，题目给的用例会是一个首节点，但可能存在多个尾节点。同时图中可能含有环。如果图中含有环，返回 [-1]。
说明：入度为0是首节点，出度为0是尾节点。
```
**输入描述**
```
第一行为后续输入的 键值对 数量N（N ≥ 0）
第二行为2N个数字。每两个为一个起点，一个终点，如：
```
**输出描述**
```
输出一行头节点和尾节点。如果有多个尾节点，按从大到小的顺序输出。
备注
如果图有环，输出为 -1
所有输入均合法，不会出现不配对的数据
```
**用例**
```
输入 4
0 1 0 2 1 2 2 3
输出 0 3
说明 无
输入 2
0 1 0 2
输出 0 1 2
说明 无
```
**解析**
```
本题可以通过拓扑排序解题。
关于拓扑排序的知识，大家如果不知道的话，可以先看下：LeetCode - 207 课程表（Java & JS & Python & C）_leetcode207课程表-CSDN博客
了解拓扑排序后，我们就可以按照拓扑排序的思路不停剥离图中入度为0的点，每当剥离一个入度为0的点A，我们都需要做如下判断：
A点如果没有后继点，则说明A点的出度为0，因此A点为尾节点
A点如果有后继点，则A点的所有后继点的入度-1，如果后继点中-1后出现新的入度为0的节点，则加入度0点的队列，等待下次剥离
在上面过程中，我们需要统计被剥离点的个数，使用count表示，如果图中节点总数为total，那么当拓扑排序完成后，count < total 的话，则说明图中存在环
```
**代码**
```python
# 算法入口
def getResult():
    # 输入获取
    n = int(input())
 
    if n == 0:
        print(-1)
        return 
 
    tmp = list(map(int, input().split()))
 
    # 记录每个点的入度
    inDegree = {}
    # 记录每个点的后继点集合
    nxt = {}
 
    # 记录图中点
    points = set()
 
    for i in range(0, 2 * n, 2):
        # 从 a 到 b 的路径
        a = tmp[i]
        b = tmp[i + 1]
 
        # 收集图中所有节点
        points.add(a)
        points.add(b)
 
        # b点入度+1
        inDegree.setdefault(b, 0)
        inDegree[b] += 1
 
        # a点的后继点集合纳入b
        nxt.setdefault(a, [])
        nxt[a].append(b)
 
    # 图中总共total个节点
    total = len(points)
 
    # head记录图的头节点
    head = 0
    # 队列记录入度为0的点
    queue = []
 
    for p in points:
        # 题目描述中说图中只有一个首节点，首节点是入度为0的节点，因此如果某节点p没有入度，则为头节点
        if p not in inDegree:
            head = p
            queue.append(p)
            break
 
    # tails记录所有尾节点
    tails = []
 
    # count记录已被剥去的点个数，如果图中存在环，则必然最终count < total
    count = 0
 
    while len(queue) > 0:
        # 剥离入度为0的点
        fa = queue.pop(0)
        count += 1
 
        # 如果fa没有后继点，即fa没有出度，则fa是尾节点
        if fa not in nxt:
            tails.append(fa)
            continue
 
        # 如果fa有后继点，则其所有后继点入度-1
        for ch in nxt[fa]:
            inDegree[ch] -= 1
 
            # 如果ch点入度变为0，则加入队列
            if inDegree[ch] == 0:
                queue.append(ch)
 
    if count != total:
        # 如果存在环，则必然count < total
        print(-1)
    else:
        # 如果不存在环，则打印头节点和尾节点
        # 注意本题描述存在冲突（用例2输出的尾节点是从小到大排序的，而题目输出描述是要求尾节点从大到小排序），这里以用例为准
        tails.sort()
        print(head, " ".join(map(str, tails)))
 
 
# 算法调用
getResult()
```

44.  快递员的烦恼 floyd+全排列
**题目描述**
```
快递公司每日早晨，给每位快递员推送需要送到客户手中的快递以及路线信息，快递员自己又查找了一些客户与客户之间的路线距离信息，请你依据这
给快递员设计一条 最短路径 ，告诉他最短路径的距离。
注意：
不限制快递包裹送到客户手中的顺序，但必须保证都送到客户手中
用例保证一定存在投递站到每位客户之间的路线，但不保证客户与客户之间有路线，客户位置及投递站均允许多次经过
所有快递送完后，快递员需回到投递站
```
**输入描述**
```
首行输入两个正整数n、m
接下来 n 行，输入快递公司发布的客户快递信息，格式为：
客户id 投递站到客户之间的距离distance
再接下俩的 m 行，是快递员自行查找的客户与客户之间的距离信息，格式为
客户id1 客户id2 distance
在每行数据中，数据与数据之间均以单个空格分隔
规格：
0 < n ≤ 10
0 ≤ m ≤ 10
0 < 客户id ≤ 1000
0 < distance ≤ 10000
```
**输出描述**
```
最短路径距离，如无法找到，请输出-1
```
**用例**
```
输入
2 1
1 1000
2 1200
1 2 300
输出 2500
输入
5 1
5 1000
9 1200
17 300
132 700
500 2300
5 9 400
输出 9200
说明 在所有可行的路径中，最短路径长度为 1000 + 400 + 1200 +
300 + 300 + 700 + 700 + 2300 + 2300 = 9200
```
**代码**
```python
import sys
 
# 输入获取
n, m = map(int, input().split())
 
# floyd算法需要基于dist和path矩阵求解
# dist[i][j] 用于记录点 i->j 的最短距离，初始时等价于邻接矩阵
dist = [[sys.maxsize] * (n + 1) for _ in range(n + 1)]
# path[i][j] 用于记录点 i->j 最短距离情况下需要经过的中转点，初始时默认任意两点间无中转点，即默认path[i][j] = -1
path = [[-1] * (n + 1) for _ in range(n + 1)]
 
# 由于本题的客户id不是顺序的，因此这里需要将客户id离散化处理
dic = {}
 
for i in range(1, n + 1):
    idx, dis = map(int, input().split())
 
    # 离散化处理
    dic[idx] = i
 
    # 投递站到客户之间的距离distance
    dist[0][i] = dis
    dist[i][0] = dis
 
for i in range(1, m + 1):
    idx1, idx2, dis = map(int, input().split())
 
    i1 = dic[idx1]
    i2 = dic[idx2]
 
    # 客户与客户之间的距离信息
    dist[i1][i2] = dis
    dist[i2][i1] = dis
 
# ans记录经过所有点后回到出发点的最短距离
ans = sys.maxsize
 
 
# floyd算法求解图中任意两点之间的最短路径
def floyd():
    for k in range(n + 1):
        for i in range(n + 1):
            for j in range(n + 1):
                # newDist是经过k后，i->j的距离
                newDist = dist[i][k] + dist[k][j]
                # 如果newDist是i->j的更短路径
                if newDist < dist[i][j]:
                    # 则更新i->j的最短距离
                    dist[i][j] = newDist
                    # 且此更短距离需要经过k, path[i][j]即记录 i->j 最短距离下需要经过点 k
                    path[i][j] = k
 
 
def dfs(pre, sumDis, used, level):
    """
    找一条经过所有点的最短路径，我们可以求解所有点形成的全排列，每一个全排列都对应一条经过所有点的路径，只是经过点的先后顺序不同 //
    求某个全排列过程中，可以通过dist数组，累计上一个点i到下一个点j的最短路径dist[i][j]
    :param pre: 上一个点, 初始为0，表示从披萨店出发
    :param sumDis: 当前全排列路径累计的路径权重
    :param used: 全排列used数组，用于标记哪些点已使用过
    :param level: 用于记录排列的长度
    """
    global ans
 
    if level == n:
        # 此时pre是最后一个客户所在点，送完最后一个客户后，司机需要回到披萨店，因此最终累计路径权重为 sum + dist[pre][0]
        # 我们保留最小权重路径
        ans = min(ans, sumDis + dist[pre][0])
        return
 
    for i in range(1, n + 1):
        if used[i]:
            continue
 
        used[i] = True
        dfs(i, sumDis + dist[pre][i], used, level + 1)
        used[i] = False
 
 
# 算法入口
def main():
    # floyd算法调用
    floyd()
 
    # 全排列模拟经过所有点的路径
    dfs(0, 0, [False] * (n + 1), 0)
 
    print(ans)
 
 
# 算法调用
main()
```

45.  考古学家 全排列
**题目描述**
```
有一个考古学家发现一个石碑，但是很可惜，发现时其已经断成多段，原地发现n个断口整齐的石碑碎片。
为了破解石碑内容，考古学家希望有程序能帮忙计算复原后的石碑文字 组合数 ，你能帮忙吗？
```
**输入描述**
```
第一行输入 n
n表示石碑碎片的个数
第二行依次输入石碑碎片上的文字内容s，共有n组。
```
**输出描述**
```
输出石碑文字的组合（按照 升序排列 ），行末无多余空格。
备注
如果存在石碑碎片内容完全相同，则由于碎片间的顺序变换不影响复原后的碑文内容，即相同碎片间的位置变换不影响组合。
```
**用例**
```
输入 3
a b c
输出
abc
acb
bac
bca
cab
cba
说明 当石碑碎片上的内容为“a”，“b”，“c”时，则组合有“abc”，“acb”，
“bac”，“bca”，“cab”，“cba”
输入 3
a b a
输出
aab
aba
baa
说明 当石碑碎片上的内容为“a”，“b”，“a”时，则可能的组合有“aab”，
“aba”，“baa”
输入 3
a b ab
输出
aabb
abab
abba
baab
baba
```
**代码**
```python
class Solution:

    def solve(self, n, pieces):
        ans = set()
        used = [False] * n

        def dfs(path, k):
            nonlocal ans
            if k == n:
                ans.add(''.join(path))
                return
            for i in range(n):
                if used[i]:
                    continue
                if i > 1 and pieces[i] == pieces[i-1] and not used[i-1]:
                    continue
                used[i] = True
                dfs(path+[pieces[i]], k+1)
                used[i] = False

        pieces.sort()
        dfs([], 0)
        return ans

s = Solution()
print(s.solve(3, ['a', 'b', 'ab']))
```

46.  最大社交距离 逻辑分析
**题目描述**
```
疫情期间需要大家保证一定的 社交距离 ，公司组织开交流会议。
座位一排共 N 个座位，编号分别为 [0, N - 1] 。
要求员工一个接着一个进入会议室，并且可以在任何时候离开会议室。
满足：
每当一个员工进入时，需要坐到最大社交距离（最大化自己和其他人的距离的座位）；
如果有多个这样的座位，则坐到索引最小的那个座位。
```
**输入描述**
```
会议室座位 总数 seatNum
1 ≤ seatNum ≤ 500
员工的进出顺序 seatOrLeave 数组
元素值为 1，表示进场
元素值为负数，表示出场（特殊：位置 0 的员工不会离开）
例如 -4 表示坐在位置 4 的员工离开（保证有员工坐在该座位上）
```
**输出描述**
```
最后进来员工，他会坐在第几个位置，如果位置已满，则输出-1。
```
**用例**
```
输入 10
[1, 1, 1, 1, -4, 1]
输出 5
说明
seat -> 0,空在任何位置都行，但是要给他安排索引最小的位置，也就是座位 0
seat -> 9,要和旁边的人距离最远，也就是座位 9
seat -> 4,要和旁边的人距离最远，应该坐到中间，也就是座位 4
seat -> 2,员工最后坐在 2 号座位上
leave[4], 4 号座位的员工离开
seat -> 5,员工最后坐在 5 号座位上
```
**代码**
```python
# 输入获取
seatNum = int(input())
seatOrLeave = eval(input())
 
 
# 算法入口
def getResult():
    # 记录已经坐人位置的序号
    seatIdx = []
 
    # 记录题解
    lastSeatIdx = -1
 
    # 遍历员工的进出顺序
    for info in seatOrLeave:
        # 如果当前元素值为负数，表示出场（特殊：位置 0 的员工不会离开）
        # 例如 -4 表示坐在位置 4 的员工离开（保证有员工坐在该座位上）
        if info < 0:
            leaveIdx = -info
            seatIdx.remove(leaveIdx)
            continue
 
        # 如果当前元素值为 1，表示进场
        # 如果没有空闲位置，则坐不下
        if len(seatIdx) == seatNum:
            lastSeatIdx = -1
            continue
 
        if len(seatIdx) == 0:
            # 当前人员进场前，座位上没有人，则当前人员是第一个进场的，直接坐第0个位置
            seatIdx.append(0)
            lastSeatIdx = 0
        elif len(seatIdx) == 1:
            # 当前人员进场前，座位上只有一个人，那么这个人肯定坐在第0个位置，则当前进场的人坐在 seatNum - 1 位置才能离 0 位置最远
            seatIdx.append(seatNum - 1)
            lastSeatIdx = seatNum - 1
        else:
            # 记录具有最大社交距离的座位号
            bestSeatIdx = -1
            # 记录最大社交距离
            bestSeatDis = -1
 
            # 找到连续空闲座位区域（该区域左、右边界是坐了人的座位）
 
            left = seatIdx[0]  # 左边界
            for i in range(1, len(seatIdx)):
                right = seatIdx[i]  # 右边界
 
                # 连续空闲座位区域的长度
                dis = right - left - 1
 
                # 如果连续空闲座位区域长度为0，则无法坐人，此时遍历下一个连续空闲座位区域
                # 如果连续空闲座位区域长度大于0，则可以坐人
                if dis > 0:
                    # 当前空闲区域能产生的最大社交距离
                    curSeatDis = dis // 2 - (1 if dis % 2 == 0 else 0)
                    # 当前空闲区域中具备最大社交距离的位置
                    curSeatIdx = left + curSeatDis + 1
 
                    # 保留最优解
                    if curSeatDis > bestSeatDis:
                        bestSeatDis = curSeatDis
                        bestSeatIdx = curSeatIdx
 
                left = right
 
            # 如果最后一个座位，即第 seatNum - 1 号座位没有坐人的话，比如 1 0 0 0 1 0 0 0 0，此时最后一段空闲区域是没有右边界的，需要特殊处理
            if seatIdx[-1] < seatNum - 1:
                # 此时可以直接坐到第 seatNum - 1 号座位，最大社交距离为 curSeatDis
                curSeatDis = seatNum - 1 - seatIdx[-1] - 1
                curSeatIdx = seatNum - 1
 
                # 保留最优解
                if curSeatDis > bestSeatDis:
                    bestSeatIdx = curSeatIdx
 
            # 如果能坐人，则将坐的位置加入seatIdx中
            if bestSeatIdx > 0:
                seatIdx.append(bestSeatIdx)
                seatIdx.sort()
 
            # 假设当前人就是最后一个人，那么无论当前人是否能坐进去，都更新lastSeatIdx = bestSeatIdx
            lastSeatIdx = bestSeatIdx
 
    return lastSeatIdx
 
 
# 算法调用
print(getResult())
```

47.  信道分配 逻辑分析
**题目描述**
```
算法工程师 小明面对着这样一个问题 ，需要将通信用的信道分配给尽量多的用户:
信道的条件及分配规则如下:
1. 所有信道都有属性:”阶”。阶为 r的信道的容量为 2^r比特;
2. 所有用户需要传输的数据量都一样:D比特;
3. 一个用户可以分配多个信道，但每个信道只能分配给一个用户;
4. 只有当分配给一个用户的所有信道的容量和>=D，用户才能传输数据;
给出一组信道资源，最多可以为多少用户传输数据?
```
**输入描述**
```
第一行，一个数字 R。R为最大阶数。
0<=R<20
第二行，R+1个数字，用空格隔开。代表每种信道的数量 Ni。按照阶的值从小到大排列。
0<=i<=R,0<=Ni<1000.
第三行，一个数字 D。D为单个用户需要传输的数据量。
0<D<1000000
```
**输出描述**
```
一个数字（代表最多可以供多少用户传输数据）
```
**用例**
```
输入
5
10 5 0 1 3 2
30
输出 4
说明 无
```
**代码**
```python
# 输入获取
R = int(input())
N = list(map(int, input().split()))
D = int(input())
 
 
def calc_sub(bin1):
    ans = 0
    for i in range(len(bin1)):
        ans += bin1[i] * (1 << i)
    return ans
 
 
def binary_sub(minuend, subtrahend):
    """
    二进制减法
    :param minuend: 被减数
    :param subtrahend: 减数
    :return: 被减数是否为正数
    """
    # 进行减法运算逻辑, 从高位开始
    i = len(minuend) - 1
    while i >= 0:
        if minuend[i] >= subtrahend[i]:
            # 如果对应位的信道数足够，则直接相减
            minuend[i] -= subtrahend[i]
        else:
            # 如果对应位的信道数不足，此时有两种策略，一是向低位借，一是向高位借
            # 具体向哪里借，需要看 minuend 的 [0,i] 低位部分是否能够承载 subtrahend[0, i] 低位部分
            if calc_sub(minuend[0:i + 1]) < calc_sub(subtrahend[0:i + 1]):
                # 如果minuend 的 [0,i]不能承载，则向高位借，即从j=i+1位开始借
                j = i + 1
                while j < len(minuend):
                    if minuend[j] > 0:
                        # 如果高位 j 有信道可借，则借
                        minuend[j] -= 1
                        return True
                    else:
                        # 否则继续向更高位探索
                        j += 1
                # 如果所有高位都没有富余信道数，则说明减法结果为负数
                return False
            else:
                # 如果minuend 的 [0,i]可以承载，则向低位借（可以避免浪费）
                # 此时minuend[i]为负数，表示欠债
                minuend[i] -= subtrahend[i]
 
                # 将当前阶位的欠债，转移到前面的低阶位上，注意转移时，欠债x2
                minuend[i - 1] += minuend[i] << 1
 
                # 转移后，当前阶位的欠债变为0
                minuend[i] = 0
 
        i -= 1
 
    return True
 
 
# 算法入口
def getResult():
    # 将D值转化为二进制形式，并且为了和N[]的阶位进行对应，这里将D的二进制进行了反转
    subtrahend = list(map(int, str(bin(D))[2:]))
    subtrahend.reverse()
 
    # count记录N能承载几个D
    count = 0
 
    # N中高阶信道的单个信道就能满足D，因此这些高阶信道有几个，即能承载几个D
    for i in range(len(subtrahend), R + 1):
        # R ~ subtrahend.length 阶的单个信道就能承载一个D，因此这些信道有几个，就能承载几个D
        count += N[i]
 
    # 0 ~ subtrahend.length - 1 阶的单个信道无法承载一个D，因此这些阶需要组合起来才能承载一个D
    minuend = N[0:len(subtrahend)]
    while len(minuend) < len(subtrahend):
        minuend.append(0)
 
    # 进行二进制减法
    while binary_sub(minuend, subtrahend):
        count += 1
 
    return count
 
 
# 算法调用
print(getResult())
```

48.  欢乐的周末 bfs
**题目描述**
```
小华和小为是很要好的朋友，他们约定周末一起吃饭。
通过手机交流，他们在地图上选择了多个聚餐地点（由于自然地形等原因，部分聚餐地点不可达），求小华和小为都能到达的聚餐地点有多少个？
```
**输入描述**
```
第一行输入 m 和 n
m 代表地图的长度
n 代表地图的宽度
第二行开始具体输入地图信息，地图信息包含：
0 为通畅的道路
1 为障碍物（且仅1为障碍物）
2 为小华或者小为，地图中必定有且仅有2个 （非障碍物）
3 为被选中的聚餐地点（非障碍物）
```
**输出描述**
```
可以被两方都到达的聚餐地点数量，行末无空格。
备注
地图的长宽为 m 和 n，其中：
4 ≤ m ≤ 100
4 ≤ n ≤ 100
聚餐的地点数量为 k，则
1< k ≤ 100
```
**用例**
```
输入
4 4
2 1 0 3
0 1 2 1
0 3 0 0
0 0 0 0
输出 2
说明
第一行输入地图的长宽为4和4。
第二行开始为具体的地图，其中：3代表小华和小明选择
的聚餐地点；2代表小华或者小明（确保有2个）；0代表
可以通行的位置；1代表不可以通行的位置。
此时两者能都能到达的聚餐位置有2处。
```
**解析**
```
广度优先遍历，先循环找出第一个2，从这个点开始遍历，最后统计遍历到3的次数，需要注意一点就是遍历完成后除去起点的2，必须还遍历到另一个2，这样才能保证两个人都能走到餐厅
```
**代码**
```python
class Solution:

    def solve(self, m, n, matrix):
        ans = 0

        def bfs(x, y):
            nonlocal ans
            queue = [(x, y)]
            vis = set()
            vis.add(x * n + y)
            flag = False
            while queue:
                cur = queue.pop(0)
                cur_x, cur_y = cur[0], cur[1]
                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nx, ny = cur_x + dx, cur_y + dy
                    pos = nx * n + ny
                    if nx < 0 or nx >= m or ny < 0 or ny >= n or matrix[nx][ny] == 1 or pos in vis:
                        continue
                    if matrix[nx][ny] == 2:
                        flag = True
                    elif matrix[nx][ny] == 3:
                        ans += 1
                    queue.append((nx, ny))
                    vis.add(pos)
            return flag

        for i in range(m):
            for j in range(n):
                if matrix[i][j] == 2:
                    if bfs(i, j):
                        return ans
                    else:
                        return 0


s = Solution()
print(s.solve(4,4,[[2,1,2,3],[0,1,0,0],[0,1,0,0],[0,1,0,0]]))
```

49. 二叉树的广度优先遍历 bfs

**题目描述**
```
有一棵二叉树，每个节点由一个大写字母标识(最多26个节点）。
现有两组字母，分别表示 后序遍历 （左孩子->右孩子->父节点）和中序遍历（左孩子->父节点->右孩子）的结果，请你输出层序遍历的结果。
```
**输入描述**
```
每个输入文件一行，第一个字符串表示后序遍历结果，第二个字符串表示 中序遍历 结果。（每串只包含大写字母）
中间用单空格分隔。
```
**输出描述**
```
输出仅一行，表示层序遍历的结果，结尾换行。
```
**用例**
```
输入 CBEFDA CBAEDF
输出 ABDCEF
说明
二叉树为：
  A
 / \
 B D
/ / \
C E F
```
**代码**
```python
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = right
        self.right = right



class Solution:

    def generate(self, postorder, inorder):
        if not postorder or not inorder:
            return
        root = Node(postorder[-1])
        index = inorder.index(postorder[-1])
        root.left = self.generate(postorder[:index], inorder[:index])
        root.right = self.generate(postorder[index:-1], inorder[index+1:])
        return root

    def solve(self, postorder, inorder):
        root = self.generate(postorder, inorder)
        res = []
        queue = [root]
        while queue:
            for _ in range(len(queue)):
                node = queue.pop(0)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                res.append(node.val)
        return ''.join(res)




s = Solution()
print(s.solve('CBEFDA', 'CBAEDF'))

```

50. 图像物体的边界 并查集

**题目描述**
```
给定一个 二维数组 M行N列，二维数组里的数字代表图片的像素，为了简化问题，仅包含像素1和5两种像素，每种像素代表一个物体，2个物体相邻
界，求像素1代表的物体的边界个数。
像素1代表的物体的边界指与像素5相邻的像素1的格子，边界相邻的属于同一个边界，相邻需要考虑8个方向（上，下，左，右，左上，左下，右上，
其他约束
地图规格约束为：
0<M<100
0<N<100
1）如下图，与像素5的格子相邻的像素1的格子（0,0）、（0,1）、（0,2）、（1,0）、（1,2）、（2,0）、（2,1）、（2,2）、（4,4）、（4,5）、
界，另（0,0）、（0,1）、（0,2）、（1,0）、（1,2）、（2,0）、（2,1）、（2,2）相邻，为1个边界，（4,4）、（4,5）、（5,4）相邻，为1个边界
边界个数为2。
2）如下图，与像素5的格子相邻的像素1的格子（0,0）、（0,1）、（0,2）、（1,0）、（1,2）、（2,0）、（2,1）、（2,2）、（3,3）、（3,4）、
（4,3）、（4,5）、（5,3）、（5,4）、（5,5）为边界，另这些边界相邻，所以下图边界个数为1。
注：（2,2）、（3,3）相邻。
```
**输入描述**
```
第一行，行数M，列数N
第二行开始，是M行N列的像素的二维数组，仅包含像素1和5
```
**输出描述**
```
像素1代表的物体的边界个数。
如果没有边界输出0（比如只存在像素1，或者只存在像素5）。
```
**用例**
```
输入
6 6
1 1 1 1 1 1
1 5 1 1 1 1
1 1 1 1 1 1
1 1 1 1 1 1
1 1 1 1 1 1
1 1 1 1 1 5
输出 2
说明 参考题目描述部分
输入
6 6
1 1 1 1 1 1
1 5 1 1 1 1
1 1 1 1 1 1
1 1 1 1 1 1
1 1 1 1 5 1
1 1 1 1 1 1
输出 1
说明 参考题目描述部分
```
**代码**
```python
# 输入获取
m, n = map(int, input().split())
matrix = [list(map(int, input().split())) for _ in range(m)]
 
 
# 并查集
class UnionFindSet:
    def __init__(self, n):
        self.fa = [idx for idx in range(n)]
        self.count = n
 
    def find(self, x):
        if x != self.fa[x]:
            self.fa[x] = self.find(self.fa[x])
            return self.fa[x]
        return x
 
    def union(self, x, y):
        x_fa = self.find(x)
        y_fa = self.find(y)
 
        if x_fa != y_fa:
            self.fa[y_fa] = x_fa
            self.count -= 1
 
 
# 算法入口
def getResult():
    # 上、下、左、右、左上、左下、右上、右下的横坐标、纵坐标偏移量
    offsets = ((-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1))
 
    # 记录所有边界位置
    brands = set()
 
    for i in range(m):
        for j in range(n):
            # 如果当前点是像素5
            if matrix[i][j] == 5:
                # 遍历像素5的相邻位置
                for offset in offsets:
                    newI = i + offset[0]
                    newJ = j + offset[1]
 
                    # 如果该位置不越界，且为像素1，则是边界
                    if m > newI >= 0 and n > newJ >= 0 and matrix[newI][newJ] == 1:
                        brands.add(newI * n + newJ)
 
    brands_list = list(brands)
    k = len(brands_list)
 
    # 使用并查集，对所有边界位置进行合并
    ufs = UnionFindSet(k)
 
    for i in range(k):
        x1 = brands_list[i] // n
        y1 = brands_list[i] % n
 
        for j in range(i + 1, k):
            x2 = brands_list[j] // n
            y2 = brands_list[j] % n
 
            # 如果两个边界像素1的位置 横向、纵向距离均小于1，则相邻，可以进行合并
            if abs(x1 - x2) <= 1 and abs(y1 - y2) <= 1:
                ufs.union(i, j)
 
    return ufs.count
 
 
# 算法调用
print(getResult())
```

51. 找单词 DFS

**题目描述**
```
给一个字符串和一个 二维字符数组 ，如果该字符串存在于该数组中，则按字符串的字符顺序输出字符串每个字符所在单元格的位置下标字符串，如
回字符串“N”。
1.需要按照字符串的字符组成 顺序搜索 ，且搜索到的位置必须是相邻单元格，其中“相邻单元格”是指那些水平相邻或垂直相邻的单元格。
2.同一个单元格内的字母不允许被重复使用。
3.假定在数组中最多只存在一个可能的匹配。
```
**输入描述**
```
第1行为一个数字N指示二维数组在后续输入所占的行数。
第2行到第N+1行输入为一个二维大写字符数组，每行字符用半角,分割。
第N+2行为待查找的字符串，由大写字符组成。
二维数组的大小为N*N，0<N<=100。
单词长度K，0<K<1000。
```
**输出描述**
```
输出一个位置下标字符串，拼接格式为：第1个字符行下标+”,”+第1个字符列下标+”,”+第2个字符行下标+”,”+第2个字符列下标… +”,”+第N个字符行下标
个字符列下标。
用例
```
**输入**
```
4
A,C,C,F
C,D,E,D
B,E,S,S
F,E,C,A
ACCESS
输出 0,0,0,1,0,2,1,2,2,2,2,3
说明 ACCESS分别对应二维数组的[0,0] [0,1] [0,2] [1,2] [2,2] [2,3]下标
位置。
```
**代码**
```python
class Solution:

    def solve(self, n, matrix, target):
        path = []
        used = [[False] * n for _ in range(n)]

        def dfs(x, y, target):
            if x < 0 or x >= n or y < 0 or y >= n or matrix[x][y] != target[0] or used[x][y]:
                return False
            path.append(str(x) + ',' + str(y))
            used[x][j] = True

            if not target[1:]:
                return True

            res = dfs(x+1, y, target[1:]) or dfs(x, y+1, target[1:]) or dfs(x-1, y, target[1:]) or dfs(
                x, y-1, target[1:])
            if not res:
                path.pop()
                used[x][y] = False
            return res

        for i in range(n):
            for j in range(n):
                if matrix[i][j] == target[0]:
                    if dfs(i, j, target):
                        return ','.join(path)
        return 'N'


s = Solution()
print(s.solve(4, [['A','C','C','F'],
['C','D','E','D'],
['B','E','S','S'],
['F','E','C','A']],
'ACCESS'
))
```

52. 找城市 并查集

**题目描述**
```
一张地图上有n个城市，城市和城市之间有且只有一条道路相连：要么直接相连，要么通过其它城市中转相连（可中转一次或多次）。城市与城市之间
不会成环。
当切断通往某个城市 i 的所有道路后，地图上将分为多个连通的城市群，设该城市i的聚集度为 DPi （Degree of Polymerization），DPi = max（城市
个数，城市群2的城市个数，…城市群m 的城市个数）。
请找出地图上DP值最小的城市（即找到城市j，使得DPj = min(DP1,DP2 … DPn))
提示：如果有多个城市都满足条件，这些城市都要找出来（可能存在多个解）
提示：DPi的计算，可以理解为已知一棵树，删除某个节点后；生成的多个子树，求解多个子数节点数的问题。
```
**输入描述**
```
每个样例：第一行有一个整数N，表示有N个节点。1 <= N <= 1000。
接下来的N-1行每行有两个整数x，y，表示城市x与城市y连接。1 <= x, y <= N
```
**输出描述**
```
输出城市的编号。如果有多个，按照编号升序输出。
```
**用例**
```
输入
5
1 2
2 3
3 4
4 5
输出 3
说明
输入表示的是如下地图：
对于城市3，切断通往3的所有道路后，形成2个城市群
[（1，2），（4，5）]，其聚集度分别都是2。DP3 =
2。
对于城市4，切断通往城市4的所有道路后，形成2个城市
群[（1，2，3），（5）]，DP4 = max（3，1）= 3。
依次类推，切断其它城市的所有道路后，得到的DP都会
大于2，因为城市3就是满足条件的城市，输出是3。
输入
6
1 2
2 3
2 4
3 5
3 6
输出 2 3
说明 将通往2或者3的所有路径切断，最大城市群数量是3，其他任意
城市切断后，最大城市群数量都比3大，所以输出2 3
```
**代码**
```python
import sys
 
# 输入获取
n = int(input())
relations = [list(map(int, input().split())) for i in range(n - 1)]
 
 
# 并查集
class UnionFindSet:
    def __init__(self, n):
        self.fa = [i for i in range(n)]
 
    def find(self, x):
        if x != self.fa[x]:
            self.fa[x] = self.find(self.fa[x])
            return self.fa[x]
        return x
 
    def union(self, x, y):
        x_fa = self.find(x)
        y_fa = self.find(y)
        if x_fa != y_fa:
            self.fa[y_fa] = x_fa
 
 
# 算法入口
def getResult():
    # minDp用于保存最小城市聚集度
    minDp = sys.maxsize
    # city用于保存最小城市聚集度对应的被切割的城市序号
    city = []
 
    # 遍历每个城市 1~n
    for i in range(1, n + 1):
        # 利用并查集对城市进行关联
        ufs = UnionFindSet(n + 1)
 
        for x, y in relations:
            # 切断城市的所有道路，即忽略和城市i有联系的合并操作
            if x == i or y == i:
                continue
            # 否则连接x和y
            ufs.union(x, y)
 
        # 统计各个连通分量自身的城市个数
        cnts = [0] * (n + 1)
        for j in range(1, n + 1):
            fa = ufs.find(j)
            cnts[fa] += 1
 
        #  取最多城市个数作为当前的切断城市的聚集度
        dp = max(cnts)
 
        if dp < minDp:
            minDp = dp
            city = [i]
        elif dp == minDp:
            city.append(i)
 
    # 如果有多个，按照编号升序输出。
    city.sort()
    return " ".join(map(str, city))
 
 
# 算法调用
print(getResult())
```

53. 可以组成网络的服务器 BFS/DFS

**题目描述**
```
在一个机房中， 服务器 的位置标识在 n*m 的整数矩阵网格中，1 表示单元格上有服务器，0 表示没有。如果两台服务器位于同一行或者同一列中紧
则认为它们之间可以组成一个局域网。
请你统计机房中最大的 局域网 包含的服务器个数。
```
**输入描述**
```
第一行输入两个正整数，n和m，0<n,m<=100
之后为n*m的 二维数组 ，代表服务器信息
```
**输出描述**
```
最大局域网包含的服务器个数。
```
**用例**
```
输入
2 2
1 0
1 1
输出 3
说明 [0][0]、[1][0]、[1][1]三台服务器相互连接，可以组成局域网
```
**代码**
```python
class Solution:

    def solve(self, m, n, matrix):
        ans = 0

        def dfs(x, y):
            total = 1
            matrix[x][y] = 0
            for dx, dy in [(0,1),(0,-1),(1,0),(-1,0)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] == 1:
                    total += dfs(nx, ny)
            matrix[x][y] = 1
            return total

        for i in range(m):
            for j in range(n):
                if matrix[i][j] == 1:
                    ans = max(ans, dfs(i, j))
        return ans


s = Solution()
print(s.solve(2,2,[[1,0],[1,1]]))
```

```python
class Solution:

    def solve(self, m, n, matrix):
        vis = set()
        ans = 0

        def bfs(x, y):
            nonlocal ans
            total = 0
            queue = [(x, y)]
            while queue:
                node = queue.pop(0)
                total += 1
                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nx, ny = node[0] + dx, node[1] + dy
                    pos = nx * n + ny
                    if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] == 1 and pos not in vis:
                        vis.add(pos)
                        queue.append((nx, ny))
            ans = max(ans, total)

        for i in range(m):
            for j in range(n):
                pos = i * n + j
                if matrix[i][j] == 1 and pos not in vis:
                    vis.add(pos)
                    bfs(i, j)

        return ans

s = Solution()
print(s.solve(3,4,[[1,0,0,1],[1,1,1,0],[0,1,0,1]]))
```

54. 简易内存池 模拟

**题目描述**
```
请实现一个简易内存池,根据请求命令完成内存分配和释放。
内存池支持两种操作命令，REQUEST和RELEASE，其格式为：
REQUEST=请求的内存大小 表示请求分配指定大小内存，如果分配成功，返回分配到的内存首地址；如果内存不足，或指定的大小为0，则输出
RELEASE=释放的内存首地址 表示释放掉之前分配的内存，释放成功无需输出，如果释放不存在的首地址则输出error。
注意：
1. 内存池总大小为100字节。
2. 内存池地址分配必须是连续内存，并优先从低地址分配。
3. 内存释放后可被再次分配，已释放的内存在空闲时不能被二次释放。
4. 不会释放已申请的内存块的中间地址。
5. 释放操作只是针对首地址所对应的单个内存块进行操作，不会影响其它内存块。
```
**输入描述**
```
首行为整数 N , 表示操作命令的个数，取值范围：0 < N <= 100。
接下来的N行, 每行将给出一个操作命令，操作命令和参数之间用 “=”分割。
```
**输出描述**
```
请求分配指定大小内存时，如果分配成功，返回分配到的内存首地址；如果内存不足，或指定的大小为0，则输出error
释放掉之前分配的内存时，释放成功无需输出，如果释放不存在的首地址则输出error。
```
**用例**
```
输入
2
REQUEST=10
REQUEST=20
输出 0
10
说明 无
输入
5
REQUEST=10
REQUEST=20
RELEASE=0
REQUEST=20
REQUEST=10
输出
0
10
30
0
说明
第一条指令，申请地址0~9的10个字节内存，返回首地
址0
第二条指令，申请地址10~29的20字节内存，返回首地
址10
第三条指令，释放首地址为0的 内存申请 ，0~9地址内
存被释放，变为空闲，释放成功，无需输出
第四条指令，申请20字节内存，09地址内存连续空间不
足20字节，往后查找到3049地址，返回首地址30
第五条指令，申请10字节，0~9地址内存空间足够，返
回首地址0
```
**题目解析**
```
定义一个used数组，用来存储已被占用的内存区间，即[起始位置，结束位置]。
初始化 给used数组一个 [100,101]，表示存在一个已占有内存区间[100,101]，这个内存区间将作为尾边界使用。
当REQUEST申请size大小的内存时，我们从start=0位置开始申请，即申请[start, start+size-1]区间，接下来看该区间是否和used[i]区间存在交叉，如果存在交xian叉，则说明申请的内存区间中部分内存已被使用，因此我们应该更新 start = used[i][1] + 1位置，重新申请一个区间，这样就必然不和used[i]区间交叉了，但是要继续和used[i+1]区间比较。
直到找到一个不存在交叉的内存区间，打印此时的start，并将申请到的内存区间插入到used数组中，注意插入位置是 i 。
如果一直都找不到不存在交叉的内存区间，则打印error。
当RELEASE释放起始位置addr的内存时，我们只需要遍历每一个used[i]，比较used[i][0]和addr是否相同，若相同，则表示找到了要释放的内存，此时只要将used[i]从used中删除即可。
如果没有找到，则打印error
```
**代码**
```python
class Solution:

    def solve(self, n, operations):
        used = [[100, 101]]
        ans = []
        for i in range(n):
            op = operations[i].split('=')
            if len(op) != 2:
                ans.append('error')
                continue
            if op[0] == 'REQUEST':
                val = int(op[1])
                if val <= 0 or val > 100:
                    ans.append('error')
                    continue
                start = 0
                end = start + val - 1
                for j in range(len(used)):
                    if end < used[j][0]:
                        used.insert(j, [start, end])
                        ans.append(str(start))
                        break
                    else:
                        start = used[j][1] + 1
                        end = start + val - 1
                else:
                    ans.append('error')
            elif op[0] == 'RELEASE':
                val = int(op[1])
                if val >= 100:
                    ans.append('error')
                    continue
                for i in range(len(used)):
                    if used[i][0] == val:
                        used.pop(i)
                        break
                else:
                    ans.append('error')
            else:
                ans.append('error')
                continue
        return '\n'.join(ans)


s = Solution()
print(s.solve(5, ['REQUEST=10', 'REQUEST=20', 'RELEASE=0', 'REQUEST=20', 'REQUEST=10']))
```

55. 学生重新排队 逻辑分析

**题目**
```
n 个学生排成一排，学生编号分别是 1 到 n，n 为 3 的整倍数。
老师随机抽签决定将所有学生分成 m 个 3 人的小组（n == 3 * m） ，
为了便于同组学生交流，老师决定将小组成员安排到一起，也就是同组成员彼此相连，同组任意两个成员之间无其它组的成员。
因此老师决定调整队伍，老师每次可以调整任何一名学生到队伍的任意位置，计为调整了一次， 请计算最少调整多少次可以达到目标。
注意：对于小组之间没有顺序要求，同组学生之间没有顺序要求。
```
**输入描述：**
```
两行 字符串 ，空格分隔表示不同的学生编号。
第一行是学生目前排队情况
第二行是随机抽签分组情况，从左开始每 3 个元素为一组
n 为学生的数量，n 的范围为 [3, 900]，n 一定为 3 的整数倍
第一行和第二行元素的个数一定相同
```
**输出描述**
```
老师调整学生达到同组彼此相连的最小调整次数
备注：
同组相连：同组任意两个成员之间无其他组的成员，比如有两个小组 [4, 5, 6] 和 [1, 2, 3]，
以下结果都满足要求：
1,2,3,4,5,6；
1,3,2,4,5,6；
2,3,1,5,6,4；
5,6,4,1,2,3；
以下结果不满足要求：
1,2,4,3,5,6；（4与5之间存在其他组的成员3）
```
**示例1：**
```
输入：
4 2 8 5 3 6 1 9 7
6 3 1 2 4 8 7 9 5
输出：
1
说明：
分组为[6,3,1],[2,4,8],[7,9,5]，那么初始排序中，只需要将5移到1后面即可
428 361 597即可满足要求，只需要一次调整。
```
**示例2：**
```
输入：
8 9 7 5 6 3 2 1 4
7 8 9 4 2 1 3 5 6
输出：
0
```
**示例3：**
```
输入：
7 9 8 5 6 4 2 1 3
7 8 9 4 2 1 3 5 6
输出：
1
```
**代码**
```python
# 分块（即连续的相同组的小朋友）
class Block:
    def __init__(self, groupId, count):
        self.groupId = groupId
        self.count = count
 
 
# 输入获取
nums = list(map(int, input().split()))  # // 原始顺序
sorted_nums = list(map(int, input().split()))  # 排队顺序
 
 
def confirm(queue, confirmed_groupId):
    # 此方法用于剔除掉队列中已被调整完位置的小朋友，并且抽离后，尝试合并抽离位置前后的小朋友（如果是同一组）
    # 时间复杂度有点高这里，可能会超时
    back_queue = []
 
    while len(queue) > 0:
        first = queue.pop(0)
 
        if first.groupId == confirmed_groupId:
            continue
 
        if len(back_queue) == 0 or back_queue[-1].groupId != first.groupId:
            back_queue.append(Block(first.groupId, first.count))
        else:
            back_queue[-1].count += first.count
 
    return back_queue
 
 
# 算法入口
def getResult():
    n = len(nums)
 
    # 序号->组号 映射关系，即group的索引是序号，值是组号
    group = [0] * (n + 1)
    for i in range(n):
        num = sorted_nums[i]
        group[num] = i // 3
 
    # 相邻相同组号合并统计
    queue = []
    for num in nums:
        groupId = group[num]
 
        if len(queue) == 0 or queue[-1].groupId != groupId:
            queue.append(Block(groupId, 1))
        else:
            queue[-1].count += 1
 
    #  记录调整次数
    moved_count = 0
    while len(queue) > 0:
        first = queue.pop(0)
 
        # 当first.count = 1 时，情况如下
        # 1 x 1 1 y z
        # 1 x 1 y 1 z
        if first.count == 1:
            x = queue[0]
 
            # 判断x是否存在连续完整分组
            while x.count == 3:
                queue.pop(0)
                x = queue[0]
 
            if x.groupId == first.groupId and x.count == 2:
                # 情况：1 2 2 2 x[1 1]
                # 将开头1，移动进x中
                moved_count += 1
                queue.pop(0)
            else:
                # 情况如下：
                # 1 x[2 2] 1 1
                # 1 x[2] 1 2 1
                # 将后面的两个1移动到开头
                moved_count += 2
                queue = confirm(queue, first.groupId)
        elif first.count == 2:
            # 当first.count == 2 时，情况如下：
            # 1 1 x 1 y z
            moved_count += 1
            queue = confirm(queue, first.groupId)
 
    return moved_count
 
 
# 算法调用
print(getResult())
```

56. 电脑病毒感染 dijkstra算法

**题目描述**
```
一个 局域网 内有很多台电脑，分别标注为 0 ~ N-1 的数字。相连接的电脑距离不一样，所以感染时间不一样，感染时间用 t 表示。
其中网络内一台电脑被病毒感染，求其感染网络内所有的电脑最少需要多长时间。如果最后有电脑不会感染，则返回-1。
给定一个数组 times 表示一台电脑把相邻电脑感染所用的时间。
如图：path[i] = {i, j, t} 表示：电脑 i->j，电脑 i 上的病毒感染 j，需要时间 t。
```
**输入描述**
```
4
3
2 1 1
2 3 1
3 4 1
2
```
**输出描述**
```
2
```
**题解**
```
1. 构建邻接表
2. vis代表是否找到最短路径
3. dist代表当前最短路径长度
4. queue优先队列存储
```
**代码**
```python
import heapq
import sys
 
# 输入获取
n = int(input())
 
# 邻接表
graph = {}
 
m = int(input())
for i in range(m):
    # 出发点, 目标点, 出发点到达目标点的耗时
    u, v, w = map(int, input().split())
    graph.setdefault(u, [])
    graph[u].append([v, w])
 
# 源点
src = int(input())
 
# visited[i]:记录节点i是否找到最短路
visited = [False] * (n + 1)
 
# dist[i]:记录源点到节点i的最短路
# 初始时，假设源点不可达其他剩余点，即源点到达其他点的耗时无限大
dist = [sys.maxsize] * (n + 1)
# 源点到自身的耗时为0
dist[src] = 0
 
# pq用于记录[节点编号，节点到源点的距离]，排序规则是，节点到源点的距离越短，优先级越高
pq = []
# 从源点src开始发起探索
heapq.heappush(pq, (dist[src], src))
 
# bfs
while len(pq) > 0:
    # 取出局部最优（最短）路径的终点编号 u
    u = heapq.heappop(pq)[1]
 
    # 如果节点编号u已经找到了最短路，说明当前u是重复入队的点，因此无需继续探索
    if visited[u]:
        continue
 
    # 否则记录当前u找到了最短路
    visited[u] = True
 
    # 如果u有可达的其他点
    if graph.get(u) is not None:
        # v是可达的其他店，w是u->v的耗时
        for v, w in graph[u]:
            # 那么如果从源点到u点的耗时是dist[u]，那么源点经过u点到v点的耗时就是dist[u] + w
            newDist = dist[u] + w
 
            # 而源点到v的耗时之前是dist[v]，因此如果newDist < dist[v]，则找到更少耗时的路径
            if dist[v] > newDist:
                # 更新源点到v的路径，即更新v点权重
                dist[v] = newDist
                # 将v点加入优先队列中参与下一轮局部最优路径比较
                heapq.heappush(pq, (dist[v], v))
 
ans = max(dist[1:])
 
print(-1 if ans == sys.maxsize else ans)
```

57. 路口最短时间问题 dijkstra变形

**题目描述**
```
假定街道是棋盘型的，每格距离相等，车辆通过每格街道需要时间均为 timePerRoad；
街道的街口（交叉点）有 交通灯 ，灯的周期 T（=lights[row][col]）各不相同；
车辆可直行、左转和右转，其中直行和左转需要等相应 T 时间的交通灯才可通行，右转无需等待。
现给出 n * m 个街口的交通灯周期，以及起止街口的坐标，计算车辆经过两个街口的最短时间。
其中：
1. 起点和终点的交通灯不计入时间，且可以在任意方向经过街口
2. 不可超出 n * m 个街口，不可跳跃，但边线也是道路（即：lights[0][0] -> lights[0][1] 是有效路径）
入口 函数定义 ：
```
**输入描述**
```
第一行输入 n 和 m，以空格分隔
之后 n 行输入 lights矩阵，矩阵每行m个整数，以空格分隔
之后一行输入 timePerRoad
之后一行输入 rowStart colStart，以空格分隔
最后一行输入 rowEnd colEnd，以空格分隔
```
**输出描述**
```
lights[rowStart][colStart] 与 lights[rowEnd][colEnd] 两个街口之间的最短通行时间
```
**用例**
```
输入
3 3
1 2 3
4 5 6
7 8 9
60
0 0
2 2
输出 245
说明
行走路线为 (0,0) -> (0,1) -> (1,1) -> (1,2) -> (2,2) 走了4格路，2
个右转，1个左转，共耗时 60+0+60+5+60+0+60=245
```
**代码**
```python
import sys
 
 
# 根据三点坐标，确定拐弯方向
def getDirection(preX, preY, curX, curY, nextX, nextY):
    """
    :param preX: 前一个点横坐标
    :param preY: 前一个点纵坐标
    :param curX: 当前点横坐标
    :param curY: 当前点纵坐标
    :param nextX: 下一个点横坐标
    :param nextY: 下一个点纵坐标
    :return: cur到next的拐弯方向， >0 表示向左拐， ==0 表示直行（含调头）， <0 表示向右拐
    """
    # 向量 pre->cur
    dx1 = curX - preX
    dy1 = curY - preY
 
    # 向量 cur->next
    dx2 = nextX - curX
    dy2 = nextY - curY
 
    #  两个向量的叉积 >0 表示向左拐， ==0 表示直行（含调头）， <0 表示向右拐
    return dx1 * dy2 - dx2 * dy1
 
 
class Solution:
    def calcTime(self, lights, timePerRoad, rowStart, colStart, rowEnd, colEnd):
        n = len(lights)
        m = len(lights[0])
 
        # 到达位置(i,j)的路径有四个来源方向]
        # dist[i][j][k] 表示从来源方向k到达位置(i,j)所需要的时间，初始化INT_MAX
        dist = [[[sys.maxsize] * 4 for _ in range(m)] for _ in range(n)]
 
        # 小顶堆，堆中元素是数组 [前一个位置行号，前一个位置列号，当前位置行号，当前位置列号，到达当前位置需要的时间]
        # 到达当前位置的时间越小，优先级越高
        pq = []
 
        # 四个来源方向到达出发点位置 (rowStart, colStart) 所需时间均为 0
        for k in range(4):
            dist[rowStart][colStart][k] = 0
            # 出发点位置没有前一个位置，因此前一个位置设为(-1,-1)
            pq.append((-1, -1, rowStart, colStart, 0))
 
        offsets = ((-1, 0), (1, 0), (0, -1), (0, 1))
 
        # 每次取出最短路
        while len(pq) > 0:
            pq.sort(key=lambda x: -x[4])
            preX, preY, curX, curY, cost = pq.pop()
 
            # 向四个方向探索
            for k in range(4):
                # 新位置
                newX = curX + offsets[k][0]
                newY = curY + offsets[k][1]
 
                # 新位置越界，则不可进入
                if newX < 0 or newX >= n or newY < 0 or newY >= m:
                    continue
 
                # 本题不允许掉头，因此新位置处于掉头位置的话，不可进入
                if newX == preX and newY == preY:
                    continue
 
                # 每走一步都要花费 timePerRoad 单位时间
                newCost = cost + timePerRoad
 
                # 出发的第一步，或者右拐，不需要等待红绿灯，其他情况需要等待红绿灯 lights[curX][curY] 单位时间
                if preX != -1 and preY != -1 and getDirection(preX, preY, curX, curY, newX, newY) >= 0:
                    newCost += lights[curX][curY]
 
                # 如果以来源方向k到达位置（newX, newY）花费的时间 newCost 并非更优，则终止对应路径探索
                if newCost >= dist[newX][newY][k]:
                    continue
 
                # 否则更新为更优时间
                dist[newX][newY][k] = newCost
                # 并继续探索该路径
                pq.append((curX, curY, newX, newY, newCost))
 
        # 最终取(rowEnd, colEnd)终点位置的四个来源方向路径中最短时间的作为题解
        return min(dist[rowEnd][colEnd])
 
 
# 实际考试时，本题为核心代码模式，即无需我们解析输入输出，因此只需要写出上面代码即可
if __name__ == '__main__':
    n, m = map(int, input().split())
    lights = [list(map(int, input().split())) for _ in range(n)]
    timePerRoad = int(input())
    rowStart, colStart = map(int, input().split())
    rowEnd, colEnd = map(int, input().split())
 
    print(Solution().calcTime(lights, timePerRoad, rowStart, colStart, rowEnd, colEnd))
```

58. 寻找最优的路测线路 dijkstra

**题目描述**
```
评估一个网络的 信号质量 ，其中一个做法是将网络划分为栅格，然后对每个栅格的信号质量计算。
路测的时候，希望选择一条信号最好的路线（彼此相连的栅格集合）进行演示。
现给出 R 行 C 列的整数数组 Cov，每个单元格的数值 S 即为该栅格的信号质量（已归一化，无单位，值越大信号越好）。
要求从 [0, 0] 到 [R-1, C-1]设计一条最优路测路线。返回该路线得分。
规则：
1. 路测路线可以上下左右四个方向，不能对角
2. 路线的评分是以路线上信号最差的栅格为准的，例如路径 8→4→5→9 的值为4，该线路评分为4。线路最优表示该条线路的评分最高。
```
**输入描述**
```
第一行表示栅格的行数 R
第二行表示栅格的列数 C
第三行开始，每一行表示 栅格地图 一行的信号值，如5 4 5
```
**输出描述**
```
最优路线的得分
备注
1 ≤ R，C ≤ 20
0 ≤ S ≤ 65535
```
**用例**
```
输入
3
3
5 4 5
1 2 6
7 4 6
输出 4
说明 路线为：5→4→5→6→6
输入
6
5
3 4 6 3 4
0 2 1 1 7
8 8 3 2 7
3 2 4 9 8
4 1 2 0 0
4 6 5 4 3
输出 3
说明
路线为：
3→4→6→3→4→7→7→8→9→4→3→8→8→3→4→4→6→5→4→3
```
**代码**
```python
# 输入获取
r = int(input())
c = int(input())
matrix = [list(map(int, input().split())) for _ in range(r)]
 
 
# 算法入口
def getResult():
    # dist[i]记录的 起点0 到 终点i 的所有路径中“最大的”最小权值节点的权值
    # 其中 i 是将二维坐标一维化后的值，比如(x,y)坐标一维化后为 x * c + y; (c是列数)
    # dist[i] 记录的 “最大的”最小权值节点的权值，因此需要初始化为一个 "最小的" 最小权值节点的权值，方便后面被更大者取代，由于本题节点的最小权值>=0，因此这里可以初始化为0
    dist = [0] * (r * c)
    # 起点0 到 终点0 路径的最小权值节点就是自身，即matrix[0][0]点的权重
    dist[0] = matrix[0][0]
 
    # 优先队列记录路径（终点），并且路径中的最小权值节点的权值越大，优先级越高
    # 初始时将(0,0)入队
    pq = [0]
 
    # 上下左右的方向偏移量
    offsets = ((-1, 0), (1, 0), (0, -1), (0, 1))
 
    while len(pq) > 0:
        # 取出优先队列中优先级最大的路径（终点）
        u = pq.pop()
 
        # 将一维化坐标u，解析为二维坐标(x,y)
        x = u // c
        y = u % c
 
        # 已找到dist[r-1][c-1]最优解，则可以提前结束
        if x == r - 1 and y == c - 1:
            break
 
        # 向上下左右四个方向探索
        for offsetX, offsetY in offsets:
            # 新位置坐标
            newX = x + offsetX
            newY = y + offsetY
 
            # 新位置越界则无法访问
            if newX < 0 or newX >= r or newY < 0 or newY >= c:
                continue
 
            # 新位置的一维化坐标
            v = newX * c + newY
            # 当前路径（终点u）的最小权值节点的权值为dist[u]
            # 要加入当前路径的新位置的点的权值 matrix[newX][newY]
            #  那么形成的新路径的最小权值节点的权值即为 w = min(dist[u], matrix[newX][newY])
            w = min(dist[u], matrix[newX][newY])
 
            # 形成的新路径的终点为 v（即新位置一维化坐标）
            # 而dist[v]记录的是起点到点v的所有路径中“最大的”最小权值节点
            if dist[v] < w:
                # 因此如果dist[v] < w的话，则更新dist[v]
                dist[v] = w
                # 并将新路径加入优先队列，参与下一轮比较
                pq.append(v)
                # 优先级排序，由于24行是pq.pop()，尾部优先级最大，因此这里升序
                pq.sort(key=lambda i: dist[i])
 
    # 返回起点（0，0）到终点(r-1, c-1)的所有路径中"最大的"最小权值节点的权值
    return dist[r * c - 1]
 
 
# 算法调用
print(getResult())
```