1. **猴子吃桃 二分法**

**题目描述**
```
孙悟空爱吃蟠桃，有一天趁着蟠桃园守卫不在来偷吃。已知蟠桃园有 N 棵桃树，每颗树上都有桃子，守卫将在 H 小时后回来。
孙悟空可以决定他吃蟠桃的速度K（个/小时），每个小时选一颗桃树，并从树上吃掉 K 个，如果树上的桃子少于 K 个，则全部吃掉，并且这一小时剩
不再吃桃。
孙悟空喜欢慢慢吃，但又想在守卫回来前吃完桃子。
请返回孙悟空可以在 H 小时内吃掉所有桃子的最小速度 K（K为整数）。如果以任何速度都吃不完所有桃子，则返回0。
```
**输入描述**
```
第一行输入为 N 个数字，N 表示桃树的数量，这 N 个 数字表示 每颗桃树上蟠桃的数量。
第二行输入为一个数字，表示守卫离开的时间 H。
其中数字通过空格分割，N、H为正整数，每颗树上都有蟠桃，且 0 < N < 10000，0 < H < 10000。
```
**输出描述**
```
吃掉所有蟠桃的最小速度 K，无解或输入异常时输出 0。
```
**用例**
```
输入 2 3 4 5
4
输出 5
说明 无
输入 2 3 4 5
3
输出 0
说明 无
输入 30 11 23 4 20
6
输出 23
说明 无
```
**代码**
```python
class Solution:
    def solve(self, trees, n):
        if n < len(trees):
            return 0
        l, r = 1, max(trees)
        while l < r:
            mid = (l + r) >> 1
            if self.get_res(trees, n, mid):
                r = mid
            else:
                l = mid + 1
        return l

    def get_res(self, trees, n, speed):
        total = 0
        for i in range(len(trees)):
            total += (trees[i] + speed - 1) // speed
            if total > n:
                return False
        return True

s = Solution()
print(s.solve([2,3,4,5], 4))
```

2. 猜拳 逻辑分析

**题目描述**
```
石头剪刀布 游戏有 3 种出拳形状：石头、剪刀、布。分别用字母A、B、C表示。
游戏规则 ：
1. 出拳形状之间的胜负规则如下：
A > B；
B > C；
C > A；
">" 左边一个字母，表示相对优势形状。右边一个字母，表示相对劣势形状。
2. 当本场次中有且仅有一种出拳形状优于其他出拳形状，则该形状的玩家是胜利者。否则认为是平局。
例如1：三个玩家出拳分别是A，B，C。由于三方优势循环（即没有任何一方优于其他出拳者），判断为平局。
例如2：三个玩家出拳分别是A，B，B。出拳A的获胜。
例如3：三个玩家出拳全部是A。判为平局。
3. 当发生平局，没有赢家。有多个胜利者时，同为赢家。
```

**输入描述**
```
在一场游戏中，每个玩家的信息为一行。玩家数量不超过1000。每个玩家信息有2个字段，用空格隔开；
1. 玩家ID：一个仅由英文字母和数字组成的字符串
2. 出拳形状：以英文大写字母表示，A、B、C形状。
3. 出拳时间：正整数，越小表示时间越早
例如：
abc1 A
xyz B
解释：玩家abc1出拳为石头（A）。玩家xyz出拳为剪刀（B）
```

**输出描述**
```
输出为赢家的玩家ID列表（一个或多个），每个ID一行，按 字符串 升序排列。如果没有赢家，输出为”NULL“字符串。
例如：
abc1
```
**代码**
```python
def get_res():
    mp = {}
    while True:
        try:
            name, value = input().split()
            if value < 'A' or value > 'C':
                print('NULL')
                return

            if value not in mp:
                mp[value] = [name]
            else:
                mp[value].append(name)
        except:
            break

    kinds = len(mp)
    if kinds == 1 or kinds == 3:
        print('NULL')
    else:
        ans = None
        if 'B' not in mp:
            ans = mp['C']
        elif 'A' not in mp:
            ans = mp['B']
        else:
            ans = mp['A']
        ans.sort()
        for item in ans:
            print(item)

get_res()
```

3. 二叉树计算 dfs

**题目**
```
给出一个二叉树：请由该二叉树生成一个新的二叉树，它满足其树中的每个节点将包含原始树中的左子树和右子树的和。
左子树表示该节点左侧叶子节点为 根节点 的一颗新树；右子树表示该节点右侧叶子节点为根节点的一颗新树。
```
**输入描述**
```
2行整数，第1行表示二叉树的 中序遍历 ，第2行表示二叉树的前序遍历，以空格分割
例如：
7 -2 6 6 9
6 7 -2 9 6
```
**输出描述**
```
1行整数，表示求和树的中序遍历，以空格分割
例如：
-2 0 20 0 6
```
**用例1**
```
输入
1 7 -2 6 6 9
2 6 7 -2 9 6
输出
-2 0 20 0 6
```
**思路**
```
1：二叉树相关的很经典的题目，从前序+中序去 还原二叉树 。
2：本题只是在还原二叉树的基础上要算每一个节点的左右子树和，一个dfs解决问题。
```
**代码**
```python
class TreeNode:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

class Solution:

    def build(self, inorder, preorder):
        if not inorder and not preorder:
            return
        root = TreeNode(preorder[0])
        index = inorder.index(preorder[0])
        root.left = self.build(inorder[:index], preorder[1:index+1])
        root.right = self.build(inorder[index+1:], preorder[index+1:])
        return root

    def solve(self, inorder, preorder):
        root = self.build(inorder, preorder)
        res = []
        def dfs(root):
            if not root:
                return 0
            tmp = root.value
            left = dfs(root.left)
            res.append(left)
            index = len(res)
            right = dfs(root.right)
            res[index-1] += right
            return left + right + tmp

        dfs(root)
        return res

s = Solution()
print(s.solve([7,-2,6,6,9], [6,7,-2,9,6]))
```

5. 分月饼 分治

**题目描述**
```
中秋节，公司分 月饼 ，m 个员工，买了 n 个月饼，m ≤ n，每个员工至少分 1 个月饼，但可以分多个，
单人分到最多月饼的个数是 Max1 ，单人分到第二多月饼个数是 Max2 ，Max1 - Max2 ≤ 3 ，
单人分到第 n - 1 多月饼个数是 Max(n-1)，单人分到第n多月饼个数是 Max(n) ，Max(n-1) – Max(n) ≤ 3,
问有多少种分月饼的方法？
```
**输入描述**
```
每一行输入m n，表示m个员工，n个月饼，m ≤ n
```
**输出描述**
```
输出有多少种月饼分法
```
**题目解析**
```
本题类似于 整数划分问题 ，即将一个正整数n，分解为m个正整数的方案数。
这类问题一般不会有太大的数量级，比如将10000分解为10个整数，那方案数就太多了。
本题给了一个限制条件，那就是，如果将分解后的m个正整数升序的话，相邻元素之间的差值不能超过3。
另外，分解方案不在意m个正整数的顺序，比如 1 2 1 和 1 1 2算一种方案。
我这里考虑使用分治递归求解。
分治递归可以想象成一棵树，这颗树有m层。
第0层相当于序号0个员工，该层有多个节点，每个节点的值即为序号0个员工可能分得的月饼数量。
题目说，每个员工至少分得1个月饼，因此序号0个员工分得月饼数至少为1。
为了保证不产生重复方案，因此我们默认当前求解的升序的m个正整数序列，因此序号0个员工分得的月饼数不能超过均值，即 n / m，因为一旦序号0个员工分得的月饼超过均值，则其后面的员工必然会有分得小于均值月饼数的情况。
因此第0个员工分得的月饼数范围是 1 ~ n / m
接下来是第1层，相当于序号1员工，该员工分得的月饼数取决于上一层的员工：
为了保证升序，序号1员工分得的月饼最少数量即序号0员工分得的月饼数量
同时，题目限定相邻员工之间，月饼数差距不能超过3，因此序号1员工最多分得的月饼数量 = 序号0员工分得月饼数量 + 3
另外为了保证后面员工分得月饼数一定不小于序号1员工，因此序号1员工分得的月饼数量不能超过 (剩余月饼数量 ➗ 剩余员工数量) ，其中：
1. 剩余月饼数量 = n - 序号0员工分得的月饼数
2. 剩余员工数量 = m - 1
接下来层数同理，直到第m-1层，即分配到最后一个员工，此时最后一个员工将分得剩余所有月饼，如果最后一个员工和倒数第二个员工月饼数差距bu超过3，即可判断当前递归分支对应的分配方案可行与否
```
**代码**
```python
from functools import cache
import sys
 
# 这题递归可能栈溢出，Python的递归深度要搞大一点，考试时如果10000不行，再加大一点
sys.setrecursionlimit(10000)
 
# 输入获取
m, n = map(int, input().split())
 
 
# 递归
@cache
def recursive(level, low, high, remain):
    """
    :param level: 第几个员工
    :param low: 当前员工至少分得几个月饼
    :param high: 当前员工至多分得几个月饼
    :param remain: 分月饼给当前员工前，月饼的剩余数量
    """
    # 分到最后一个员工时，我们应该将剩余月饼都给他
    if level == m - 1:
        # 因此最后一个员工的月饼数量就是remain，而倒数第二个员工的月饼数量是low（本轮递归的min参数，即上一轮员工分得的月饼数量）
        if remain - low <= 3:
            # 如果二者差距不超过maxDiff，则分月饼方案可行
            return 1
 
        # 否则方案不可行
        return 0
 
    # ans记录可行方案数
    ans = 0
 
    # i 是当前员工可以分得的月饼数量
    for i in range(low, high + 1):
        remain -= i
        # 下一个员工至少分得 i 个月饼（当前员工分得的月饼数量），至多分得 i + maxDiff
        # 同时下一个员工分得的月饼数量不能超过：均分月饼数量（即剩余月饼总数 / 剩余员工总数），否则破坏去重策略（为了保证分月饼的方案不重复，我们这里保证后面的员工分得月饼数不小于前面员工）
        ans += recursive(level + 1, i, min(i + 3, remain // (m - level - 1)), remain)
        remain += i
 
    return ans
 
 
# 算法入口
def getResult():
    if m == 1:
        # 如果只有一个员工分月饼，那么就只有一种方案
        return 1
    else:
        # 如果有多个员工分月饼，为了保证分月饼的方案不重复，我们这里保证 员工i的月饼数量 <= 员工i+1的月饼数量
        # 因此对于第0个员工，至少分得1个月饼，至多分得n/m个月饼（均分数量）
        return recursive(0, 1, n // m, n)
 
 
# 算法调用
print(getResult())
```

6. 连续出牌数量 回溯

**题目描述**
```
有这么一款单人卡牌游戏，牌面由颜色和数字组成，颜色为红、黄、蓝、绿中的一种，数字为0-9中的一个。游戏开始时玩家从手牌中选取一张卡牌打
如果玩家手中有和他上一次打出的手牌颜色或者数字相同的手牌，他可以继续将该手牌打出，直至手牌打光或者没有符合条件可以继续打出的手牌。
现给定一副手牌，请找到最优的出牌策略，使打出的手牌最多。
```
**输入描述**
```
输入为两行
第一行是每张手牌的数字，数字由空格分隔，
第二行为对应的每张手牌的颜色，用r y b g这4个字母分别代表4种颜色，字母也由空格分隔。
手牌数量不超过10。
```
**输出描述**
```
输出一个数字，即最多能打出的手牌的数量。
```
**用例**
```
输入 1 4 3 4 5
r y b b r
输出 3
说明 如果打（1, r）-> (5, r)，那么能打两张。
如果打（4，y) -> (4, b) -> (3, b)，那么能打三张。
输入 1 2 3 4
r y b l
输出 1
说明 没有能够连续出牌的组合，只能在开始时打出一张手牌，故输出1
```
**代码**
```python
class Solution:

    def solve(self, nums, colors):

        ans = 0
        used = [False] * len(nums)

        def dfs(cnt, used, last):
            nonlocal ans
            ans = max(ans, cnt)
            if False not in used:
                return

            for i in range(len(nums)):
                if not used[i]:
                    if last and last[0] != nums[i] and last[1] != colors[i]:
                        continue
                    used[i] = True
                    dfs(cnt+1, used, [nums[i], colors[i]])
                    used[i] = False
            return ans

        return dfs(0, used, None)


s = Solution()
print(s.solve([1,4,3,4,5], ['r', 'y', 'b', 'b', 'r']))
```

7. 攀登者 逻辑分析

**题目描述**
```
攀登者喜欢寻找各种地图，并且尝试攀登到最高的山峰。
地图表示为一维数组，数组的索引代表水平位置，数组的元素代表相对海拔高度。其中数组元素0代表地面。
例如：[0,1,2,4,3,1,0,0,1,2,3,1,2,1,0]，代表如下图所示的地图，地图中有两个山脉位置分别为 1,2,3,4,5 和 8,9,10,11,12,13，最高峰高度分别为 4,3。最高峰位置分别为3,10。
一个山脉可能有多座山峰(高度大于相邻位置的高度，或在地图边界且高度大于相邻的高度)。
登山时会消耗登山者的体力(整数)，
上山时，消耗相邻高度差两倍的体力
下山时，消耗相邻高度差一倍的体力
平地不消耗体力
登山者体力消耗到零时会有生命危险。
例如，上图所示的山峰：
从索引0，走到索引1，高度差为1，需要消耗 2 * 1 = 2 的体力，
从索引2，走到索引3，高度差为2，需要消耗 2 * 2 = 4 的体力。
从索引3，走到索引4，高度差为1，需要消耗 1 * 1 = 1 的体力。
攀登者想要评估一张地图内有多少座山峰可以进行攀登，且可以安全返回到地面，且无生命危险。
例如上图中的数组，有3个 不同的 山峰，登上位置在3的山可以从位置0或者位置6开始，从位置0登到山顶需要消耗体力 1 * 2 + 1 * 2 + 2 * 2 = 8，从山顶返回到地面0需要消耗体力 2 * 1 + 1 * 1 + 1 * 1 = 4 的体力，按照登山路线 0 → 3 → 0 需要消耗体力12。攀登者至少需要12以上的体力（大于12）才能安全返回。
```
**输入描述**
```
第一行输入为地图一维数组
第二行输入为攀登者的体力
```
**输出描述**
```
确保可以安全返回地面，且无生命危险的情况下，地图中有多少山峰可以攀登。
```
**代码**
```python
# 输入获取
heights = list(map(int, input().split(",")))
strength = int(input())
 
 
def climb(idxs, direction):
    # 找到第一个地面位置
    j = 0
    while j < len(heights) and heights[j] != 0:
        j += 1
 
    # 上山体力消耗
    # upCost = 0
    # 下山体力消耗
    # downCost = 0
 
    # 攀登体力总消耗（包括上山，下山）
    cost = 0
 
    for i in range(j + 1, len(heights)):
        # 如果遇到了新的地面，则从新的地面位置重新计算攀登消耗的体力
        if heights[i] == 0:
            cost = 0
            # upCost = 0
            # downCost = 0
            continue
 
        # diff记录高度差
        diff = heights[i] - heights[i - 1]
 
        if diff > 0:
            # 如果过程是上坡
            cost += diff * 3
            # upCost += diff * 2  # 则上山时，体力消耗 = 高度差 * 2
            # downCost += diff  # 相反的下山时，体力消耗 = 高度差 * 1
 
            # 由于 height[i] > heights[i-1]，因此如果 height[i] > heights[i+1] 的话，位置 i 就是山顶
            if i + 1 >= len(heights) or heights[i] > heights[i + 1]:
                # 计算攀登此山顶的上山下山消耗的体力和
                if cost < strength:
                    # if upCost + downCost <= strength:
                    # 如果不超过自身体力，则可以攀登
                    if direction:
                        idxs.add(i)
                    else:
                        idxs.add(len(heights) - i - 1)  # 需要注意，逆序heights数组后，我们对于的山峰位置需要反转
 
        elif diff < 0:
            # 如果过程是下坡
            cost -= diff * 3
            # upCost -= diff  # 则上山时，体力消耗 = 高度差 * 1
            # downCost -= diff * 2  # 相反的下山时，体力消耗 = 高度差 * 2
            # heights[i] < heights[i-1]，因此位置i不可能是山顶
 
 
# 算法入口
def getResult():
    # 记录可攀登的山峰索引
    idxs = set()
 
    # 正向攀登
    climb(idxs, True)
 
    # 逆序攀登
    heights.reverse()
    climb(idxs, False)
 
    return len(idxs)
 
 
# 算法调用
print(getResult())
```

8. 园区参观路径 dfs

**题目描述**
```
园区某部门举办了Family Day，邀请员工及其家属参加；
将公司园区视为一个矩形，起始园区设置在左上角，终点园区设置在右下角；
家属参观园区时，只能向右和向下园区前进，求从起始园区到终点园区会有多少条 不同的 参观路径。
```
**输入描述**
```
第一行为园区的长和宽；
后面每一行表示该园区是否可以参观，0表示可以参观，1表示不能参观
```
**输出描述**
```
输出为不同的路径数量
```
**用例**
```
输入
3 3
0 0 0
0 1 0
0 0 0
输出 2
说明 无
```
**代码**
```python
class Solution:

    def solve(self, m, n, matrix):
        ans = 0

        def dfs(x, y):
            nonlocal ans
            if x == m - 1 and y == n - 1:
                ans += 1
                return

            for dx, dy in [(0, 1), (1, 0)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] != 1:
                    dfs(nx, ny)

        dfs(0, 0)
        return ans


s = Solution()
print(s.solve(3,3,[[0,0,0],[0,0,0],[0,0,0]]))
```

9. 部门人力分配 二分+双指针

**题目描述**
```
部门在进行需求开发时需要进行人力安排。
当前部门需要完成 N 个需求，需求用 requirements 表述，requirements[i] 表示第 i 个需求的工作量大小，单位：人月。
这部分需求需要在 M 个月内完成开发，进行人力安排后每个月人力时固定的。
目前要求每个月最多有2个需求开发，并且每个月需要完成的需求不能超过部门人力。
请帮助部门评估在满足需求开发进度的情况下，每个月需要的最小人力是多少？
```
**输入描述**
```
输入为 M 和 requirements，M 表示需求开发时间要求，requirements 表示每个需求工作量大小，N 为 requirements长度，
1 ≤ N/2 ≤ M ≤ N ≤ 10000
1 ≤ requirements[i] ≤ 10^9
```
**输出描述**
```
对于每一组 测试数据 ，输出部门需要人力需求，行末无多余的空格
```
**用例**
```
输入 3
3 5 3 4
输出 6
说明
输入数据两行，
第一行输入数据3表示开发时间要求，
第二行输入数据表示需求工作量大小，
输出数据一行，表示部门人力需求。
当选择人力为6时，2个需求量为3的工作可以在1个月里
完成，其他2个工作各需要1个月完成。可以在3个月内完
成所有需求。
当选择人力为5时，4个工作各需要1个月完成，一共需要
4个月才能完成所有需求。
因此6是部门最小的人力需求。
```
**代码**
```python
class Solution:

    def solve(self, n, nums):
        l, r = max(nums), max(nums) + min(nums)
        while l < r:
            mid = (l + r) >> 1
            if self.get_res(mid, nums, n):
                r = mid
            else:
                l = mid + 1
        return l

    def get_res(self, target, nums, n):
        nums.sort()
        cnt = 0
        l, r = 0, len(nums) - 1
        while l < r:
            if nums[l] + nums[r] <= target:
                l += 1
                r -= 1
                cnt += 1
            else:
                r -= 1
                cnt += 1
        cnt += 1 if l == r else 0
        return True if cnt <= n else False


s = Solution()
print(s.solve(3,[3,5,3,4]))
```

10. 结对编程 二叉搜索树/暴力

**题目描述**
```
某部门计划通过结队编程来进行 项目开发 ，
已知该部门有 N 名员工，每个员工有 独一无二 的职级，每三个员工形成一个小组进行结队编程，结队分组规则如下：
从部门中选出序号分别为 i、j、k 的3名员工，他们的职级分贝为 level[i]，level[j]，level[k]，
结队小组满足 level[i] < level[j] < level[k] 或者 level[i] > level[j] > level[k]，
其中 0 ≤ i < j < k < n。
请你按上述条件计算可能组合的小组数量。同一员工可以参加多个小组。
```
**输入描述**
```
第一行输入：员工总数 n
第二行输入：按序号依次排列的员工的职级 level，中间用空格隔开
限制：
1 ≤ n ≤ 6000
1 ≤ level[i] ≤ 10^5
```
**输出描述**
```
可能结队的小组数量
```
**用例**
```
输入 4
1 2 3 4
输出 4
说明 可能结队成的组合(1,2,3)、(1,2,4)、(1,3,4)、(2,3,4)
输入 3
5 4 7
输出 0
说明 根据结队条件，我们无法为该部门组建小组
```
**代码**
```python
class Solution:

    def solve(self, n, nums):
        total = 0
        for i in range(1, n-1):
            leftsmallercnt = 0
            leftbiggercnt = 0
            for j in range(i):
                if nums[j] < nums[i]:
                    leftsmallercnt += 1
                else:
                    leftbiggercnt += 1
            rightsmallercnt = 0
            rightbiggercnt = 0
            for k in range(i+1, n):
                if nums[k] < nums[i]:
                    rightsmallercnt += 1
                else:
                    rightbiggercnt += 1
            total += leftsmallercnt * rightbiggercnt + leftbiggercnt * rightsmallercnt
        return total


s = Solution()
print(s.solve(4,[1,2,3,4]))
```

11. 数据单元的替换 递归

**题目描述**
```
将一个 csv 格式的数据文件中包含有单元格引用的内容替换为对应单元格内容的实际值。
comma separated values(CSV) 逗号分隔值，csv 格式的数据文件使用逗号 "," 作为分隔符将各单元的内容进行分隔。
```
**输入描述**
```
1. 输入只有一行数据，用逗号分隔每个单元格，行尾没有逗号。最多26个单元格，对应编号A~Z。
2. 每个单元格的内容包含字母和数字，以及使用 '<>' 分隔的单元格引用，例如：<A>表示引用第一个单元的值。
3. 每个单元格的内容，在替换前和替换后均不超过100个字符。
4. 引用单元格的位置不受限制，允许排在后面的单元格被排在前面的单元格引用。
5. 不存在循环引用的情况，比如下面这种场景是不存在的：
A单元恪：aCd<B>8U
B单元格：KAy<A>uZq0
6. 不存在多重 '<>' 的情况，一个单元只能引用一个其他单元格。比如下面这种场景是不存在的：
A单元格：aCdOu
B单元格：kAydzco
C单元格：y<<A><B>>d
```
**输出描述**
```
输出替换后的结果
```
**用例**
```
输入 1,2<A>00
输出 1,2100
说明 第二个单元中有对A单元的引用，A单元格的值为1，替换时，将
A单元的内容替代<A>的位置，并和其他内容合并。
输入 1<B>2,1
输出 112,1
说明 第一个单元中有对B单元的引用，B单元格的值为1，耆换时，将
第二个数据第单元的内容替代<B>的位置，并和其他内容合并
```
**代码**
```python
import re
 
regexp = re.compile(r"(<.*?>)")
 
# 输入获取
cells = input().split(",")
 
 
def changeCell(index):
    # 通过正则匹配出单元格内容中"引用字符串"
    matchers = regexp.findall(cells[index])
 
    # reference记录引用字符串
    for reference in matchers:
        # 引用单元格编号只能是A~Z的字母，即引用引用字符串长度只能是3，比如"<A>"
        if len(reference) != 3:
            return False
 
        # 引用单元格的编号
        reference_cellNum = reference[1]
        # 当前单元格的编号
        self_cellNum = chr(65 + index)
 
        # 引用单元格编号只能是A~Z的字母，且不能自引用
        if reference_cellNum < 'A' or reference_cellNum > 'Z' or reference_cellNum == self_cellNum:
            return False
 
        # 引用单元格的数组索引， 'A' -> 0  ... 'Z' -> 25
        reference_index = ord(reference_cellNum) - 65
 
        # 引用单元格编号不存在
        if reference_index >= len(cells):
            return False
 
        if not changeCell(reference_index):
            return False
 
        # 将单元格内容中的引用部分，替换为被引用的单元格的内容
        cells[index] = cells[index].replace(reference, cells[reference_index])
 
    return True
 
 
# 算法入口
def getResult():
    if len(cells) > 26:
        # 最多26个单元格，对应编号A~Z
        return "-1"
 
    for i in range(len(cells)):
        # 替换单元格中的引用
        if not changeCell(i):
            # 替换失败，则返回-1
            return "-1"
 
        if len(cells[i]) > 100:
            # 每个单元格的内容，在替换前和替换后均不超过100个字符
            return "-1"
 
        if not re.match(r"^[a-zA-Z0-9]+$", cells[i]):
            # 每个单元格的内容包含字母和数字
            return "-1"
 
    return ",".join(cells)
 
 
# 算法调用
print(getResult())
```

12. 高效货运 完全背包/暴力枚举

**题目描述**
```
老李是货运公司承运人，老李的货车额定载货重量为 wt。
现有两种货物：
货物 A 单件重量为 wa，单件运费利润为 pa
货物 B 单件重量为 wb，单件运费利润为 pb
老李每次发车时载货总重量刚好为货车额定的载货重量 wt，车上必须同时有货物 A 和货物 B ，货物A、B不可切割。
老李单次满载运输可获得的最高利润是多少？
```
**输入描述**
```
第一列输入为货物 A 的单件重量 wa
0 < wa < 10000
第二列输入为货物 B 的单件重量 wb
0 < wb < 10000
第三列输入为货车的额定载重 wt
0 < wt < 100000
第四列输入为货物 A 的单件运费利润 pa
0 < pa < 1000
第五列输入为货物 B 的单件运费利润 pb
0 < pb < 1000
```
**输出描述**
```
单次满载运输的最高利润
```
**用例**
```
输入 10 8 36 15 7
输出 44
说明 无
输入 1 1 2 1 1
输出 2
说明 无
```
**代码**
```python
class Solution:

    def solve(self, wa, wb, target, va, vb):
        target -= wa + wb
        total = va + vb
        w = [wa, wb]
        v = [va, vb]
        dp = [float('-inf')] * (target + 1)
        dp[0] = 0
        for i in range(2):
            for j in range(w[i], target+1):
                    dp[j] = max(dp[j], dp[j-w[i]] + v[i])
        return dp[-1] + total

s = Solution()
print(s.solve(1,1,2,1,1))
```

13. 找数字 位运算

**题目描述**
```
小扇和小船今天又玩起来了 数字游戏 ，
小船给小扇一个正整数 n（1 ≤ n ≤ 1e9），小扇需要找到一个比 n 大的数字 m，使得 m 和 n 对应的二进制中 1 的个数要相同，如：
4对应二进制100
8对应二进制1000
其中1的个数都为1个
现在求 m 的 最小值 。
```
**输入描述**
```
输入一个正整数 n（1 ≤ n ≤ 1e9）
```
**输出描述**
```
输出一个正整数 m
```
**用例**
```
输入 2
输出 4
说明
2的二进制10，
4的 二进制位 100，
1的个数相同，且4是满足条件的最小数
输入 7
输出 11
说明
7的二进制111，
11的二进制位1011，
1的个数相同，且11是满足条件的最小数
```
**代码**
```python
class Solution:

    def solve(self, n):
        tmp = n
        index = 0
        flag = False
        while n:
            if n & 1:
                flag = True
            elif not n & 1 and flag:
                break
            index += 1
            n >>= 1
        return tmp + 2 ** (index - 1)


s = Solution()
print(s.solve(2))
```

14. 中文分词模拟器 逻辑分析

**题目**
```
给定一个连续不包含空格的 字符串 ，该字符串仅包含英文小写字母及英文标点符号(逗号、分号、句号)，同时给定词库，对该字符串进行精确分
说明:
1.精确分词: 字符串分词后，不会出现重叠
即"ilovechina",不同词库可分割为",love,china”，“ilove,china”不能分割出现重叠的"ilove,china"i 出现重叠。
2.标点符号不成词，仅用于断句
3.词库: 根据外部 知识库 统计出来的常用词汇例:
dictionary =["i",“love”,“china”,“lovechina”,“ilove”]
4.分词原则: 采用分词顺序优先且最长匹配原则
“llovechina”假设分词结果[i,ilove,lo,love,ch,china,lovechina],则输出[ilove,china]
错误输出: [i,lovechina],原因:“ilove”>优先于"lovechina"成词
错误输出: [i,love,china],原因:“love”>"遵循最长匹配原则
```
**输入描述**
```
第一行输入待分词语句 S
第二行输入中文词库
字符串 S 长度限制: 0 < S.length < 256
词库长度限制: 1 < length < 100000
```
**输出描述**
```
按顺序输出分词结果
```
**示例1：**
```
输入：
ilovechina
i,love,china,ch,na,ve,lo,this,is,the,word
输出：
i,love,china
```
**示例2：**
```
输入：
iat
i,love,china,ch,na,ve,lo,this,is,the,word,beauti,tiful,ful
输出：
i,a,t
```
**示例3：**
```
输入：
ilovechina,thewordisbeautiful
i,love,china,ch,na,ve,lo,this,is,the,word,beauti,tiful,ful
输出：
i,love,china,the,word,is,beauti,fu
```
**代码**
```python
import re
 
# 输入获取
sentences = list(filter(lambda x: x != "", re.split(r"[,.;]", input())))
words = list(filter(lambda x: x != "", re.split(r"[,.;]", input())))
 
 
def getResult():
    # wordSet 记录词库词汇
    wordSet = set(words)
    # ans记录最终分词结果
    ans = []
 
    while len(sentences) > 0:
        # 待分词的句子
        sentence = sentences.pop(0)
 
        r = len(sentence)
        while r > 0:
            # 截取句子 [0,r) 范围子串词汇, 这样的就能实现优先最长匹配，并且由于是必须从0索引开始截取，因此满足了分词顺序优先
            fragment = sentence[0:r]
 
            # 若词库中是否存在该子串词汇
            if fragment in wordSet:
                # 则将对应子串词汇纳入结果
                ans.append(fragment)
                wordSet.remove(fragment)  # 我理解词库中每个词汇只能使用一次，因此这里将词库中使用过的词汇移除
 
                # 若子串词汇只是句子部分，则句子剩余部分还要继续去词库中查找
                if r < len(sentence):
                    sentences.insert(0, sentence[r:])
 
                break
 
            r -= 1
 
        # 没有在词库中找到对应子串词汇，则输出单个字母
        if r == 0:
            # 注意，这里只放一个字母到结果中，句子剩余部分继续去词库中查找
            ans.append(sentence[0])
 
            if len(sentence) > 1:
                sentences.insert(0, sentence[1:])
 
    return ",".join(ans)
 
 
print(getResult())
```

15. 符号运算 栈

**题目描述**
```
给定一个表达式，求其分数计算结果。
表达式的限制如下：
1. 所有的输入数字皆为正整数（包括0）
2. 仅支持四则运算（+-*/）和括号
3. 结果为整数或分数，分数必须化为最简格式（比如6，3/4，7/8，90/7）
4. 除数可能为0，如果遇到这种情况，直接输出"ERROR"
5. 输入和最终计算结果中的数字都不会超出整型范围
用例输入一定合法，不会出现 括号匹配 的情况
```
**输入描述**
```
字符串 格式的表达式，仅支持+-*/，数字可能超过两位，可能带有空格，没有负数
长度小于200个字符
```
**输出描述**
```
表达式结果，以最简格式表达
如果结果为整数，那么直接输出整数
如果结果为负数，那么分子分母不可再约分，可以为假分数，不可表达为带分数
结果可能是负数，符号放在前面
```
**用例**
```
输入 1 + 5 * 7 / 8
输出 43/8
说明 无
输入 1 / (0 - 5)
输出 -1/5
说明 符号需要提到最前面
输入 1 * (3*4/(8-(7+0)))
输出 12
说明 注意括号可以多重嵌套
```
**代码**
```python
class Num:
    def __init__(self, up, down):
        self.up = up
        self.down = down

class Sign:
    def __init__(self, value):
        self.value = value
        if value in ['*', '/']:
            self.pri = 3
        elif value in ['+', '-']:
            self.pri = 2
        else:
            self.pri = 1

class Solution:

    def solve(self, strs):
        sign_stack, num_stack, num_cache = [], [], []
        for x in strs:
            if x.isdigit():
                num_cache.append(x)
            else:
                sign = Sign(x)
                if sign.value == '(':
                    sign_stack.append(sign)
                    continue
                elif sign.value == ')':
                    if num_cache:
                        num = Num(int(''.join(num_cache)), 1)
                        num_cache = []
                        num_stack.append(num)
                    while sign_stack[-1].value != '(':
                        num2 = num_stack.pop()
                        num1 = num_stack.pop()
                        pre_sign = sign_stack.pop()
                        cur_num = self.get_cal(num1, num2, pre_sign)
                        if cur_num == 'ERROR':
                            return cur_num
                        num_stack.append(cur_num)
                    sign_stack.pop()
                    continue

                num = Num(int(''.join(num_cache)), 1)
                num_cache = []
                num_stack.append(num)
                while sign_stack and sign.pri <= sign_stack[-1].pri:
                    num2 = num_stack.pop()
                    num1 = num_stack.pop()
                    pre_sign = sign_stack.pop()
                    cur_num = self.get_cal(num1, num2, pre_sign)
                    if cur_num == 'ERROR':
                        return cur_num
                    num_stack.append(cur_num)
                sign_stack.append(sign)



        while sign_stack and num_stack:
            num2 = num_stack.pop()
            num1 = num_stack.pop()
            pre_sign = sign_stack.pop()
            cur_num = self.get_cal(num1, num2, pre_sign)
            if cur_num == 'ERROR':
                return cur_num
            num_stack.append(cur_num)
        final_num = num_stack[0]
        if final_num.up < 0 and final_num.down < 0:
            final_sign = ''
        elif final_num.up > 0 and final_num.down > 0:
            final_sign = ''
        else:
            final_sign = '-'
        gcd_num = self.gcd(abs(final_num.up), abs(final_num.down))
        if abs(final_num.down) == gcd_num:
            return final_sign + str(abs(final_num.up) // gcd_num)
        else:
            return final_sign + str(abs(final_num.up) // gcd_num) + '/' + str(abs(final_num.down) // gcd_num)

    def gcd(self, a, b):
        while b:
            a, b = b, a % b
        return a

    def get_cal(self, num1, num2, sign):
        if sign.value == '+':
            cur_up = num1.up * num2.down + num1.down * num2.up
            cur_down = num1.down * num2.down
        elif sign.value == '-':
            cur_up = num1.up * num2.down - num1.down * num2.up
            cur_down = num1.down * num2.down
        elif sign.value == '*':
            cur_up = num1.up * num2.up
            cur_down = num1.down * num2.down
        else:
            if num2.up == 0:
                return 'ERROR'
            cur_up = num1.up * num2.down
            cur_down = num1.down * num2.up
        return Num(cur_up, cur_down)


s = Solution()
print(s.solve('1*(3*4/(8-(7+6)))'))
```

16. 根据IP查找城市 逻辑分析

**题目**
```
某业务需要根据终端的 IP地址 获取该终端归属的城市，可以根据公开的IP地址池信息查询归属城市地址池格式如下: 城市名=起始IP，结束IP
起始和结束地址按照英文逗号分隔，多个地址段采用英文分号分隔。比如:
City1=1.1.1.1,1.1.1.2;City1=1.1.1.1,1.1.1.16;City2=3.3.3.3,4.4.4.4;City3=2.2.2.2,6.6.6.6一个城市可以有多个IP段，比如City1有2个IP段城市间也可
包含关系，如City3的IP段包含City2的IP段范围
现在要根据输入的IP列表，返回最佳匹配的城市列表
注:最佳匹配即包含待查询P且长度最小的IP段，比如例子中
3.4.4.4 最佳匹配是City2=3.3.3.3,4.4.4.4，
5.5.5.5的最佳匹配是City3=2.2.2.2,6.6.6.6
```
**输入描述**
```
输入共2行。
第一行为城市的IP段列表，多个IP段采用英文分号， 分隔，IP段列表最大不超过500000。城市名称只包含 英文字母 、数字和下划线。最多不超
100000个。IP段包含关系可能有多层，但不超过100层。
第二行为查询的IP列表，多个IP采用英文逗号“，分隔，最多不超过10000条
```
**输出描述**
```
最佳匹配的城市名列表，采用英文逗号，分隔，城市列表长度应该跟查询的IP列表长度一致。
备注
。无论是否查到匹配正常都要输出分隔符。举例: 假如输入IP列表为IPa,IPb，两个IP均未有匹配城市，此时输出为","即只有一个逗号分隔符，两个
空;
可以假定用例中的所有输入均合法，IP地址均为合法的ipv4地址，满足(1/255),(0/255)(0/255,0/255)的格式，且可以假定用例中不会出现组播和广播
```
**示例1：**
```
输入:
City1=1.1.1.1,1.1.1.2;City1=1.1.1.1,1.1.1.16;City2=3.3.3.3,4.4.4.4;City3=2.2.2.2,6.6.6.6
3.4.4.4,5.5.5.5
输出：
City2,City3
```
**思路**
```
1：题目比较核心的一个点：【起始IP，结束IP】，这里我们首先要做的一个事，就是拿到这个区间内的所有IP，一般的ip表达是 xxx.xxx.xxx.xxx 数字组成，每个数字的最大上限为255，这样我们其实可以用一个8位的二进制数组来表达每个数组，再将四个数字的对应二进制数组合并，这样我
以得到一个正整数，用这个正整数，我们就可以很方便的获取对应其中的IP了。
```
**代码**
```python
class Solution:
    def trans(self, ip):
        ips = [int(x) for x in ip.split('.')]
        ans = 0
        for i in range(4):
            ans <<= 8
            ans |= ips[i]
        return ans

    def solve(self, citys, targets):
        mp = {}
        city_name = set()
        citys_list = citys.split(';')
        for city in citys_list:
            name = city.split('=')[0]
            city_name.add(name)
            ip_range = city.split('=')[1]
            start, end = self.trans(ip_range.split(',')[0]), self.trans(ip_range.split(',')[1])
            if name not in mp:
                mp[name] = [[start, end]]
            else:
                mp[name].append([start, end])
        target_list = targets.split(',')
        ans = ''
        for target in target_list:
            out = ''
            size = float('inf')
            cur_city = None
            target_num = self.trans(target)
            for city in city_name:
                for range in mp[city]:
                    if range[0] <= target_num and range[1] >= target_num:
                        if range[1] - range[0] < size:
                            size = range[1] - range[0]
                            out = city
                        elif range[1] - range[0] == size:
                            if city > cur_city:
                                out = city
                                cur_city = city
            ans += out + ','
        return ans[:-1]


s = Solution()
print(s.solve('City1=1.1.1.1,1.1.1.2;City1=1.1.1.1,1.1.1.16;City2=3.3.3.3,4.4.4.4;City3=2.2.2.2,6.6.6.6',
              '3.4.4.4,5.5.5.5'))
```

17. 文件缓存系统 哈希表+双向链表

**题目描述**
```
请设计一个文件 缓存系统 ，该文件缓存系统可以指定缓存的最大值（单位为字节）。
文件缓存系统有两种操作：
存储文件（put）
读取文件（get）
操作命令为：
put fileName fileSize
get fileName
存储文件是把文件放入文件缓存系统中；
读取文件 是从文件缓存系统中访问已存在，如果文件不存在，则不作任何操作。
当缓存空间不足以存放新的文件时，根据规则删除文件，直到剩余空间满足新的文件大小位置，再存放新文件。
具体的删除规则为：
文件访问过后，会更新文件的最近访问时间和总的访问次数，当缓存不够时，按照第一优先顺序为访问次数从少到多，第二顺序为时间从老到新的方式
件。
```
**输入描述**
```
第一行为缓存 最大值 m（整数，取值范围为 0 < m ≤ 52428800）
第二行为文件操作序列个数 n（0 ≤ n ≤ 300000）
从第三行起为文件操作序列，每个序列单独一行，文件操作定义为：
op file_name file_size
file_name 是文件名，file_size 是文件大小
```
**输出描述**
```
输出当前文件缓存中的文件名列表，文件名用英文逗号分隔，按字典顺序排序，如：
a,c
如果文件缓存中没有文件，则输出NONE
备注
1. 如果新文件的文件名和文件缓存中已有的文件名相同，则不会放在缓存中
2. 新的文件第一次存入到文件缓存中时，文件的总访问次数不会变化，文件的最近访问时间会更新到最新时间
3. 每次文件访问后，总访问次数加1，最近访问时间更新到最新时间
4. 任何两个文件的最近访问时间不会重复
5. 文件名不会为空，均为小写字母，最大长度为10
6. 缓存空间不足时，不能存放新文件
7. 每个文件大小都是大于 0 的整数
```
**用例**
```
输入
50
6
put a 10
put b 20
get a
get a
get b
put c 30
输出 a,c
说明 无
输入
50
1
get file
输出 NONE
说明 无
```
**代码**
**LFU**
```python
class Node:
    def __init__(self, key=None, value=None, freq=None):
        self.key = key
        self.value = value
        self.freq = freq
        self.next = None
        self.pre = None

class Solution:
    def __init__(self, capacity):
        self.keymap = {}
        self.freqmap = {}
        self.capacity = capacity
        self.cur_capacity = 0
        self.min_freq = 1
        self.head = []
        self.tail = []

    def solve(self, n, operations):
        for i in range(n):
            op = operations[i].split(' ')
            if len(op) == 2:
                self.get(op[1])
            elif len(op) == 3:
                self.put(op[1], int(op[2]))
        return ','.join(sorted(list(self.keymap.keys())))


    def insert_to_tail(self, node, freq):
        node.next = self.tail[freq-1]
        node.pre = self.tail[freq-1].pre
        self.tail[freq-1].pre.next = node
        self.tail[freq-1].pre = node


    def change_node_freq(self, node, pre_freq, cur_freq):
        if cur_freq not in self.freqmap:
            self.head.append(Node())
            self.tail.append(Node())
            self.head[-1].next = self.tail[-1]
            self.tail[-1].pre = self.head[-1]
            self.freqmap[cur_freq] = self.head[-1]
        if pre_freq:
            node.pre.next = node.next
            node.next.pre = node.pre
            if self.min_freq == pre_freq and not self.head[pre_freq - 1].next.value:
                self.min_freq = cur_freq
        if cur_freq < self.min_freq:
            self.min_freq = cur_freq
        self.insert_to_tail(node, cur_freq)

    def get(self, key):
        res = self.keymap.get(key, -1)
        if res == -1:
            pass
        else:
            res.freq += 1
            self.change_node_freq(res, res.freq - 1, res.freq)
            print(res.value)

    def remove_node(self):
        node = self.head[self.min_freq - 1].next
        node.pre.next = node.next
        node.next.pre = node.pre
        del self.keymap[node.key]
        if node.next.value == None:
            max_freq = max(list(self.freqmap.keys()))
            for i in range(1, max_freq+1):
                if self.head[i-1].next.value:
                    self.min_freq = i
                    break
            else:
                self.min_freq = 0

        return node.value

    def put(self, key, value):
        if key not in self.keymap:
            while self.cur_capacity + value > self.capacity:
                self.cur_capacity -= self.remove_node()
            new_node = Node(key, value, 1)
            self.change_node_freq(new_node, None, 1)
            self.cur_capacity += value
            self.keymap[key] = new_node


s = Solution(50)
print(s.solve(6, ['put a 10', 'put b 20', 'get a', 'get a', 'get b', 'put c 30']))
```

**LRU**
```python
class ListNode:
    def __init__(self, key=None, value=None):
        self.key = key
        self.value = value
        self.next = None
        self.pre = None

class LRUCache:

    def __init__(self, capacity: int):
        # 哈希表存储 key: node
        self.hashmap = {}
        # 容量
        self.capacity = capacity
        # 头节点
        self.head = ListNode()
        # 尾节点
        self.tail = ListNode()
        # 连接头尾节点
        self.head.next = self.tail
        self.tail.pre = self.head

    def move_to_tail(self, key):
        # 从哈希表中获取key对应node
        node = self.hashmap[key]
        # 断开node
        node.pre.next = node.next
        node.next.pre = node.pre
        # node插入尾节点之前
        node.next = self.tail
        node.pre = self.tail.pre
        self.tail.pre = node
        node.pre.next = node

    def get(self, key: int) -> int:
        # 从哈希表获取key对应结果
        res = self.hashmap.get(key, -1)
        if res == -1:
            # 不存在返回-1
            return -1
        else:
            # 将key对应node移到末尾
            self.move_to_tail(key)
            # 返回结果
            return res.value

    def put(self, key: int, value: int) -> None:
        # 如果key已存在在哈希表中
        if key in self.hashmap:
            # 更新哈希表key对应node的value
            self.hashmap[key].value = value
            # 将key对应node移到末尾
            self.move_to_tail(key)
        # key不存在于哈希表中
        else:
            # 如果当前哈希表长度已达到最大容量，需要删除一个最长未使用节点，也就是头节点的下一个节点
            if len(self.hashmap) == self.capacity:
                # 从哈希表中删除头节点下一个节点key对应的数据
                self.hashmap.pop(self.head.next.key)
                # 双向链表中删除该节点
                self.head.next = self.head.next.next
                self.head.next.pre = self.head
            # 定义一个新节点
            node = ListNode(key, value)
            # key: node 存储于哈希表中
            self.hashmap[key] = node
            # 新节点插入到尾节点之前
            node.next = self.tail
            node.pre = self.tail.pre
            self.tail.pre = node
            node.pre.next = node
```

18. 员工派遣 二分法

**题目**
```
某公司部门需要派遣员工去国外做项目。
现在，代号为 x 的国家和代号为 y 的国家分别需要 cntx 名和 cnty 名员工部门每个员工有一个员工号 (1,2,3,......)，工号连续，从 1开始。部长派遣
则: 规则1: 从 1,k中选择员工派遣出去
规则2: 编号为 x的倍数的员工不能去 x国，编号为 y 的倍数的员工不能去y 国
问题
找到最小的k，使得可以将编号在 [1,k] 中的员工分配给 x 国和 y 国，且满足 x 国和 y 国的需求
```
**输入描述**
```
四个整数 x,y,cntx,cnty。
2 < x < y < 30000
x和y 一定是 质数
1 < cntx, cnty < 10^9
cntx + cnty < 10^9
```
**输出描述**
```
满足条件的最小的 k
```
**示例1：**
```
输入：
2 3 3 1
输出：
5
说明: 输入中：
2 表示国家代号 2
3 表示国家代号 3
3 表示国家 2 需要3 个人
1 表示国家 3 需要1个人
输出的5表示k最小为5
```
**思路**
```
1：C卷的场景题特别多，我们需要阅读题干来获取题目想表达的真是题意。这个题目的最后一句：【使得可以将编号在 [1,k] 中的员工分配给 x 国
且满足 x 国和 y 国的需求】，其实核心就是规则2：【编号为 x的倍数的员工不能去 x国，编号为 y 的倍数的员工不能去y 国】
2：那这样的话，其实就是求1~k中，是x的倍数的个数（可以去y国），和是y的倍数的个数（可以去x国），如果既不是x也不是y的倍数，也需要纳
3：首先，1~k中能够被x整除的数个数为 k/x, 能够被y整除的个数为k/y，这个属于数学的前置知识了。其次，1~k中,既能被x整除，也能够被y整除的
就是 k/x*y。这样的话，既不是x也不是y的倍数，就是 k-k/x-k/y-k/x*y。
4：我们主要求的就是【既不是x也不是y的倍数】，因为这个数可以分给两者。从直觉上来说，k越大，肯定数字越多，满足条件的可能性也就越大
们可以使用二分法来判定当前的数字是否满足条件。
```
**代码**
```python
class Solution:

    def solve(self, x, y, cx, cy):
        left = 0
        right = pow(10, 9)
        while left < right:
            mid = (left + right) >> 1
            # cx - mid//y + mid//(x*y) 求的是x用y的倍数去填，但是不用公倍数，还需要几个非x y倍数的人
            # cy - mid//x + mid//(x*y) 求的是y用x的倍数去填，但是不用公倍数，还需要几个非x y倍数的人
            # 负数代表另一家公司倍数的人够用，不需要额外的人，为0
            target = max(0, cx - mid//y + mid//(x*y)) + max(0, cy - mid//x + mid//(x*y))
            # 如果非x y倍数的人大于等于需要的，右边界更新为mid
            if mid - mid//x - mid//y + mid//(x*y) >= target:
                right = mid
            else:
                left = mid + 1
        return left

s = Solution()
print(s.solve(2,3,3,1))
```

19. 跳格子3 动态规划

**题目**
```
小明和朋友们一起玩跳格子游戏，每个格子上有特定的分数score = [1 -1-6 7 -17 7]，从起点score[0]开始，每次最大的步长为k，请你返回小明跳到
score[n-1]时，能得到的最大得分。
注
格子的总长度和步长的区间在[1，100000]
每个格了的分数在[-10000,10000]区间中
```
**输入描述**
```
6//第一行输入总的格了数量
1 -1 -6 7 -17 7/第二行输入每个格子的分数score[i]
2//第三行输入最大跳的步长k
```
**输出描述：**
```
一个整数代表最大得分。
```
**示例1：**
```
输入：
6
1 -1 -6 7 -17 7
2
输出：
14
```
**代码**
```python
class Solution:

    def solve(self, nums, k):
        n = len(nums)
        dp = [float('-inf')] * n
        dp[0] = nums[0]
        for i in range(1, k):
            dp[i] = nums[i] + max(dp[:i])
        for j in range(k, n):
            dp[j] = nums[j] + max(dp[j-k:j])
        return dp[-1]


s = Solution()
print(s.solve([1,-1,-6,7,-17,7], 2))
```

20. 贪吃的猴子 逻辑分析

**题目**
```
一只贪吃的猴子，来到一个果园，发现许多串香蕉排成一行，每串香蕉上有若干根香蕉。每串香蕉的根数由数组numbers给出。猴子获取香蕉，每
从行的开头或者未尾获取，并且只能获取N次，求猴子最多能获取多少根香蕉。
```
**输入描述**
```
第一行为数组numbers的长度
第二行为数组numbers的值每个数字通过空格分开
第三行输入为N，表示获取的次数
```
**输出描述**
```
按照题目要求能获取的最大数值
```
**示例1**
```
输入
7
1 2 2 7 3 6 1
3
输出
10
```
**示例2**
```
输入
3
1 2 3
3
输出
6
说明
全部 获取所有 的香蕉，因此最终根数为1+2+3 = 6
```
**示例3：**
```
输入
4
4 2 2 3
2
输出
7
说明
第一次获取香蕉为行的开头，第二次获取为行的末尾，因此最终根数为4+3 =7
```
**代码**
```python
class Solution:

    def solve(self, n, bananas, m):
        tmp = 0
        for i in range(m):
            tmp += bananas[i]
        res = tmp
        left = m-1
        right = n-1
        while left >= 0:
            tmp += bananas[right] - bananas[left]
            if tmp > res:
                res = tmp
            left -= 1
            right -= 1
        return res

s = Solution()
print(s.solve(6, [2,4,3,2,10,1], 2))
```

21. 项目排期 二分+回溯

**题目描述**
```
项目组共有 N 个开发人员，项目经理接到了 M 个独立的需求，每个需求的工作量不同，且每个需求只能由一个开发人员独立完成，不能多人合作。
假定各个需求直接无任何先后 依赖关系 ，请设计算法帮助项目经理进行工作安排，使整个项目能用最少的时间交付。
```
**输入描述**
```
第一行输入为 M 个需求的工作量，单位为天，用逗号隔开。
例如：
X1 X2 X3 ... Xm
表示共有 M 个需求，每个需求的工作量分别为X1天，X2天，...，Xm天。其中：
0 < M < 30
0 < Xm < 200
第二行输入为项目组人员数量N
例如：
5
表示共有5名员工，其中 0 < N < 10
```
**输出描述**
```
最快完成所有工作的天数
例如：
25
表示最短需要25天完成所有工作
```
**用例**
```
输入
6,2,7,7,9,3,2,1,3,11,4
2
输出
28
```
**代码**
```python

# 输入获取
balls = list(map(int, input().split()))
n = int(input())
 
 
def check(index, buckets, limit):
    """
    :param index: 要被装入球的（balls）索引
    :param buckets: 桶数组，buckets[i]记录第i个桶的已经使用的容量
    :param limit: 每个桶的最大容量，即限制
    :return: k个桶（每个桶容量limit）是否可以装下所有balls
    """
    if index == len(balls):
        # 如果balls已经取完，则说明k个limit容量的桶，可以装完所有balls
        return True
 
    # select是当前要装的球
    selected = balls[index]
 
    # 遍历桶
    for i in range(len(buckets)):
        # 剪枝优化
        if i > 0 and buckets[i] == buckets[i - 1]:
            continue
 
        # 如果当前桶装了当前选择的球后不超过容量限制，则可以装入
        if selected + buckets[i] <= limit:
            buckets[i] += selected
            # 递归装下一个球
            if check(index + 1, buckets, limit):
                return True
            # 如果这种策略无法装完所有球，则回溯
            buckets[i] -= selected
 
    return False
 
 
# 算法入口
def getResult():
    # 这里对balls降序，有利于降低后面回溯操作的复杂度
    balls.sort(reverse=True)
 
    # 分范围：即每个桶的容量最小，最大值
    low = balls[0]  # 桶至少要有max(balls)的容量
    high = sum(balls)  # 当只有一个桶时，此时该桶容量要装下所有balls
 
    # 记录题解
    ans = high
 
    # 二分找中间值作为桶容量
    while low <= high:
        mid = (low + high) >> 1
 
        if check(0, [0] * n, mid):
            # 如果k个mid容量的桶，可以装完所有balls，那么mid容量就是一个可能解，但不一定是最优解，我们应该尝试更小的桶容量
            ans = mid
            high = mid - 1
        else:
            # 如果k个mid容量的桶，无法装完所有balls，那么说明桶容量取小了，我们应该尝试更大的桶容量
            low = mid + 1
 
    return ans
 
 
# 算法调用
print(getResult())
 
```

22. 亲子游戏 BFS

**题目描述**
```
宝宝和妈妈参加亲子游戏，在一个二维矩阵（N*N）的格子地图上，宝宝和妈妈抽签决定各自的位置，地图上每个格子有 不同的 糖果数量，部分格子有障碍物。
游戏规则 是妈妈必须在最短的时间（每个单位时间只能走一步）到达宝宝的位置，路上的所有糖果都可以拿走，不能走障碍物的格子，只能上下左右走。
请问妈妈在最短到达宝宝位置的时间内最多拿到多少糖果（优先考虑最短时间到达的情况下尽可能多拿糖果）。
```
**输入描述**
```
第一行输入为 N，N 表示二维矩阵的大小
之后 N 行，每行有 N 个值，表格矩阵每个位置的值，其中：
-3：妈妈
-2：宝宝
-1：障碍
≥0：糖果数（0表示没有糖果，但是可以走）
```
**输出描述**
```
输出妈妈在最短到达宝宝位置的时间内最多拿到多少糖果，行末无多余空格
备注
地图最大 50*50
```
**用例**
```
输入
4
3 2 1 -3
1 -1 1 1
1 1 -1 2
-2 1 2 3
输出 9
说明
此地图有两条 最短路径 可到达宝宝位置，绿色线和黄
色线都是最短路径6步，但黄色拿到的糖果更多，9个。
输入
4
3 2 1 -3
-1 -1 1 1
1 1 -1 2
-2 1 -1 3
输出 -1
说明
此地图妈妈无法到达宝宝位置
```
**代码**
```python
class Solution:

    def solve(self, n, matrix):
        queue = []
        total = 0
        for x in range(n):
            for y in range(n):
                if matrix[x][y] == -3:
                    queue.append([x, y, 0])
                    break
        flag = False
        while queue:

            if not flag:
                for _ in range(len(queue)):
                    node = queue.pop(0)
                    matrix[node[0]][node[1]] = -1
                    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nx, ny = node[0] + dx, node[1] + dy
                        if 0 <= nx < n and 0 <= ny < n and matrix[nx][ny] != -1:
                            queue.append([nx, ny, matrix[nx][ny] + node[2]])
                            if matrix[nx][ny] == -2:
                                flag = True
            else:
                for _ in range(len(queue)):
                    node = queue.pop(0)
                    if matrix[node[0]][node[1]] == -2:
                        total = max(total, node[2] + 2)
        return total if total else -1


s = Solution()
print(s.solve(4, [[3,2,1,-3], [-1,-1,1,1],[1,1,-1,2],[-2,1,-1,3]]))
```

23. 可处理的最大任务数 优先队列

*题目**
```
在某个项目中有多个任务(用 tasks 数组表示) 需要您进行处理，其中 tasks[i] = [si, ei] 你可以在 s[i] <= day <= e[i]中的任意天处理该任务。请返回你
理的最大任务数。
注:一天可以完成一个任务的处理
```
**输入描述:** 
```
第一行为任务数量n,1<= n<= 100000。
后面n行表示各任务的开始时间和终止时间，用 si和ei表示，1= si<= ei<=100000.
```
**输出描述:**
```
输出为一个整数，表示可以处理的最大任务数
```
**示例1**
```
输入:
3
1 1
1 2
1 3
输出:
3
说明: 第一天处理任务 1，第二天处理任务 2，第三天处理任务 3。
```
**解析**
```
1、统计输入的所有任务的时间段，仅按照结束时间降序，得到数组ranges
2、定义一个优先队列pq，仅用于保存任务的开始时间（开始时间越大，优先级越高），我们可以认为优先队列中保存的任务（的开始时间）对应的结束时间都是相同的，我们定义这个公共结束时间为pq_end
3、遍历ranges，得到每一个任务的开始，结束时间range：[start, end]，然后比较遍历到任务的end 和 优先队列中所有任务的公共结束时间pq_end：
如果 end < pq_end，则在end ~ pq_end 这段间隔时间内，我们可以从pq中挑选出pq_end - end 个 较短任务进行执行，执行前需要检查 对应任务的开始时间 start <= pq_end，若不满足则不执行。每执行一个任务，则pq_end -= 1，count += 1（count是已执行的任务数量）。当pq_end == end时，则将当前遍历的任务的start 加入 优先队列。
```
**代码**
```python
import heapq
import sys
 
# 输入获取
n = int(input())
ranges = [list(map(int, input().split())) for _ in range(n)]
 
 
# 算法入口
def getResult():
    # 将所有任务按照结束时间降序
    ranges.sort(key=lambda x: -x[1])
 
    # 优先队列中记录的是任务的开始时间，并且开始时间越大，优先级越高
    # 由于heapq默认是数值越小，优先级越大，因此这里存入负数的开始时间到pq
    pq = []
 
    # 优先队列中记录的是结束时间相同的任务的开始时间，pq_end就是优先队列中任务的相同结束时间
    pq_end = sys.maxsize
 
    # 最大任务数
    count = 0
 
    # 当前任务的开始和结束时间
    for start, end in ranges:
        # 如果当前任务的结束时间 小于 优先队列中记录的任务的结束时间，则两个结束时间之间的间隔时间段，可以处理一些紧急任务
        while len(pq) > 0 and end < pq_end:
            # 这里的紧急任务即指时间短的任务，即开始时间比较大的任务
            if -heapq.heappop(pq) <= pq_end:
                # 如果紧急任务的开始时间未超过其结束时间，则可以执行
                count += 1
                pq_end -= 1  # 一个时刻只执行一个任务
 
        # 间隔时间消耗完后，优先队列中的任务的结束时间全部更新为当前任务的结束时间
        heapq.heappush(pq, -start)
        pq_end = end
 
    # 收尾处理
    while len(pq) > 0:
        if -heapq.heappop(pq) <= pq_end:
            count += 1
            pq_end -= 1
 
    return count
 
 
# 算法调用
print(getResult())
```

24. 推荐多样性 逻辑分析

**题目**
```
推荐多样性需要从多个列表中选择元素，一次性要返回N屏数据(窗口数量)，每屏展示K个元素(窗口大小)，选择策略
1.各个列表元素需要做穿插处理，即先从第一个列表中为每屏选择一元素，再从第二个列表中为每屏选择一个元素，依次类推
2.每个列表的元素尽量均分为N份，如果不够N个，也要全部分配完，比如下面的例子:
(1)从第一个列表中选择4条0 12 3，分别放到4个窗口中
(2)从第二个列表中选择4条10 11 12 13，分别放到4个窗口中
(3)从第三个列表中选择4条20 21 22 23，分别放到4个窗口
(4)再从第一个列表中选择4条4 5 6 7，分别放到4个窗口中
(5)再从第一个列表中选择，由于数量不足4条，取剩下的2条，放到窗1和窗口2(6)再从第二个列表中选择，由于数量不足4条并且总的元素数达到窗
求，取18 19放到窗口3和窗口4
```
**输入描述**
```
第一行输入为N，表示需要输出的窗口数量，取值范围[1,10]
第二行输入为K，表示每个窗口需要的 元素数量 Q，取值范用[1,100]之后的行数不定(行数取值范围[1,10]，表示每个列表输出的元素列表。元素之
格分隔，已经过准序外理，每人列表输出的元素数量取值范围[1,100]
```
**输出描述**
```
输出元素列表，元素数量=窗口数量“窗口大小，元素之间以空格分隔，多个窗口合并为一个列表输出，参考样例:先输出窗口1的元素列表，再输出
元素列表，再输出窗口3的元素列表，最后输出窗口4的元素列表
```
**示例1**
```
输入
4
7
0 1 2 3 4 5 6 7 8 9
10 11 12 13 14 15 16 17 18 19
20 21 22 23 24 25 26 27 28 29
输出
0 10 20 4 14 24 8 1 11 21 5 15 25 9 2 12 22 6 16 26 18 3 13 23 7 17 27 19
说明：
1.每个列表会保证元素数最满足窗口要求，不需要考虑元素不足情况
2.每个列表的元素已去重，不需要考虑元素重复情况
3.每个列表的元素列表均不为空，不需要考虑列表为空情况
4.每个列表的元素列表已经过排序处理，输出结果要保证不改变同一个列表的元素顺序
5.每个列表的元素数量可能是 不同的
```

**代码**
```python
# 输入获取
n = int(input())
k = int(input())
 
lists = []
while True:
    try:
        lists.append(list(map(int, input().split())))
    except:
        break
 
 
# 算法入口
def getResult():
    # 窗口矩阵，k行n列，每一列对应一个窗口，这里将二维矩阵一维化，方便后面赋值
    windows = [0] * (k * n)
    # 窗口矩阵中正在赋值的索引位置
    idx = 0
    # 正在从第level个列表中取值
    level = 0
 
    # 当窗口矩阵填满后，结束循环
    while idx < len(windows):
        # 当前轮次是否发生了"借"动作
        flag = False
 
        # 从第level个列表中取前n个元素
        for _ in range(n):
            windows[idx] = lists[level].pop(0)
            idx += 1
 
            # 如果第level个列表没有元素了，则继续切到下一个列表中"借"
            if len(lists[level]) == 0 and len(lists) > 1:
                lists.pop(level)  # 删除空列表
                level %= len(lists)  # 防止越界
                flag = True  # 发生了"借"动作
 
        #  如果没有发生"借"动作，则需要切到下一行
        if not flag:
            level = (level + 1) % len(lists)  # 防止越界
 
    ans = []
 
    # 遍历列号
    for j in range(n):
        # 遍历行号
        for i in range(k):
            # 按列收集元素
            ans.append(windows[i * n + j])
 
    return " ".join(map(str, ans))
 
 
# 算法调用
print(getResult())
```

25. 两个字符串间的最短路径问题 动态规划

**题目描述**
```
给定两个 字符串 ，分别为字符串 A 与字符串 B。
例如 A字符串为 "ABCABBA"，B字符串为 "CBABAC" 可以得到下图 m * n 的 二维数组 ，定义原点为(0,0)，终点为(m,n)，水平与垂直的每一条边距
射成坐标系如下图。
从原点 (0,0) 到 (0,A) 为水平边，距离为1，从 (0,A) 到 (A,C) 为垂直边，距离为1；
假设两个字符串同一位置的两个字符相同，则可以作一个斜边，如 (A,C) 到 (B,B) 最短距离为斜边，距离同样为1。
作出所有的斜边如下图，(0,0) 到 (B,B) 的距离为：1 个水平边 + 1 个垂直边 + 1 个斜边 = 3。
```
**输入描述**
```
空格分割的两个字符串 A 与字符串 B
字符串不为"空串"
字符格式满足正则规则：[A-Z]
字符串长度 < 10000
```
**输出描述**
```
原点到终点的最短距离
```
**用例**
```
输入 ABC ABC
输出 3
说明 无
输入 ABCABBA CBABAC
输出 9
说明 无
```
**代码**
```python
class Solution:

    def solve(self, str1, str2):
        dp = [i for i in range(len(str1) + 1)]
        pre = dp[0]
        for j in range(len(str2)):
            for i in range(len(str1) + 1):
                tmp = dp[i]
                if i == 0:
                    dp[i] += 1
                else:
                    if str2[j] == str1[i-1]:
                        dp[i] = pre + 1
                    else:
                        dp[i] = min(dp[i-1], dp[i]) + 1
                pre = tmp
        return dp[-1]


s = Solution()
print(s.solve('ABCABBA', 'CBABAC'))
```

26. 跳马 BFS

**题目描述**
```
马是象棋（包括 中国象棋 和国际象棋）中的棋子，走法是每步直一格再斜一格，即先横着或者直者走一格，然后再斜着走一个对角线，可进可退，
界，俗称"马走日"字。
给定 m 行 n 列的棋盘（网格图），棋盘上只有棋子象棋中的棋子“马”，并且每个棋子有等级之分，等级为 k 的马可以跳 1~k 步（走的方式与象棋中“马
样，不可以超出棋盘位置），问是否能将所有马跳到同一位置，如果存在，输出最少需要的总步数（每匹马的步数相加），不存在则输出-1。
注：允许不同的马在跳的过程中跳到同一位置，坐标为（x,y）的马跳一次可以跳到的坐标为：(x+1, y+2)，(x+1, y-2)，(x+2, y+1)，(x+2, y-1)，(x-1, y
y-2)，(x-2, y+1)，(x-2, y-1)，的格点上，但是不可以超出棋盘范围。
```
**输入描述**
```
第一行输入m，n，代表 m 行 n 列的网格图棋盘（1 ≤ m, n ≤ 25）
接下来输入 m 行 n 列的网格图棋盘，如果第 i 行，第 j 列的元素为 "." ，代表此格点没有棋子，如果为数字 k（1 ≤ k ≤ 9），代表此格点存在等级为 k 
```
**输出描述**
```
输出最少需要的总步数（每匹马的步数相加），不存在则输出-1。
```
**用例**
```
输入
3 2
..
2.
..
输出 0
说明 只有一匹马，不需要跳动
输入
3 5
47.48
4744.
7....
输出 17
说明 无
```
**代码**
```python
import sys
 
# 输入获取
m, n = map(int, input().split())  # 棋盘行数, 棋盘列数
grid = [input() for _ in range(m)]  # 棋盘矩阵
stepGrid = [[0] * n for _ in range(m)]  # 最小步数和矩阵，stepMap[i][j]记录各个马走到棋盘(i,j)位置的最小步数之和
 
# 记录所有马都可达的公共位置坐标
reach = set()
for i in range(m):
    for j in range(n):
        reach.add(i * n + j)
 
# 马走日的偏移量
offsets = ((1, 2), (1, -2), (2, 1), (2, -1), (-1, 2), (-1, -2), (-2, 1), (-2, -1))
 
 
# 广搜
def bfs(sx, sy, k):
    global reach
 
    # 广搜队列
    # (sx,sy)为马所在初始位置，马到达初始位置需要0步
    queue = [(sx, sy, 0)]
 
    # 记录该马可以访问(sx,sy)位置
    vis = set()
    vis.add(sx * n + sy)  # 二维坐标一维化
 
    # k记录该马剩余可走步数
    while len(queue) > 0 and k > 0:
        # newQueue记录该马花费相同步数的可达的位置（即BFS按层遍历的层）
        newQueue = []
 
        # 按层BFS
        for x, y, step in queue:
            for offsetX, offsetY in offsets:
                # 马走日到达的新位置
                newX = x + offsetX
                newY = y + offsetY
 
                pos = newX * n + newY
 
                # 如果新位置越界或者已访问过，则不能访问
                if newX < 0 or newX >= m or newY < 0 or newY >= n or (pos in vis):
                    continue
 
                # 将新位置加入新层
                newQueue.append((newX, newY, step + 1))
 
                # 该马到达(newX, newY)位置最小步数为step+1, 由于该马首次到达(newX, newY)位置，因此step+1就是最小步数
                stepGrid[newX][newY] += step + 1
 
                # 记录该马访问过该位置，后续如果该马再次访问该位置，则不是最小步数
                vis.add(pos)
 
        queue = newQueue
        k -= 1  # 剩余步数减1
 
    # BFS完后，将公共可达位置reach和当前马可达位置vis取交集，交集部分就是新的公共可达位置
    reach &= vis
 
 
# 算法入口
def getResult():
    # 遍历棋盘
    for i in range(m):
        for j in range(n):
            # 如果棋盘(i,j)位置是马
            if grid[i][j] != '.':
                # 马的等级
                k = int(grid[i][j])
                # 对该马进行BFS走日
                bfs(i, j, k)
 
    # 如果所有马走完，发现没有公共可达位置
    if len(reach) == 0:
        return -1
 
    # 记录所有马都可达位置的最小步数和
    minStep = sys.maxsize
 
    for pos in reach:
        x = pos // n
        y = pos % n
        # (x,y)是所有马都可达的位置，stepMap[x][y]记录所有马到达此位置的步数和
        minStep = min(minStep, stepGrid[x][y])
 
    return minStep
 
 
# 算法调用
print(getResult())
```

27. 字符串拼接 递归+回溯

**题目描述**
```
给定 M（0 < M ≤ 30）个字符（a-z），从中取出任意字符（每个字符只能用一次）拼接成长度为 N（0 < N ≤ 5）的字符串，
要求相同的字符不能相邻，计算出给定的字符列表能拼接出多少种满足条件的字符串，
输入非法或者无法拼接出满足条件的字符串则返回0。
```
**输入描述**
```
给定的字符列表和结果 字符串长度 ，中间使用空格(" ")拼接
```
**输出描述**
```
满足条件的字符串个数
```
**用例**
```
输入 abc 1
输出 3
说明 给定的字符为a,b,c，结果字符串长度为1，可以拼接成a,b,c，共
3种
输入 dde 2
输出 2
说明 给定的字符为dde，结果字符串长度为2，可以拼接成de,ed，共
2种
```
**代码**
```python
class Solution:

    def solve(self, strs, k):
        used = [False] * len(strs)
        ans = 0
        str_list = list(strs)
        str_list.sort()

        def dfs(path, k):
            nonlocal ans
            nonlocal used
            if k == 0:
                ans += 1
            for i in range(len(str_list)):
                if used[i]:
                    continue
                if i > 0 and str_list[i] == str_list[i-1] and not used[i-1]:
                    continue
                if not path or str_list[i] != path[-1]:
                    used[i] = True
                    path.append(str_list[i])
                    dfs(path, k-1)
                    path.pop()
                    used[i] = False

        dfs([], k)
        return ans

s = Solution()
print(s.solve('dede', 3))
```

28. Wonderland 动态规划

**题目描述**
```
Wonderland是小王居住地一家很受欢迎的游乐园。Wonderland目前有4种售票方式，分别为一日票（1天）、三日票（3天）、周票（7天）和月票（3
每种售票方式的价格由一个数组给出，每种票据在票面时限内可以无限制地进行游玩。例如：
小王在第10日买了一张三日票，小王可以在第10日、第11日和第12日进行无限制地游玩。
小王计划在接下来一年多次游玩该游乐园。小王计划地游玩日期将由一个数组给出。
现在，请您根据给出地售票价格数组和小王计划游玩日期数组，返回游玩计划所需要地最低消费。
```
**输入描述**
```
输入为2个数组：
售票价格数组为costs，costs.length = 4，默认顺序为一日票、三日票、周票和月票。
小王计划游玩日期数组为days，1 ≤ days.length ≤ 365，1 ≤ days[i] ≤ 365，默认顺序为升序。
```
**输出描述**
```
完成游玩计划的最低消费。
```
**用例**
```
输入 5 14 30 100
1 3 5 20 21 200 202 230
输出 40
```
**说明**
```
根据售票价格数组和游玩日期数组给出的信息，发现每次去玩的
时候买一张一日票是最省钱的，所以小王会卖8张一日票，每张5
元，最低花费是40元。
题目解析
本题可以使用 动态规划 求解。
定义一个dp数组，dp[i] 的含义是：前 i 天，完成所有游玩日的最少花费金额。
dp[i] 可以由前面的 dp状态 推导而来：
如果第 i 天不是游玩日，即第 i 天不需要考虑花钱买票，那么：dp[i] = dp[i-1]
如果第 i 天是游玩日，那么此时有四种选择：
1. 如果第 i 天被购买的"一日票"有效期覆盖，那么：dp[i] = dp[i-1] + costs[0]，其中：
dp[i - 1] 是前 i-1 天的花费
costs[0] 是第 i 天的花费，即第 i 天买了当天有效的"一日票"
2. 如果第 i 天被购买的"三日票"有效期覆盖，那么：dp[i] = ( i ≥ 3 ? dp[i-3] : 0 ) + costs[1]
我们可以认为在第 i - 2 天购买了"三日票"，其有效期覆盖第 i-2 天，第i-1天，第i天，这段时间的花费是 costs[1]
而第 i-2 天之前，即：第0天~第i-3天的花费是dp[i-3]，此时需要注意 i - 3 可能为负数，如果为负数，则表示第 i-2 天之前没有花费，即为0
3. 如果第 i 天被购买的"七日票"有效期覆盖，那么：dp[i] = ( i ≥ 7 ？dp[i-7] : 0) + costs[2]
原理同上
4. 如果第 i 天被购买的"月票"有效期覆盖，那么：dp[i] = ( i ≥ 30 ？dp[i-30] : 0) + costs[3]
原理同上
因此，如果第 i 天是游玩日，那么我们可以选择上面四种花费中最小的花费。
最后只需要返回 dp[maxDay] 即可，其中maxDay为最大的游玩日，即为days[days.length - 1]。
```
**代码**
```python
class Solution:

    def solve(self, prices, days):
        dp = [0] * (days[-1] + 1)
        index = 0
        for i in range(1, days[-1] + 1):
            if i == days[index]:
                buy1 = prices[0] + dp[i-1]
                buy3 = prices[1] + (dp[i-3] if i >= 3 else 0)
                buy7 = prices[2] + (dp[i-7] if i >= 7 else 0)
                buy30 = prices[3] + (dp[i-30] if i >= 30 else 0)
                dp[i] = min(buy1, buy3, buy7, buy30)
                index += 1
            else:
                dp[i] = dp[i-1]
        return dp[-1]


s = Solution()
print(s.solve([5,14,30,100], [1,3,5,20,21,200,202,230]))
```

29. 伐木工 动态规划

**题目**
```
一根X米长的树木，伐木工切割成不同长度的木材后进行交易，交易价格为每根木头长度的乘积。规定切割后的每根木头长度都为正整数,也可以不
接拿整根树木进行交易。请问伐木工如何尽量少的切割，才能使收益最大化?
```
**输入描述:** 
```
木材的长度(X<=50)
```
**输出描述:** 
```
输出最优收益时的各个树木长度，以空格分割，按升序排列
```
**示例1**
```
输入:
10
输出:
3 3 4
说明:
1.一根2米长的树木，伐木工不切割，为2* 1，收益最大为2
2.一根4米长的树木，伐木工不需要切割为2 *2，省去切割成本，直接整根树木交易，为4*1，收益最大为4
3.一根5米长的树木，伐木工切割为2*3，收益最大为 6
4.一根10米长的树木，伐木工可以切割为方式: 3，4,3，也可以切割为方式二: 3,2，2,3，但方式二伐木工多切割了一次增加切割成本却卖了一样的
此并不是最优收益。
```
**思路**
```
1：收益类的问题，包括 股票交易 类题目，可以直接按照贪心算法往上靠。
```
**代码**
```python
class Solution:

    def solve(self, n):
        dp = [0] * (n+1)
        mem = [[] for _ in range(n+1)]
        for i in range(1, n+1):
            dp[i] = i
            mem[i].append(i)
        for i in range(1, n+1):
            for j in range(1, i):
                if dp[i] > dp[j] * dp[i-j]:
                    continue
                elif dp[i] < dp[j] * dp[i-j]:
                    dp[i] = dp[j] * dp[i-j]
                    mem[i] = mem[j] + mem[i-j]
                else:
                    if len(mem[i]) > len(mem[j]) + len(mem[i-j]):
                        mem[i] = mem[j] + mem[i - j]
        return mem[-1]


s = Solution()
print(s.solve(8))
```

30. 抢7游戏 动态规划

**题目**
```
A、B两个人玩抢7游戏， 游戏规则 为A先报一个起始数字X(10<起始数字<10000)，B报下一个数字Y(X-Y<3), A再报个数字Z(Y-Z<3)，以此类推，
中一个抢到7，抢到7即为胜者;在B赢得 比赛的情况下，一共有多少种组合?
```
**输入描述:** 
```
起始数字M，如100; 10<=M<=10000
```
**输出描述:**
```
B能赢得比赛的 组合次数
```
**示例1**
```
输入:
10
输出：
1
```
**思路**
```
可以倒过来求从B数7到A数起始数字有多少种组合，动态规划
```
**代码**
```python
class Solution:

    def solve(self, n):
        dp = [[0] * (n+1) for _ in range(2)]
        dp[0][7] = 1
        dp[1][7] = 0
        for i in range(8, n+1):
            dp[0][i] = dp[1][i-1] + dp[1][i-2]
            dp[1][i] = dp[0][i-1] + dp[0][i-2]
        return dp[1][-1]


s = Solution()
print(s.solve(100))
```

31. 篮球游戏 双端队列

**题目**
```
幼儿园里有一个放倒的圆桶，它是一个 线性结构 ，允许在桶的右边将篮球放入，可以在桶的左边和右边将篮球取出。每个篮球有单独的编号，老
连续放入一个或多个篮球，小朋友可以在桶左边或右边将篮球取出，当桶只有一个篮球的情况下，必须从左边取出。
如老师按顺序放入1、2、3、4、5共有5 个编号的篮球，那么小朋友可以依次取出编号为1、2、3、4、5或者 3、1、2.4、5 编号的篮球，无法取出
3、2、4 编号的篮球
其中 3、1、2、4、5 的取出场景为:
->连续放入1、2、3号
->从右边取出3号
->从左边取出1号
->从左边取出2号
->放入4号
->从左边取出4号
->放入5号
->从左边取出5号
简答起见，我们以 L 表示左，R表示右，此时取出篮球的依次取出序列为“RLLLL”。
```
**输入描述**
```
每次输入包含一个 测试用例
1.第一行的数字作为老师依次放入的篮球编号
2.第二行的数字作为要检查是否能够按照放入的顺序取出给定的篮球的编号，其中篮球的编号用逗号进行分隔. 其中篮球编号用逗号进行分隔。
```
**输出描述**
```
对干每个篮球的取出席列，如果确实可以获取，请打印出其按照左右方向的操作取出顺序，如果无法获取则打印“NO”
备注
1<篮球编号，篮球个数≤200
篮球上的数字不重复
输出的结果中 LR 必须为大写
```
**示例1：**
```
输入：
4,5,6,7,0,1,2
6,4,0,1,2,5,7
输出：
RLRRRLL
说明：
篮球的取出顺序依次为"右、左、右、右、右、左、左" 
```
**示例2：**
```
输入：
4,5,6,7,0,1,2
6,0,5,1,2,4,7
输出：
NO
```
**代码**
```python
class Solution:

    def solve(self, n1, n2):
        index1 = 0
        index2 = 0
        stack = []
        ans = ''
        while index2 < len(n2) and index1< len(n1):
            while index1< len(n1):
                stack.append(n1[index1])
                index1 += 1
                if stack[-1] == n2[index2]:
                    break
            while stack and (n2[index2] == stack[0] or n2[index2] == stack[-1]):
                if n2[index2] == stack[0]:
                    ans += 'L'
                    stack.pop(0)
                elif n2[index2] == stack[-1]:
                    ans += 'R'
                    stack.pop()
                index2 += 1

        return ans if not stack else 'NO'

s = Solution()
print(s.solve([4,5,6,7,0,1,2], [6,4,0,1,2,5,7]))
```

32. 宽度最小的子矩阵 滑动窗口

**题目**
```
给定一个矩阵，包含N*M个整数，和一个包含K个整数的数组现在要求在这个矩阵中找一个宽度最小的子矩阵，要求子矩阵包含数组中所有的整数
```
**输入描述**
```
第一行输入两个正整数N，M，表示矩阵大小。
接下来N行M列表示矩阵内容。下一行包含一个正整数K。下一行包含K个整数，表示所需包含的数组，K个整数可能存在重复数字。
所有输入数据小于1000。
```
**输出描述**
```
输出包含一个整数，表示满足要求子矩阵的最小宽度，若找不到，输出-1
```
**示例1**
```
输入
2 5
1 2 2 3 1
2 3 2 3 2
3
1 2 3
输出
2
说明
矩阵第0、3列包含了1、2、3，矩阵第3、4列包含了1、2、3
```
**示例2**
```
输入
2 5
1 2 2 3 1
1 3 2 3 4
3
1 1 4
输出
5
说明
矩阵第1,2,3,4,5列包含了1,1,4
```
**思路**
```
1：题目要求：【宽度最小的子矩阵】，我们需要仔细的看题目的示例，从示例中来看，这里的宽度指的是矩阵的列数。注意不要理解错误。
2：既然题目只要求最小的列数，那我们可以把这个矩阵当做成一个可以使用 滑动窗口法 的数组，每次遍历都选择当前列的所有行即可。
```
**代码**
```python
import sys
 
# 输入获取
n, m = map(int, input().split())  # 矩阵 [行数, 列数]
matrix = [list(map(int, input().split())) for _ in range(n)]  # 矩阵
k = int(input())  # 目标数组长度
nums = list(map(int, input().split()))  # 目标数组
 
# cnts[num] 记录的是 目标数组中num元素的个数
cnts = [0] * 1000
for num in nums:
    cnts[num] += 1
 
 
# 算法入口
def getResult():
    # 未完成匹配的元素的个数
    total = k
 
    # 记录最小子矩阵的宽度
    minLen = sys.maxsize
 
    l = 0  # 当前子矩阵的左边界（列号）
    r = 0  # 当前子矩阵的右边界（列号）
 
    # 如果右边界未越界，则可以继续尝试找最小子矩阵
    while r < m:
        # 将第r列所有元素纳入子矩阵
        for i in range(n):
            #  第r列的元素numR
            numR = matrix[i][r]
 
            # cnts[numR] 记录的是 目标数组中numR元素的个数，也可以理解为：目标数组中numR元素剩余未匹配的个数
            # 如果numR不是目标数组元素，则cnts[numR]初始时必然为0，对于非目标数组元素numR, 即使进行了 cnts[numR]--， 也不影响总的未匹配数量 total
            # 如果numR是目标数组元素，则cnts[numR]初始时必然大于0，且随着子矩阵扩大范围，如果子矩阵中包含numR元素个数超过了初始cnts[numR]数量，则超出部分起不到匹配效果，即不能影响总的未匹配数量
            if cnts[numR] > 0:
                total -= 1
            cnts[numR] -= 1
 
        # 纳入r列后，看看总的未匹配元素数量total还有几个，如果total为0，则说明当前子矩阵匹配到了所有目标数组元素
        while total == 0:
            # 若此时子矩阵宽度 r - l + 1 更小，则更新最小子矩阵宽度
            minLen = min(minLen, r - l + 1)
 
            # 由于当前子矩阵已经匹配到所有目标数组元素，因此下一步应该将 l 右移，尝试更小宽度的子矩阵
            for i in range(n):
                # l 右移，相当于当前子矩阵移除了第 l 列所有元素，被移除的元素numL如果是目标数组元素，则对应的未匹配数量应该被恢复
                numL = matrix[i][l]
 
                # 如果当前numL不是目标数组元素，或者当前numL是目标数组元素，但是属于超出部分（这两种情况必然cnts[numL] < 0），则对应numL元素的恢复，不能影响到整体未匹配数量total，
                # 如果当前numL是目标数组元素，且不是超出部分（此时必然cnts[numL] >= 0），则对应numL元素的恢复，会影响到整体未匹配数量total
                if cnts[numL] >= 0:
                    total += 1
                cnts[numL] += 1
 
            # l右移，且下一轮要继续检查l右移后的子矩阵是否依旧能覆盖目标数组所有元素
            l += 1
 
        # r右移
        r += 1
 
    if minLen == sys.maxsize:
        return -1
    else:
        return minLen
 
 
# 算法调用
print(getResult())
```

33. 启动多任务排序 拓扑排序

**题目描述**
```
一个应用启动时，会有多个 初始化 任务需要执行，并且任务之间有依赖关系，例如A任务依赖B任务，那么必须在B任务执行完成之后，才能开始执
现在给出多条任务 依赖关系 的规则，请输入任务的顺序执行序列，规则采用贪婪策略，即一个任务如果没有依赖的任务，则立刻开始执行，如果同
务要执行，则根据任务名称字母顺序排序。
例如：B任务依赖A任务，C任务依赖A任务，D任务依赖B任务和C任务，同时，D任务还依赖E任务。那么执行任务的顺序由先到后是：
A任务，E任务，B任务，C任务，D任务
这里A和E任务都是没有依赖的，立即执行。
```
**输入描述**
```
输入参数每个元素都表示任意两个任务之间的依赖关系，输入参数中符号"->"表示依赖方向，例如：
A->B：表示A依赖B
多个依赖之间用单个空格分隔
```
**输出描述**
```
输出排序后的启动任务列表，多个任务之间用单个空格分隔
用例
输入 A->B C->B
输出 B A C
说明 无
```
**代码**
```python
class Solution:

    def solve(self, input_strs):
        relations = input_strs.split(' ')
        mp = {}
        indegree = {}
        for item in relations:
            child, parent = item.split('->')[0], item.split('->')[1]
            indegree[parent] = indegree.get(parent, 0)
            indegree[child] = indegree.get(child, 0) + 1

            mp[parent] = mp.get(parent, [])
            mp[parent].append(child)

            mp[child] = mp.get(child, [])

        queue = []
        for task in indegree:
            if indegree[task] == 0:
                queue.append(task)

        ans = []
        while queue:
            queue.sort()
            for _ in range(len(queue)):
                cur = queue.pop(0)
                ans.append(cur)
                for cld in mp[cur]:
                    indegree[cld] -= 1
                    if indegree[cld] == 0:
                        queue.append(cld)
        return ans


s = Solution()
print(s.solve('A->B C->B C->D D->E'))
```

34. 贪心歌手 优先队列
**题目描述**
```
一个歌手准备从A城去B城参加演出。
1. 按照合同，他必须在 T 天内赶到
2. 歌手途经 N 座城市
3. 歌手不能往回走
4. 每两座城市之间需要的天数都可以提前获知。
5. 歌手在每座城市都可以在路边卖唱赚钱。
经过调研，歌手提前获知了每座城市卖唱的收入预期：
如果在一座城市第一天卖唱可以赚M，后续每天的收入会减少D（第二天赚的钱是 M - D，第三天是 M - 2D ...）。如果收入减少到 0 就不会再少
6. 歌手到达后的第二天才能开始卖唱。如果今天卖过唱，第二天才能出发。
贪心 的歌手最多可以赚多少钱？
```
**输入描述**
```
第一行两个数字 T 和 N，中间用空格隔开。
T 代表总天数，0 < T < 1000
N 代表路上经过 N 座城市，0 < N < 100
第二行 N+1 个数字，中间用空格隔开。代表每两座城市之间耗费的时间。
其总和 ≤ T。
接下来 N 行，每行两个数字 M 和 D，中间用空格隔开。代表每个城市的输入预期。
0 < M < 1000
0 < D < 100
```
**输出描述**
```
一个数字。代表歌手最多可以赚多少钱。以回车结束。
```
**用例**
```
输入
10 2
1 1 2
120 20
90 10
输出 540
说明
总共10天，路上经过2座城市。
路上共花 1+1+2=4 天
剩余6天最好的计划是在第一座城市待3天，在第二座城市待3
天。
在第一座城市赚的钱：120 + 100 + 80 = 300
在第二座城市赚的钱：90 + 80 + 70 = 240
```
**题目解析**
```
本题歌手必须从A到B，因此输入的第二行各个城市间的花费的路程时间之和roadCost是必须的，即可用于卖唱赚钱的时间 remain 为 T - roadCost。
我们需要规划 remain 时间，合理分配给各个城市，保证时间分配方案能够赚的钱最多。
按照题目意思，每个城市停留的第一天赚m钱，后面每天减少d，
每个城市停留Y天，那么这Y天中赚的钱是严格递减的，且最后一天（第Y天）赚的钱最少
假设歌手目前在X市
如果前面城市没有用完remain时间，那么当天可以停留在X市卖唱赚钱
如果前面城市已经用完remain时间，那么此时需要比较：
1. 歌手选择在X市当天停留卖唱可以赚的钱 x
2. 歌手前面时间中某天赚的最少的钱 y，由于每个城市停留天数中最后一天赚的钱最少，因此这里的y必然是前面某个城市最后一天赚的钱
如果 x > y，则我们应该将前面赚 y 钱的时间，空闲出来，用于当天赚 x 元，这种替换逻辑，不会改变歌手的行程顺序
如果 x <= y，则X市就没有必要待下去了，因为继续待下去赚的钱只会比x少
上面逻辑中，在前面城市（前面时间）中找一个最小赚的钱，非常适合使用 优先队列 。因此我们可以使用优先队列记录已经赚的钱（按天），如果
超出remain限制，那么就取出优先队列中最小赚的钱，和当天停留可以赚的钱比较，如果当天停留可以赚更多钱，则弹出优先队列中最小赚的钱（含义
最少钱的那天时间空出来）。
```
**代码**
```python
class Solution:

    def solve(self, m, n, costs, prices):
        import heapq
        remain = m - sum(costs)
        moneys = []
        index = 1
        pre = prices[0][0]
        while remain:
            if not moneys:
                heapq.heappush(moneys, pre)
            else:
                pre -= prices[0][1]
                heapq.heappush(moneys, max(pre, 0))
            remain -= 1
        while index < len(prices):
            cur = prices[index][0]
            while moneys and moneys[0] < cur:
                heapq.heappop(moneys)
                heapq.heappush(moneys, cur)
                cur = max(0, cur - prices[index][1])
            index += 1
        return sum(moneys)


s = Solution()
print(s.solve(10, 3, [1,1,2,1], [[120, 20], [90, 10], [150,50]]))
```

35. 反射计数 模拟

**题目**
```
给定一个包含 0 和 1 的二维矩阵
给定一个初始位置和速度
1个物体从给定的初始位置触发,在给定的速度下进行移动,遇到矩阵的边缘则发生镜面反射
无论物体经过 0 还是 1，都不影响其速度
请计算并给出经过 t 时间单位后,物体经过 1 点的次数
矩阵以左上角位置为[0,0](列(x),行(行)),例如下面A点坐标为[2,1](第二列,第一行)
001000010000
001000010000
001000010000
001000010000
001000010000
001000010000
001000010000
注意:
1.如果初始位置的点是 1，也计算在内
2.时间的最小单位为1，不考虑小于 1 个时间单位内经过的点
```
**输入描述**
```
第一行为初始信息
<w> <h> <x> <y> <sx> <sy> <t>
第二行开始一共h行,为二维矩阵信息其中
w,h为矩阵的宽和高
x,y为起始位置
sx,sy为初始速度
t为经过的时间
所有输入都是 有效的 ，数据范围如下
0 < w < 100
0<h < 1000 <= X < W
0 <=y < w
-1 <= sx<= 1
-1 <= sy <= 1
0 <= t< 100
```
**输出描述: **
```
经过1的个数
注意初始位置也要计算在内
```
**示例1**
```
输入:
12 7 2 1 1 -1 13
001000010000
001000010000
001000010000
001000010000
001000010000
001000010000
001000010000
输出:
3
说明: 初始位置为(2,1),速度为(1,-1),那么13个时间单位后,经过点1的个数为3
```
**代码**
```python
class Solution:

    def solve(self, w, h, x, y, sx, sy, t, matrix):
        ans = 0
        for _ in range(t+1):
            if matrix[y][x] == 1:
                ans += 1
            if x + sx < 0 or x + sx >= w:
                sx = -sx
            if y + sy < 0 or y + sy >= h:
                sy = -sy
            y += sy
            x += sx
        return ans


s = Solution()
print(s.solve(12,7,2,1,1,-1,13,[
    [0,0,1,0,0,0,0,1,0,0,0,0],
    [0,0,1,0,0,0,0,1,0,0,0,0],
    [0,0,1,0,0,0,0,1,0,0,0,0],
    [0,0,1,0,0,0,0,1,0,0,0,0],
    [0,0,1,0,0,0,0,1,0,0,0,0],
    [0,0,1,0,0,0,0,1,0,0,0,0],
    [0,0,1,0,0,0,0,1,0,0,0,0],
]))
```

36. 模拟目录管理功能 树形结构
**题目**
```
实现一个模拟目录管理功能的软件，输入一个命令序列，输出最后一条命令运行结果。 支持命令:
1)创建目录命令: mkdir 目录名称，如mkdir abc为在当前目录创建abc目录，如果已存在同名目录则不执行任何操作。此命令无输出。
2) 进入目录命令 : cd 目录名称,如cd abc为进入abc目录，特别地，cd ..为返回上级目录，如果目录不存在则不执行任何操作。此命令无输出。
3)查看当前所在路径命令: pwd，输出当前路径 字符串
约束: 1)目录名称仅支持小写字母;mkdir和cd命令的参数仅支持单个目录，如: mkdir bc和cd abc;不支持嵌套路径和绝对路径，如mkdir abc/efg
abc/efg,mkdir /abc/efg,cd /abc/efg是不支持的。
2)目录符号为/，根目录/作为初始目录。
```
**输入描述**
```
输入N行字符串，每一行字符串是一条命令。
```
**输出描述**
```
输出最后一条命令运行结果字符串
```
**示例1**
```
输入
mkdir abc
cd abc
pwd
输出
/abc/
备注
命令行数限制100行以内，目录名称限制10个字符以内。
```
**思路**
```
1：本题第一个核心的考点其实在于对输入有效性的判定。
2：读题目之后可以总结出输入有效性的三个条件，这三个条件，分别要在不同的情况下做特殊处理，但是其实也就两种类型cd和mkdir需要处理：
 1: 长度是否为2
 2: 目录是否满足都是小写字母的条件 cd 特殊条件 ..
 3: 是否存在同名目录
3：第二个核心考点就是保存当前所有的目录关系，用来判断cd和mkdir是否有效。
```
**代码**
```python
class Dic:
    def __init__(self, name, father=None):
        self.name = name
        self.child = []
        self.father = father

class Solution:
    def __init__(self):
        self.current = None

    def validate(self, op):
        flag = True
        if len(op) != 2:
            flag = False
        else:
            if op[0] == 'mkdir':
                for x in op[1]:
                    if not x.islower():
                        flag = False
                        break
                if op[1] in self.current.child:
                    flag = False
            elif op[0] == 'cd':
                if op[1] == '..':
                    if not self.current.father:
                        flag = False
                else:
                    for x in op[1]:
                        if not x.islower():
                            flag = False
                            break
                    all_child = []
                    for child in self.current.child:
                        all_child.append(child.name)
                    if op[1] not in all_child:
                        flag = False
        return flag

    def solve(self, operations):
        root = Dic('', father=None)
        self.current = root
        for operation in operations:
            op = operation.split(' ')
            if op[0] == 'mkdir':
                if self.validate(op):
                    self.current.child.append(Dic(op[1], self.current))
            elif op[0] == 'cd':
                if self.validate(op):
                    if op[1] == '..':
                        self.current = self.current.father
                    else:
                        for x in self.current.child:
                            if x.name == op[1]:
                                self.current = x
            elif op[0] == 'pwd':
                res = []
                node = self.current
                while node:
                    res.append(node.name)
                    node = node.father
                return '/'.join(res[::-1]) + '/'

s = Solution()
print(s.solve(['mkdir Abc', 'cd abc', 'mkdir abc', 'cd abc', 'pwd']))
```

37. 加密算法 dfs
**题目**
```
有一种特殊的 加密算法 ，明文为一段数字串，经过密码本查找转换，生成另一段密文数字串。规则如下
1.明文为一段数字串由0-9组成
2.密码本为数字0-9组成的 二维数组
3.需要按明文串的数字顺序在密码本里找到同样的数字串，密码本里的数字串是由相邻的单元格数字组成，上下和左右是相邻的，注意:对角线不相
一个单元格的数字不能重复使用。
4.每一位明文对应密文即为密码本中找到的单元格所在的行和列序号(序号从0开始)组成的两个数字。如明文第位Data[i]对应密码本单元格为Book[x
明文第i位对应的密文为XY，X和Y之间用空格隔开
如果有多条密文，返回字符序最小的密文。如果密码本无法匹配，返回"error"
请你设计这个加密程序
```
**输入描述**
```
第一行输入1个正整数N,代表明文的长度(1 <= N <= 200)
第二行输入N个明文数字组成的序列Data[i] (整数: 0<= Data[i] <= 9)
第三行1个正整数M,代表密文的长度接下来M行，每行M个数，代表密文矩阵
```
**输出描述**
```
输出 字典序 最小密文.如果无法匹配，输出"error
```
**示例1：**
```
输入：
2
0 3
3
0 0 2
1 3 4
6 6 4
输出：
0 1 1 1
```
**示例2：**
```
输入：
2
0 5
3
0 0 2
1 3 4
6 6 4
输出：
error
```
**代码**
```python
class Solution:

    def solve(self, n, mingwen, m, miwen):
        ans = []

        def dfs(x, y, path, mingwen):
            if not mingwen:
                ans.append(path[:])
                return

            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < m and miwen[nx][ny] == mingwen[0]:
                    dfs(nx, ny, path+[nx, ny], mingwen[1:])


        for i in range(m):
            for j in range(m):
                if miwen[i][j] == mingwen[0]:
                    dfs(i, j, [i, j], mingwen[1:])
        ans.sort()
        return ans[0] if ans else 'error'


s = Solution()
print(s.solve(2, [0,3], 3, [[0,0,2],[3,3,4],[0,3,4]]))
```

38. 田忌赛马 回溯
**题目描述**
给定两个只包含数字的数组a，b，调整数组 a 里面的数字的顺序，使得尽可能多的a[i] > b[i]。
数组a和b中的数字各不相同。
输出所有可以达到最优结果的a数组的结果。
**输入描述**
输入的第一行是数组 a 中的数字，其中只包含数字，每两个数字之间相隔一个空格，a数组大小不超过10。
输入的第二行是数组 b 中的数字，其中只包含数字，每两个数字之间相隔一个空格，b数组大小不超过10。
**输出描述**
输出所有可以达到最优结果的 a 数组的数量。
**用例**
输入 11 8 20
10 13 7
输出 1
说明 最优结果只有一个，a = [11, 20, 8]，故输出1
输入 11 12 20
10 13 7
输出 2
说明 有两个a数组的排列可以达到最优结果，[12, 20, 11] 和 [11, 20,
12]，故输出2
输入 1 2 3
4 5 6
输出 6
说明 a无论如何都会全输，故a任意排列都行，输出所有a数组的排
列，6种排法。
**
```python
class Solution:

    def solve(self, la, lb):
        la.sort()
        max_bigger_cnt = 0
        res = 0
        used = [False] * len(la)

        def dfs(k, bigger):
            nonlocal max_bigger_cnt
            nonlocal res
            if k >= len(lb):
                if bigger > max_bigger_cnt:
                    max_bigger_cnt = bigger
                    res = 1
                elif bigger == max_bigger_cnt:
                    res += 1
                return

            for i in range(len(la)):
                if used[i]:
                    continue
                if i > 0 and la[i-1] == la[i] and not used[i-1]:
                    continue
                used[i] = True
                dfs(k+1, bigger + (1 if la[i] > lb[k] else 0))
                used[i] = False

        dfs(0, 0)
        return res

s = Solution()
print(s.solve([1,2,3],[4,5,6]))
```

39. 每个元音包含偶数次的最长子字符串
**题目描述**
```
给你一个 字符串 s ，请你返回满足以下条件的最长 子字符串 的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。
```
**示例**
```
示例 1
输入：s = "eleetminicoworoep"
输出：13
解释：最长子字符串是 "leetminicowor" ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。
示例 2
输入：s = "leetcodeisgreat"
输出：5
解释：最长子字符串是 "leetc" ，其中包含 2 个 e 。
示例 3
输入：s = "bcbcbc"
输出：6
解释：这个示例中，字符串 "bcbcbc" 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。
提示
1 <= s.length <= 5 x 10^5
s 只包含小写英文字母。
```
**题目解析**
```
本题最简单的思路就是双循环暴力枚举所有子串，然后计算子串内各个元音的数目。
但是这种思路肯定会超时。
我们枚举子串的目的，是为了统计子串中各元音字符的数量，而实现该需求的更优思路是利用前缀和。
前缀和的应用场景有非常鲜明的特点，如求解连续范围内的状态，实际例子有：求解任意区间的和。
本题其实也可以当成前缀和问题来看，我们遍历输入串，每遍历一个字符，则对应位置 i 就有一个前缀状态 preSum[i]，本题preSum[i] 表示 [0, i] 范围
音字符的数量，具体表现为：
preSum[i] = {
 ‘a’：aCount，
 'e'：eCount，
  'i'：iCount，
 'o'：oCount，
 'u'：uCount
}
那么，如果我们要求解范围[i, j]子串的各个元音的数量，即可通过 preSum[j] - preSum[i-1] 得到。
更多前缀和知识请看：算法设计 - 前缀和 & 差分数列_算法设计 - 前缀和 & 差分数列_伏城之外的博客-csdn博客-CSDN博客
但是光靠前缀和，我们还是要枚举所有子串，依旧会超时。
本题要求我们求解最长的子串，子串范围内各个元音数量为偶数。我们假设：
preSum[j] 位置各个元音的数量分别为：aCount偶数，eCount奇数，iCount偶数，oCount偶数，uCount奇数
再假设 [i, j] 范围内各个元音的数量都为偶数，那么此时preSum[i-1]的各个元音的数量应该是多少呢？
答：必然和preSum[j] 对应元音的数量同奇偶性。因为：
奇数 - 奇数 = 偶数
偶数 - 偶数 = 偶数
比如 preSum[j] = {aCount: 8, eCount: 3, iCount: 6, oCount: 4, uCount: 5}；
且 preSum[i-1] = {aCount: 2, eCount: 1, iCount: 4, oCount: 2, uCount: 3}；
那么 [i, j] 范围内，各个元音的数量为：
aCount = 8 - 2 = 6
eCount = 3 - 1 = 2
iCount = 6 - 4 = 2
oCount = 4 - 2 = 2
uCount = 5 - 3 = 2
因此，当我们得到 preSum[j] 后，我们应该在 i - 1 ∈ [0, j - 1] 范围内找到一个 preSum[i-1] 和 preSum[j] 的各个元音同奇偶性的，且 i - 1要最小，这样得
子串才是 [0, j] 范围内一个最长的且各个元音数量都为偶数的子串。
此时，逻辑虽然得到了优化，但是我们依旧要遍历 0 ~ j - 1 范围内的位置 i，且需要对比对应 preSum[i] 和 preSum[j] 的各个元音的奇偶性，这样依然会
接下来要用到状态压缩了。
由于我们只关注各个元音的数量的奇偶性，即每个元音的数量要么为奇数，要么为偶数，假设我们用0表示偶数，用1表示奇数的话。
那么初始 preSum[0] 的各个元音的状态就可以表示为二进制数：00000
各个二进制位和对应元音对应，如上图所示，当二进制位值为0时，表示对应元音数量为偶数个，当二进制位值为1时，表示对应元音数量为奇数个。
这样我们就完成了 preSum[i] 的状态压缩。
那么状态压缩后的preSum[j] 和 preSum[j+1] 如何进行前缀和累进呢？
假设 j+1 位置的字符是 'e'，那么代表，preSum[j] 的二进制数 中 'e' 对应的位的性质反转，即奇变偶，偶变奇。
比如 preSum[j] = 01010，而 s[j+1] 字符是 'e'，则 preSum[j+1] = 00010
此时我们完全可以用异或运算从preSum[j]得出preSum[j+1]
preSum[j + 1] = preSum[j] ^ 01000
其中 01000 代表是新增一个'e'字符，同理
10000 代表新增一个 'a' 字符
01000 代表新增一个 'e' 字符
00100 代表新增一个 'i' 字符
00010 代表新增一个 'o' 字符
00001 代表新增一个 'u' 字符
接下来就是，比较preSum[i] 和 preSum[j] 的各个元音的奇偶性是否一致，就可以直接将对应二进制数进行值比较即可，值相同，则奇偶性一致，否则不
比如：preSum[i-1] = 01010，preSum[j] = 01010，那么二者的各个元音的奇偶性就一致。
当我们完成preSum[i]的状态压缩后，我们就可以定义一个哈希表map来记录某个压缩状态最早出现的位置，map的key时压缩状态，val时该压缩状态的
置。
即：我们求解[0, j]范围前缀子串的压缩状态status = preSum[j]后：
如果map存在key=status，那么status状态最早出现位置为 map[staus]，我们定义 i = map[status]，那么i，j位置的前缀子串内部的各个元音的数量是
的，即 [i+1, j] 范围内子串的各个元音的数量B必然都是偶数，[i+1, j] 范围子串是一个符合要求的子串，我们需要记录该子串的长度 j - (i + 1) + 1 = j 
如果 map 不存在 key == status，那么status状态最早出现的位置就是 j，我们需要记录 map[status] = j
按照逻辑，我们只要遍历一遍字符串s，即可找到最长的目标子串。
```
**代码**
```python
class Solution(object):
    def findTheLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        # "前缀子串"中各个元音的奇偶状态
        # 00000
        # aeiou
        # 元音字母和二进制位的对应关系如上，如果二进制位值位0，代表对应元音字符数量有偶数个，如果二进制位值为1，代表对应元音字符数量有奇数个
        # 初始未遍历时，没有子串，此时各个元音的数量都为0，即偶数个，因此所有二进制位值位0
        status = 0b00000
 
        # map记录某个状态的最早出现位置, -2是一个不可能的位置, 即初始时各个状态都没有出现过
        # 压缩状态用五位二进制数表示，因此最多有32种状态
        map = [-2] * 32
        # 00000 状态对应的十进制数为0，最早出现位置是-1，即未遍历，没有子串时
        map[0] = -1
 
        # 记录最长的符合要求的子串长度
        maxLen = 0
 
        for i in range(len(s)):
            c = s[i]
 
            # 如果遍历的字符s[i]是元音字母，则变更对应二进制位的奇偶性
            if c == 'a':
                status ^= 0b10000
            elif c == 'e':
                status ^= 0b01000
            elif c == 'i':
                status ^= 0b00100
            elif c == 'o':
                status ^= 0b00010
            elif c == 'u':
                status ^= 0b00001
 
            # 如果对应状态的最早出现位置为-2，表示没有出现过对应状态，否则map[status]即status状态最早出现的位置
            if map[status] != -2:
                # 当前位置 i 的状态为status，而最早出现status状态的位置是 map[status]，两个位置同奇偶性，因此他们形成的范围内子串是符合要求的
                maxLen = max(maxLen, i - map[status])
            else:
                # 如果对应状态之前未出现过，则当前位置 i 就是该状态的最早出现位置
                map[status] = i
 
        return maxLen
```

40. 最长子字符串的长度 
**题目描述**
```
给你一个字符串 s，字符串 s 首尾相连成一个环形，请你在环中找出 'l'、'o'、'x' 字符都恰好出现了偶数次最长 子字符串 的长度。
```
**输入描述**
```
输入是一串小写的字母组成的字符串
```
**输出描述**
```
输出是一个整数
备注
1 ≤ s.length ≤ 5 * 10^5
s 只包含小写英文字母
```
**用例**
```
输入 alolobo
输出 6
说明 最长子字符串之一是 "alolob"，它包含 'l'，'o' 各2个，以及 0 个
'x'。
输入 looxdolx
输出 7
说明
最长的子字符串是"oxdolxl"，由于是首尾连接在一起的，所以最
后一个 'x' 和开头的 'l' 是连接在一起的，此字符串包含 2 个 'l'，2
个'o'，2个'x'
输入 bcbcbc
输出 6
说明 这个示例中，字符串 "bcbcbc" 本身就是最长的，因为 'l'、'o'、'x'
都出现了 0 次。
```
**题目解析**
```
本题其实就是
LeetCode - 1371 每个元音包含偶数次的最长子字符串（Java & JS & Python & C）-CSDN博客
的变形体。
看本题前需要先把上面题目搞懂，否则本题解法看不懂。
本题与上面题目的区别在于，本题的主串s是环，即当遍历到s串尾部时，可以继续环动到s串头部
本题如果继续按照前面 leetcode 那题的思路解题，则会发现使用哈希表时，不能只单单记录某个状态的最早出现位置。
而是需要记录某个状态的出现的所有位置（需要按照先后顺序依次记录）。
因为，本题随着绕环运动，黑色部分会逐渐侵蚀掉一些位置，而这些被侵蚀的位置，可能就是某个状态最早出现的位置，当该位置被侵蚀后，我们需要
状态到新的最早出现位置。
如果使用队列记录某个状态出现的所有位置（按照先后顺序依次记录），那么队列头部记录的就是该状态的最早出现位置，如果该位置被侵蚀，那
弹出队头，使用新的队头元素作为对应状态的最早出现位置。
```
**代码**
```python
class Solution:

    def solve(self, strs):
        status = 0b000
        dic = [[] for _ in range(8)]
        dic[0].append(-1)
        maxlen = 0
        for i in range(len(2*strs)):
            c = strs[i % len(strs)]
            if c == 'l':
                status ^= 0b100
            elif c == 'o':
                status ^= 0b010
            elif c == 'x':
                status ^= 0b001

            if i < len(strs):
                dic[status].append(i)

            while len(dic[status]) > 0:
                earliest = dic[status][0]
                if i - earliest > len(strs):
                    dic[status].pop(0)
                else:
                    maxlen = max(maxlen, i-earliest)
                    break
        return maxlen


s = Solution()
print(s.solve('looxdolx'))
```

41. 运输时间 逻辑分析
**题目描述**
```
M（1 ≤ M ≤ 20）辆车需要在一条不能超车的单行道到达终点，起点到终点的距离为 N（1 ≤ N ≤ 400）。
速度快的车追上前车后，只能以前车的速度继续行驶，求最后一辆车到达目的地花费的时间。
注：每辆车固定间隔 1 小时出发，比如第一辆车 0 时出发，第二辆车 1 时出发，依次类推
```
**输入描述**
```
第一行两个数字：M N，分别代表 车辆数 和到终点的距离，以空格分隔
接下来 M 行，每行一个数字 S，代表每辆车的速度。0 < S < 30
```
**输出描述**
```
最后一辆车到达目的地花费的时间
```
**用例**
```
输入
2 11
3
2
输出 5.5
说明 2辆车，距离11，0时出发的车速度快，1时出发的车，到达目的
地花费5.5
```
**题目解析**
```
本题需要注意的是：速度快的车追上前车后，是可以和前车并行的。即本题的：
一条不能超车的单行道
指的应该是"单向"车道，即可能有多条 单向车道 ，支持多辆车并行。
因此本题的解题就很简单了，由于后车不能超过前车，因此：
如果后车正常行驶情况下，比前车更早到达，则会被前车阻碍，此时后车到达终点时刻，和前车一致
如果后车正常行驶情况下，比前车更晚到达，则不会被前车阻碍，此时后车到达终点时刻，就是自己正常行驶到达终点的时刻
本题要求输出的是：到达目的地花费的时间 = 到达时刻 - 出发时刻
```
**代码**
```python
# 输入获取
m, n = map(int, input().split())
 
# 记录前车到达终点的时刻，本题后车不可能比前车更早到达，因此如果后车到达时刻 < 前车到达时刻arrived，则后车也是按照前车arrived时刻达到
arrived = 0
 
for i in range(m):
    # 当前车的速度
    speed = int(input())
    # 当前车到达终点的时刻
    # * 当前车如果比前车更早到达，则被前车阻碍，按前车到达时间算
    # * 当前车如果比前车更晚到达，则不被前车阻碍，按后车到达时间算
    arrived = max(arrived, n / speed + i)  # n*1.0/speed是行驶花费时间； i是第i辆车的出发时间
 
# 到达时刻 - 出发时刻 = 路上花费的时间
cost = arrived - (m - 1)
 
print(cost)  # 实际考试没有精度问题，可以直接输出cost，可以满分
# print("{:g}".format(round(cost, 3)))  # 我这边OJ用例设计时有小数位则至多保留3位，:g 用于去除无效小数位
```

42.  

