**题目**
```
某业务需要根据终端的 IP地址 获取该终端归属的城市，可以根据公开的IP地址池信息查询归属城市地址池格式如下: 城市名=起始IP，结束IP
起始和结束地址按照英文逗号分隔，多个地址段采用英文分号分隔。比如:
City1=1.1.1.1,1.1.1.2;City1=1.1.1.1,1.1.1.16;City2=3.3.3.3,4.4.4.4;City3=2.2.2.2,6.6.6.6一个城市可以有多个IP段，比如City1有2个IP段城市间也可
包含关系，如City3的IP段包含City2的IP段范围
现在要根据输入的IP列表，返回最佳匹配的城市列表
注:最佳匹配即包含待查询P且长度最小的IP段，比如例子中
3.4.4.4 最佳匹配是City2=3.3.3.3,4.4.4.4，
5.5.5.5的最佳匹配是City3=2.2.2.2,6.6.6.6
```
**输入描述**
```
输入共2行。
第一行为城市的IP段列表，多个IP段采用英文分号， 分隔，IP段列表最大不超过500000。城市名称只包含 英文字母 、数字和下划线。最多不超
100000个。IP段包含关系可能有多层，但不超过100层。
第二行为查询的IP列表，多个IP采用英文逗号“，分隔，最多不超过10000条
```
**输出描述**
```
最佳匹配的城市名列表，采用英文逗号，分隔，城市列表长度应该跟查询的IP列表长度一致。
备注
。无论是否查到匹配正常都要输出分隔符。举例: 假如输入IP列表为IPa,IPb，两个IP均未有匹配城市，此时输出为","即只有一个逗号分隔符，两个
空;
可以假定用例中的所有输入均合法，IP地址均为合法的ipv4地址，满足(1/255),(0/255)(0/255,0/255)的格式，且可以假定用例中不会出现组播和广播
```
**示例1：**
```
输入:
City1=1.1.1.1,1.1.1.2;City1=1.1.1.1,1.1.1.16;City2=3.3.3.3,4.4.4.4;City3=2.2.2.2,6.6.6.6
3.4.4.4,5.5.5.5
输出：
City2,City3
```
**思路**
```
1：题目比较核心的一个点：【起始IP，结束IP】，这里我们首先要做的一个事，就是拿到这个区间内的所有IP，一般的ip表达是 xxx.xxx.xxx.xxx 数字组成，每个数字的最大上限为255，这样我们其实可以用一个8位的二进制数组来表达每个数组，再将四个数字的对应二进制数组合并，这样我
以得到一个正整数，用这个正整数，我们就可以很方便的获取对应其中的IP了。
```
**代码**
```python
class Solution:

    def trans(self, ip):
        ips = [int(x) for x in ip.split('.')]
        res = 0
        for i in range(4):
            res *= 256
            res |= ips[i]
        return res

    def solve(self, s1, s2):
        citys = s1.split(';')
        mp = {}
        for city in citys:
            ranges = city.split('=')[1].split(',')
            if city.split('=')[0] in mp:
                mp[city.split('=')[0]].append([self.trans(ranges[0]), self.trans(ranges[1])])
            else:
                mp[city.split('=')[0]] = [[self.trans(ranges[0]), self.trans(ranges[1])]]
        targets = s2.split(',')
        out = ''
        for target in targets:
            target_num = self.trans(target)
            out_city = ''
            size = float('inf')
            for city in citys:
                ranges = mp[city.split('=')[0]]
                for range in ranges:
                    start = range[0]
                    end = range[1]
                    if start <= target_num and target_num <= end:
                        if end - start < size:
                            out_city = city.split('=')[0]
                            size = end - start
            out += out_city+','
        return out[:-1]



s = Solution()
print(s.solve('City1=1.1.1.1,1.1.1.2;City1=1.1.1.1,1.1.1.16;City2=3.3.3.3,4.4.4.4;City3=2.2.2.2,6.6.6.6',
              '3.4.4.4,5.5.5.5'))

```