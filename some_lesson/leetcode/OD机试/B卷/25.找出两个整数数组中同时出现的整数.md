**题目**
```
现有两个整数数组，需要你找出两个数组中同时出现的整数，并按照如下要求输出:
1.有同时出现的整教时，先按照同时出现次数(整数在两人数组中都出现并目出现次数较少的那人)进行归类，然后按照出现次数从小到大依次按行输
2.没有同时出现的整数时，输出NULL
```
**输入描述**
```
第一行为第一个整数数组，第二行为第二个整数数组，每行数中整数与整数之间以英文号分，整数的取值范用为200,2001， 数组长度 的范用为[
10000]之间的整数。
```
**输出描述**
```
按照出现次数从小到大依次按行输出，每行输出的格式为: 出现次数:该出现次数下的整数 升序排序 的结果
格式中的"."为英文冒号，整数间以英文逗号分隔. 
```
**示例1：**
```
输入
5,3,6,-8,0,11
2,8,8,8,-1,15
输出
NULL
说明
两个整数数组没有同时出现的整数，输出NULL。
```
**示例2：**
```
输入：
5,8,11,3,6,8,8,-1,11,2,11,11
11,2,11,8,6,8,8,-1,8,15,3,-9,11
输出
1:-1,2,3,6
3:8,11
说明
两整数数组中同时出现的整数为-12、3、6、8、11,其中同时出现次数为1的整数为-1,2,3.6(升序排序),同时出现次数为3的整数为8,11(升序排序),先
出现次数为1的整数，再升序输出出现次数为3的整数。
```
**代码**
```python

class Solution:

    def solve(self, s1, s2):
        l1 = list(map(int, s1.split(',')))
        l2 = list(map(int, s2.split(',')))
        mp1 = {}
        mp2 = {}
        for x in l1:
            if x not in mp1:
                mp1[x] = 1
            else:
                mp1[x] += 1
        for y in l2:
            if y not in mp2:
                mp2[y] = 1
            else:
                mp2[y] += 1
        tmp = {}
        for k, v in mp1.items():
            if k in mp2:
                if min(v, mp2[k]) not in tmp:
                    tmp[min(v, mp2[k])] = [k]
                else:
                    tmp[min(v, mp2[k])].append(k)
        res = []
        for k, v in tmp.items():
            res.append([k, v])
        res = sorted(res, key=lambda x: x[0])
        for item in res:
            item[1] = sorted(item[1])
        return res


s = Solution()
print(s.solve('5,8,11,3,6,8,8,-1,11,2,11,11',
'11,2,11,8,6,8,8,-1,8,15,3,-9,11'))
```