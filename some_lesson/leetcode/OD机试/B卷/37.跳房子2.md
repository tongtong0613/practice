**题目**
```
跳房子，也叫跳飞机，是一种世界性的儿童游戏游戏参与者需要分多个回合按顺序跳到第1格直到房子的最后一格，然后获得一次选房子的机会，直
房子被选完，房子最多的人获胜。
跳房子的过程中，如果有踩线等违规行为会结束当前回合，甚至可能倒退几步.假设房子的总格数是count，小红每回合可能连续跳的步数都放在数
中，请问数组中是否有一种步数的组合，可以让小红三个回合跳到最后一格? 如果有，请输出索引和最小的步数组合(数据保证索引和最小的步数组
一的)。
注意:数组中的步数可以重复，但数组中的元素不能重复使用
```
**输入描述**
```
第一行输入为房子总格数count，它是int 整数类型
第二行输入为每回合可能连续跳的步数，它是int整数数组类型
```
**输出描述**
```
返回索引和最小的满足要求的步数组合 (顺序保持steps中原有顺序)
补充说明:
count<=10000，3<=steps.length<=10000，-100000<=steps[i]<=100000
```
**示例1**
```
输入:
9
[1,4,5,2,0,2]
输出:
[4,5,0]
```
**示例2**
```
输入:
9
[1,5,2,0,2,4]
输出:
[5,2,2]
```
**示例3**
```
输入:
12
[-1,2,4,9]
输出:
[-1,4,9]
```
**示例4：**
```
输入
15
[1,9,4,25,10,8,7,5]
输出
[1, 4, 10]
说明
符合条件的步数集合有
[1, 9, 5]
它的下角标之和为：0 + 1 + 7 = 8
[1, 4, 10]
它的下角标之和为：0 + 2 + 4 = 6
因为 6<8，故输出[1, 4, 10]。
```
**代码**
```python

class Solution:

    def solve(self, k, nums):
        n = len(nums)
        tmp = list(enumerate(nums))
        tmp = sorted(tmp, key=lambda x: x[1])
        res = []
        total = float('inf')
        for i in range(n):
            l, r = i + 1, n - 1
            while l < r:
                if tmp[i][1] + tmp[l][1] + tmp[r][1] == k:
                    if not res or tmp[i][0] + tmp[l][0] + tmp[r][0] < total:
                        res = [tmp[i], tmp[l], tmp[r]]
                        total = tmp[i][0] + tmp[l][0] + tmp[r][0]
                    if tmp[r-1][1] == tmp[r][1]:
                        r -= 1
                    elif tmp[l+1][1] == tmp[l][1]:
                        l += 1
                    else:
                        l += 1
                        r -= 1
                elif tmp[i][1] + tmp[l][1] + tmp[r][1] < k:
                    l += 1
                else:
                    r -= 1
        res = sorted(res, key=lambda x: x[0])
        return [item[1] for item in res]


s = Solution()
print(s.solve(15, [1,9,4,25,10,8,5,7]))
```