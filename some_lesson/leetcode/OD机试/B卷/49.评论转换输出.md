**题目**
```
在一个 博客网站 上，每篇博客都有评论。每一条评论都是一个非空英文字母字符串。
评论具有树状结构，除了根评论外，每个评论都有一个父评论。
当评论保存时，使用以下格式：
首先是评论的内容；
然后是回复当前评论的数量。
最后是当前评论的所有子评论。（子评论使用相同的格式嵌套存储）
例如：
第一条评论是"hello,2,ok,0,bye,0"，
第二条评论是"test,0"，
第三条评论是"one,1,two,1,a,0"
所有评论被保存成"hello,2,ok,0,bye,0,test,0,one,1,two,1,a,0"。
对于上述格式的评论，请以另外一种格式打印: 首先打印评论嵌套的最大深度。
然后是打印n行，第i(1<=i<=n)行对应于嵌套级别为的评论 (根评论的嵌套级别为1)对于第i行，嵌套级别为的评论按照它们出现的顺序打印，用空格
```
**输入描述**
```
行评论。由 英文字母 、数字和英文逗号组成保证每个评论都是由英文字符组成的非空字符串每个评论的数量都是整数 (至少由一个数字组成)整个
的长度不超过106.给定的评论结构保证是合法的。
```
**输出描述**
```
按照给定的格式打印评论。对于每一级嵌套，评论应该按照输入中的顺序打印
```
**示例1**
```
输入:
hello,2,ok,0,bye,0,test,0,one,1,two,1,a,0
输出:
3
hello test one
ok bye two
a
说明: 如题目描述中图所示，最大嵌套级别为3。嵌套级别为1的评论是"hello test one”，嵌套级别为2的评论是"ok bye two"，嵌套级别为3的评论为"a"。
```
**代码**
```python
class Tree:
    def __init__(self, value):
        self.value = value
        self.child = []

class Solution:


    def solve(self, input_str):
        input_list = input_str.split(',')
        n = len(input_list)
        root = Tree('*')
        i = -2
        while i < n-2:
            child, i = self.get_tree(i+2, input_list)
            root.child.append(child)
        res = []
        queue = [root]
        while queue:
            tmp = []
            for _ in range(len(queue)):
                node = queue.pop(0)
                tmp.append(node.value)
                if node.child:
                    for i in range(len(node.child)):
                        queue.append(node.child[i])
            res.append(tmp)
        return res[1:]


    def get_tree(self, i, input_list):
        root = Tree(input_list[i])
        need = int(input_list[i+1])
        if need == 0:
            return root, i
        for j in range(need):
            child, i = self.get_tree(i+2, input_list)
            root.child.append(child)
        return root, i

s = Solution()
print(s.solve('A,3,B,2,C,0,D,1,E,0,F,1,G,0,H,1,I,1,J,0,K,1,L,0,M,2,N,0,0,1,P,0'))
```