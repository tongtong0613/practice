**题目**
```
MELON有一堆精美的雨花石(数量为n，重量各异)，准备送给S和W。MELON希望送给俩人的雨花石重量一致，请你设计一个程序帮MELON
能将雨花石平均分配。
```
**输入描述**
```
第1行输入为雨花石个数: n，0 < n < 31.
第2行输入为空格分割的各雨花石重量: m[0] m[1] ..... m[n - 1]， 0 < m[k] < 1001
不需要考虑异常输入的情况。
```
**输出描述**
```
如果可以均分，从当前雨花石中最少拿出几块，可以使两堆的重量相等:如果不能均分，则输出-1。
```
**示例1：**
```
输入
4
1 1 2 2
输出
2
说明
输入第一行代表共4颗雨花石，第二行代表4颗雨花石重量分别为1、1、2、2。均分时只能分别为1,2，需要拿出重量为1和2的两块雨花石，所以输
```
**示例2：**
```
输入
10
1 1 1 1 1 9 8 3 7 10
输出
3
说明
输入第一行代表共10颗雨花石，第二行代表4颗雨花石重量分别为1、1、1、1、1、9、8、3、7、10 。均分时可以1,1,1,1,1,9,7和10,8,3，也可以
1,1,1,1,9.8和10,7,3,1，或者其他均分方式，但第一种只需要拿出重量为10.8,3的3块雨花石，第二种需要拿出4块，所以输出3(块数最少)。
```
**代码**
```python
class Solution:
    def solve(self, n, nums):
        total = sum(nums)
        if total % 2:
            return -1
        m = total // 2
        dp = [[float('inf')] * (n+1) for _ in range(m+1)]
        for i in range(1, m+1):
            dp[i][0] = -1
        for j in range(n+1):
            dp[0][j] = 0
        for i in range(1, m+1):
            for j in range(1, n+1):
                cur_weight = nums[j-1]
                use_cur = -1
                if cur_weight <= i:
                    if dp[i-cur_weight][j-1] != -1:
                        use_cur = dp[i-cur_weight][j-1] + 1
                no_use_cur = dp[i][j-1]
                if use_cur == no_use_cur == -1:
                    dp[i][j] = -1
                elif use_cur == -1:
                    dp[i][j] = no_use_cur
                elif no_use_cur == -1:
                    dp[i][j] = use_cur
                else:
                    dp[i][j] = min(use_cur, no_use_cur)
        return dp[-1][-1]


s = Solution()
print(s.solve(10, [1,1,1,1,1,9,8,3,7,10]))
```