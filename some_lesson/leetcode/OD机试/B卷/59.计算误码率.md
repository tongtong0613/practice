**题目**
```
误码率 是最常用的数据通信传输质量指标。它可以理解为“在多少位数据中出现一位差错”。移动通信 网络中的误码率主要是指比特误码率，其计
如下:比特误码率=错误比特数/传输总比特数。为了简单，我们使用字符串来标识通信的信息，一个字符错误了，就认为出现了一个误码输入一个标
符串，和一个传输后的字符串，计算误码率字符串会被压缩。
例:“2A3B4D5X1Z”表示"AABBBDDDDXXXXXZ"
用例会保证两个输入字符串解压后长度一致，解压前的长度不一定一致每个生成后的字符串长度<100000000.
```
**输入描述**
```
两行，分别为两种字符串的压缩形式。
每行字符串(压缩后的) 长度<100000
```
**输出描述**
```
一行，错误的字数量/展开后的总长度
备注
注意: 展开后的字符串不含数字
```
**示例1：**
```
输入
3A3B
2A4B
输出
1/6
```
**示例2：**
```
输入
5Y5Z
5Y5Z
输出
0/10
```
**示例3：**
```
输入
4Y5Z
9Y
输出
5/9
```
**代码**
```python
class Solution:
    def solve(self, str1, str2):
        total = 0
        diff = 0
        while str1 and str2:
            i = 0
            j = 0
            tmp1 = 0
            while str1[i].isdigit():
                tmp1 = tmp1 * 10 + int(str1[i])
                i += 1
            chr1 = str1[i]
            tmp2 = 0
            while str2[j].isdigit():
                tmp2 = tmp2 * 10 + int(str2[j])
                j += 1
            chr2 = str2[j]
            if tmp1 < tmp2:
                total += tmp1
                diff += tmp1 if chr1 != chr2 else 0
                str1 = str1[i+1:]
                str2 = str(tmp2-tmp1) + str2[j:]
            elif tmp1 > tmp2:
                total += tmp2
                diff += tmp2 if chr1 != chr2 else 0
                str2 = str2[j+1:]
                str1 = str(tmp1-tmp2) + str1[i:]
            else:
                total += tmp1
                diff += tmp1 if chr1 != chr2 else 0
                str1 = str1[i+1:]
                str2 = str2[j+1:]
        return str(diff) + '/' + str(total)


s = Solution()
print(s.solve('3A3B', '6A'))
```