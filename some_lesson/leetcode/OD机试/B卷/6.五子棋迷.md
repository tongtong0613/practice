**题目**
```
张兵和王武是 五子棋 迷，工作之余经常切磋棋艺。这不，这会儿又下起来了。走了一会儿，轮张兵了，对着一条线思考起来了，这条线上的棋子
下
用数组表示: -1 0 1 1 1 0 1 01 1
棋子分布说明:
1.-1代表白子，0代表空位，1 代表黑子
2.数组长度L,满足 1 < L < 40,且L为奇数
你得帮他写一个程序，算出最有利的出子位置。最有利定义
1.找到一个空位(0)，用棋子(1/-1)填充该位置，可以使得当前子的最大连续长度变大
2.如果存在多个位置，返回最靠近中间的较小的那个坐标;
3.如果不存在可行位置，直接返回-1:
4.连续长度不能超过5个(五字棋约束)
```
**输入描述**
```
第一行: 当前出子颜色
第二行: 当前的棋局状态
```
**输出描述**
```
1个整数，表示出子位置的数组下标
```
**示例1**
```
输入:
1
-1 0 1 1 1 0 1 0 1 -1 1
输出:
5
说明: 当前为黑子 (1)，放置在下标为5的位置，黑子的最大连续长度，可以由3到5
```
**示例2**
```
输入:
-1
-1 0 1 1 1 0 1 0 1 -1 1
输出:
1
说明: 当前为白子，唯一可以放置的位置下标为1，白子的最大长度，由1变为2
```
**示例3**
```
输入:
0 0 0 0 1 0 0 0 0 1 0
输出: 说明: 可行的位置很多，5最接近中间的位置坐标
```
**代码**
```python

class Solution:

    def solve(self, target, board):
        n = len(board)
        left, right = 0, 0
        cnt = 1
        max_len = 0
        ans = []
        position = -1
        while left <= right and right < n:
            while left == right and right < n and (board[left] != target and board[left] != 0):
                if board[left] == 0 and cnt == 1:
                    break
                left += 1
                right += 1
            while right < n and (board[right] == target or (board[right] == 0 and cnt == 1)):
                if board[right] == 0:
                    cnt = 0
                    position = right
                right += 1
            cur_len = right - left
            if cur_len > max_len:
                max_len = cur_len
                ans = [position]
            elif cur_len == max_len:
                ans.append(position)

            if board[left] == 0:
                cnt = 1
                position = -1
            left += 1
        mid_position = [n//2] if n % 2 else [n//2-1, n//2]
        min_distance = float('inf')
        res = -1
        for x in ans[::-1]:
            for mid in mid_position:
                if abs(x-mid) <= min_distance:
                    res = x
                    min_distance = abs(x-mid)
        return res

s = Solution()
print(s.solve(1, [1,0,0,1]))
```