**题目**
```
商店里有N件唯一性商品，每件商品有一个价格，第i件商品的价格是 a[i]。一个购买方案可以是从N件商品种选择任意件进行购买(至少一件) ，花费
之和。
现在你需要求出所有购买方案中花费前K小的方案，输出这些方案的花费。当两个方案选择的商品集合至少有一件不同，视为不同方案，因此可能
方案花费相同. 
```
**输入描述**
```
输入数据含两行: 第一行包含两个整数N，K，整数之间通过空格隔开。分别表示商品的个数，以及需要求得的花费个数。1<=N<=10000，1<=K<=min(2^N - 1, 100
第二行包含N个整数a1，a2，..an,整数之间通过空格隔开。表示N件商品的价格。1<=a1<= a2 ...<= an <= 10000
```
**输出描述**
```
按花费从小到大的顺序依次输出K行，一行一个整数。表示花费前K小的购买方案的花费
```
**示例1：**
```
输入
5 6
1 1 2 3 3
输出
1
1
2
2
3
3
```
**示例2：**
```
输入
3 5
1 100 101
输出
1
100
101
101
102
```
**思路**
```
初始状态为0，每次出队的值一定是将来加上又一个值后最小的，然后将来的那个值要的情况和不要的情况分别入队，从而为下下次的选取提供基础比如：（1 2 3 4 5），1要入队(sum = 1)，1不要入队(sum = 0)；2要入队(sum = 2)，2不要入队(sum = 0)；3要入队(sum = 3)，3不要入队(sum = 0)；4要入队(sum = 4)，4不要入队(sum = 0)…无形之间就把(1),(2),(3),(4),…,(1,2),(1,3)…都考虑完毕，这里有个前提：有序
```
**代码**
```python
class Solution:
    def solve(self, n, m, nums):
        import queue

        nums = sorted(nums)
        pri_queue = queue.PriorityQueue()
        # [总和， [pre总和, 当前index]] 总和=pre总和+当前index的值
        c = [nums[0], [0, 0]]
        res = []
        for i in range(m):
            res.append(c[0])
            if c[1][1] + 1 < n:
                # 放入包含当前index的列表
                pri_queue.put([c[0] + nums[c[1][1] + 1], [c[0], c[1][1] + 1]])
                c[1][1] += 1
                # 放入不包含当前index的列表
                pri_queue.put([c[1][0] + nums[c[1][1]], c[1]])
            c = pri_queue.get()
        return res


s = Solution()
print(s.solve(3, 5, [1, 100, 101]))

```
