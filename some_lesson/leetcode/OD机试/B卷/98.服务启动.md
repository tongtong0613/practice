**题目**
```
有若干个连续编号的服务（编号从0开始），服务间有 依赖关系 ，启动一个指定服务，请判断该服务是否可以成功启动，并输出以来的前置服务
赖关系是可以传递的，比如服务2依赖服务1，服务1依赖于服务0，那么服务2依赖于服务1和服务0）。
```
**输入描述**
```
第一行输入为N，N为服务的总个数（1 <= N <= 5000）
第二行输入为M，M为指定启动服务的编号（0 <= M < 5000）
接下来的N行，是从编号0服务~编号N-1服务的服务依赖表，每一行第一个数字是该服务依赖的服务个数T（0 <= T < 5000）,后面T个数字分别是对
赖服务编号
```
**输出描述**
```
为了避免不同算法的服务加载顺序不同，请从服务编号从小到大以此输出所有前置服务的编号，不包括指定启动的服务编号自身。
如果没有依赖的前置服务则输出null。
如果服务无法启动（出现 循环依赖 ，则服务无法启动，样例2为最简单的循环依赖）或其它异常，输出-1.
```
**样例1**
```
输入
4
2
0
1,0
1,1
2,0,1
输出
0,1
解释：
第一行，4，一共四个服务，编号0~3
第二行，2，指定启动编号为2的服务
第三行开始为服务依赖关系表
第三行，0，表示服务0，没有依赖的前置任务，依赖个数为0
第四行，1,0，表示服务1，依赖1个前置任务，编号为0
第三行，1,1，表示服务2，依赖1个前置任务，编号为1
第三行，2,1,0 表示服务3，依赖2个前置任务，编号为0和1
分析，服务启动顺序为0，1，2，可成功启动服务2，输出0，1
```
**样例2**
```
输入
2
1
1,1
1,0

输出
-1
```
**思路**
```
如果题目给出的是一个无向图，那么DFS是可以解决的。但有向图得不出正确结果的。比如：A->B,A->C->B,我们用DFS来处理这个图，我们会得出它有环，但其实没有。
我们可以对DFS稍加变化，来解决这个问题。解决的方法如下：
图中的一个节点，根据其C[N]的值，有三种状态：
0，此节点没有被访问过
-1，被访问过至少1次，其后代节点正在被访问中
1，其后代节点都被访问过。
按照这样的假设，当按照DFS进行搜索时，碰到一个节点时有三种可能：
 1、如果C[V]=0，这是一个新的节点，不做处理
 2、如果C[V]=-1，说明是在访问该节点的后代的过程中访问到该节点本身，则图中有环。
 3、如果C[V]=1，类似于2的推导，没有环。
 ```
 **代码**
 ```python
class Solution:
    def solve(self, n, target, relations):
        c = [0] * n
        flag = True
        ans = set()

        def dfs(target):
            nonlocal flag
            if c[target] == -1:
                flag = False
                return
            elif c[target] == 0:
                c[target] = -1
            elif c[target] == 1:
                return

            if flag:
                for next in relations[target][1:]:
                    ans.add(next)
                    dfs(next)
                else:
                    c[target] = 1
        dfs(target)
        return list(ans) if flag else -1


s = Solution()
print(s.solve(4, 0, [[1,1], [2,2,3], [1,3], [0]]))
 ```