**题目**
```
每个方块代表一个像素，每个像素用其行号和列号表示。为简化处理，多段线的走向只能是水平、竖直、斜向45度。
上图中的多段线可以用下面的坐标串表示: (2,8),(3,7),(3,6),(3,5),(4,4),(5,3),(6,2),(7,3),(8,4),(7,5)但可以发现，这种表示不是最简的，其实只需要存储
色的关键点即可，它们是线段的起点、拐点、终点，而剩下4个点是几余的。
即可以简化为: (2,8)、(3,7)、(3,5)、(6.2) 、(8,4) 、 (7,5)
现在，请根据输入的包含有几余数据的多段线坐标列表，输出其最简化的结果。
```
**输入描述**
```
2 8 3 7 3 6 3 5 4 4 5 3 6 2 7 3 8 4 7 5
1、所有数字以空格分隔，每两个数字一组，第一个数字是行号，第二个数字是列号;2、行号和列号范围为[0,64)，用例输入保证不会越界，考生不
3、输入数据至少包含两个 坐标点 。
**输出描述**
2 8 3 7 3 5 6 2 8 4 7 5
压缩后的最简化坐标列表，和输入数据的格式相同
备注: 输出的坐标相对顺序不能变化
```
**示例1：**
```
输入
2 8 3 7 3 6 3 5 4 4 5 3 6 2 7 3 8 4 7 5
输出
2 8 3 7 3 5 6 2 8 4 7 5
说明
如上图所示，6个蓝色像素的坐标依次是 (2,8) 、 (3,7) 、 (3,5) 、 (6,2) 、 (8,4) 、 (7,5)。
```
**代码**
```python
class Solution:

    def solve(self, locations):
        locations_list = list(map(int, locations.split(' ')))
        points_list = []
        for i in range(0, len(locations_list), 2):
            points_list.append([locations_list[i], locations_list[i+1]])
        res = []
        pre = None
        for j in range(1, len(points_list)):
            if points_list[j][0] - points_list[j-1][0] == 0:
                k = float('inf')
            else:
                k = (points_list[j][1] - points_list[j-1][1]) / (points_list[j][0] - points_list[j-1][0])
            if k != pre:
                res.append(points_list[j-1])
                pre = k
        else:
            res.append([points_list[-1]])
        return res

s = Solution()
print(s.solve('2 8 3 7 3 6 3 5 4 4 5 3 6 2 7 3 8 4 7 5'))
```