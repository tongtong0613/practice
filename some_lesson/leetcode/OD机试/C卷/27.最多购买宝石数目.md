**题目**
```
橱窗里有一排宝石， 不同的 宝石对应不同的价格，宝石的价格标记为gems[i],0<=i<n, n = gems.length。宝石可同时出售0个或多个，如果同时出
个，则要求出售的宝石编号连续；例如客户最大购买宝石个数为m，购买的宝石编号必须为gems[i],gems[i+1]...gems[i+m-1](0<=i<n,m<=n)。假设
有总面值为value的钱，请问最多能购买到多少个宝石,如无法购买宝石，则返回0.
```
**输入描述**
```
第一行输入n， 参数类型 为int，取值范围：[0,10^6]，表示橱窗中宝石的总数量。
之后n行分别表示从第0个到第n-1个宝石的价格，即gems[0]到gems[n-1]的价格，类型为int，取值范围：(0,1000]。
之后一行输入v，类型为int，取值范围：[0,10^9]表示你拥有的钱。
```
**输出描述**
```
输出int类型的返回值，表示最大可购买的宝石数量。
```
**示例1**
```
输入输出 示例仅供调试，后台判题数据一般不包含示例
输入
7
8
4
6
3
1
6
7
10
输出
3
说明
gems = [8,4,6,3,1,6,7], value = 10
最多购买的宝石为gems[2]至gems[4]或者gems[3]至gems[5]
```
**示例2**
```
输入输出示例仅供调试，后台判题数据一般不包含示例
输入
0
1
输出
0
说明
gems = [], value = 1
因为没有宝石，所以返回0
```
**思路**
```
1：因为宝石必须连续购买，那么自然而然的就想到了滑动窗口的思想。
2：我们限定一个窗口，不断的调整左右边界的位置，知道满足最大的长度条件即可。
```
**代码**
```python
class Solution:

    def solve(self, gems, value):
        if not gems:
            return 0
        n = len(gems)
        i, j = 0, 0
        cur = 0
        ans = 0
        while j < n:
            while cur <= value and j < n:
                cur += gems[j]
                j += 1
            while cur > value and i < j:
                cur -= gems[i]
                i += 1
            ans = max(ans, j-i)
        return ans


s = Solution()
print(s.solve([8,4,6,3,1,6,7], 10))
```