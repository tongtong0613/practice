**题目**
```
机器人 搬砖，一共有 N 堆砖存放在 N 个不同的仓库中，第i堆砖中有 bricks[i] 块砖头，要求在 8 小时内搬完。机器人每小时能搬砖的数量取决于能量格，机器人一个小时中只能在一个仓库中搬砖，机器人的能量格只在这一个小时有效，为使得机器人损耗最小化，应尽量减小每次补充的能量
为了保障在 8 小时内能完成搬砖任务，请计算每小时给机器人充能的最小能量格数
1：无需考虑机器人补充能力格的耗时;
2：无需考虑机器人搬砖的耗时;
3：机器人每小时补充能量格只在这一个小时中有效: 
```
**输入描述**
```
第一行为一行数字，空格分隔，表示每个仓库的转头数量。
```
**输出描述**
```
机器人每小时最少需要充的能量格，若无法完成任务，输出 -1
```
**示例1：**
```
输入：
30 12 25 8 19
输出：
15
```
**示例2：**
```
输入：
10 12 25 8 19 8 6 4 17 19 20 30
输出：
-1
```
**思路**
```
1：三种情况讨论吧
->N 大于8，肯定干不完，因为机器人一个小时中只能在一个仓库中搬砖。
->N 等于8，一小时干一个仓库，那肯定要充电最大的数量
->N 小于8，可能需要在一个仓库里干多个小时，这就需要我们找到那个threshold
2：题目隐含的意思应该是一个能量格可以搬一块砖。【为啥不直接明说呢。。】
3：小于8的情况，我们就需要找到一个 中间值 ，恰好满足能干完的情况。既然是找中间值，那肯定是二分法了。
```
**代码**
```python
class Solution:

    def solve(self, bricks):
        n = len(bricks)
        if n > 8:
            return -1
        if n == 8:
            return max(bricks)
        ans = 0
        i, j = 0, max(bricks)
        while i < j:
            mid = (i + j) // 2
            total = 0
            flag = True
            for brick in bricks:
                total += brick // mid
                total += 1 if brick % mid else 0
                if total > 8:
                    flag = False
                    break
            if flag:
                ans = mid
                j = mid - 1
            else:
                i = mid + 1
        return ans

s = Solution()
print(s.solve([20, 12, 25, 8, 12]))
```