**题目**
```
有一辆汽车需要从 m*n 的地图的左上角(起点)开往地图的右下角(终点)，去往每一个地区都需要消耗一定的油量，加油站可进行加油
请你计算汽车确保从起点到达终点时所需的最少初始油量说明:
(1) 智能汽车 可以上下左右四个方向移动1
(2) 地图上的数字取值是 0或-1 或者正整数:
1: 表示加油站，可以加满油，汽车的油箱容量最大为 100;
0: 表示这个地区是障碍物，汽车不能通过
正整数: 表示汽车走过这个地区的耗油量
(3) 如果汽车无论如何都无法到达终点，则返回 -1
```
**输入描述**
```
第一行为两个数字，M，V，表示地图的大小为 M,N(0< M,N < 200)
后面一个M*N 的矩阵，其中的值是 0 或 -1 或正整数，加油站的总数不超过 200个
```
**输出描述**
```
如果汽车无论如何都无法到达终点，则返回-1
如果汽车可以到达终点，则返回最少的初始油量
```
**示例1**
```
输入
2,2
10 ,20
30,40
输出
70
```
**示例2**
```
输入
4,4
10,30,30,20
30,30,-1,10
0,20,20,40
10,-1,30,40
输出
70
```
**示例3**
```
输入
4,5
10,0,30,-1,10
30,0,20,0,20
10,0,10,0,30
10,-1,30,0,10
输出
60
```
**示例4**
```
输入
4,4
10,30,30,20
30,30,20,10
10,20,10,40
10,20,30,40
输出
-1
```
**思路**
```
1：经典的 BFS 、DFS类题目，C卷里出过很多次了。
2：这个题目唯一有点特点的地方就是可以加油，我们用一个变量来保存汽车的油量即可。
```
**代码**
```python
class Solution:

    def solve(self, m, n, matrix):
        ans = float('inf')

        def dfs(x, y, oil):
            nonlocal ans
            if matrix[x][y] == -1:
                oil = 100
            else:
                oil -= matrix[x][y]
            if oil < 0:
                return
            if x == 0 and y == 0:
                ans = min(ans, 100-oil)

            tmp = matrix[x][y]
            matrix[x][y] = 0
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] != 0:
                    dfs(nx, ny, oil)
            matrix[x][y] = tmp

        dfs(m-1, n-1, 100)
        return ans if ans != float('inf') else -1



s = Solution()
print(s.solve(4, 4, [[10,30,30,20],
              [30,30,20,10],
              [10,20,20,40],
              [10,20,30,40]]))
```