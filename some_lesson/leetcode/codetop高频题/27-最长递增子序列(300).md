### 题目

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。
 
**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
``` 

**提示：**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`
 

**进阶：**

你能将算法的时间复杂度降低到 `O(nlog(n))` 吗?

### 代码

**动态规划**

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if not nums:
            return 0
        n = len(nums)
        # 初始化 dp 数组
        dp = [1] * n
        # 循环
        for i in range(n):
            # 循环从开头到i之前的数字
            for j in range(i):
                # nums[j] < nums[i] 才更新dp[i]
                if nums[i] > nums[j]:
                    # dp[i] 更新为当前值与 dp[j]+1的最大值
                    dp[i] = max(dp[i], dp[j]+1)
        return max(dp)
```

**动态规划+二分**

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        # 构造tails数组，tails单调递增
        tails = [0] * len(nums)
        res = 0
        for num in nums:
            # tails左右边界
            i, j = 0, res
            while i < j:
                # 二分查找第一个比num大的值
                m = (i + j) // 2
                # 中间值小于num，更大的在右边，左边界更新为m+1
                if tails[m] < num:
                    i = m + 1
                # 中间值大于等于num，第一个大于num的在左边或者为m，右边界更新为m
                else:
                    j = m
            # 退出循环时i j 相等，将第一个大于num的值更新为num
            tails[i] = num
            # 如果找不到，j在右边界，说明在末尾添加的num，长度加一
            if j == res:
                res += 1
        return res
```

### 题解

**动态规划**

- 状态定义：`dp[i]` 代表 `nums` 以 `nums[i]` 结尾的最长子序列长度。
- 转移方程： 设 `j∈[0,i)`，考虑每轮计算新 `dp[i]` 时，遍历 `[0,i)`列表区间，做以下判断：

  1. 当 `nums[i]>nums[j]` 时： `nums[i]` 可以接在 `nums[j]` 之后（此题要求严格递增），此情况下最长上升子序列长度为 `dp[j]+1` ；
  2. 当 `nums[i]<=nums[j]` 时： `nums[i`] 无法接在 `nums[j]` 之后，此情况上升子序列不成立，跳过。
  
  - 上述所有 1. 情况 下计算出的 `dp[j]+1` 的最大值，为直到 `i` 的最长上升子序列长度（即 `dp[i]` ）。实现方式为遍历 `j` 时，每轮执行 `dp[i]=max(dp[i],dp[j]+1)`。

  - 转移方程： `dp[i] = max(dp[i], dp[j] + 1) for j in [0, i)`。
- 初始状态：`dp[i]` 所有元素置 `1` ，含义是每个元素都至少可以单独成为子序列，此时长度都为 `1` 。
- 返回值：返回 `dp` 列表最大值，即可得到全局最长上升子序列长度。

**流程示例**

|nums|7|8|9|1|2|3|4|5|
|--|--|--|--|--|--|--|--|--|
|初始dp|1|1|1|1|1|1|1|1|
|执行到8|1|2|1|1|1|1|1|1|
|执行到9|1|2|3|1|1|1|1|1|
|执行到1|1|2|3|1|1|1|1|1|
|执行到2|1|2|3|1|2|1|1|1|
|执行到3|1|2|3|1|2|3|1|1|
|执行到4|1|2|3|1|2|3|4|1|
|执行到5|1|2|3|1|2|3|4|5|





**动态规划+二分**

- 状态定义：
    - 维护一个列表 `tails`，其中每个元素 `tails[k]` 的值代表 长度为 `k+1` 的子序列尾部元素的值。
    - 如 `[1,4,6]` 序列，长度为 1,2,3 的子序列尾部元素值分别为 `tails=[1,4,6]`。



- 转移方程： 设 `res` 为 `tails` 当前长度，代表直到当前的最长上升子序列长度。设 `j∈[0,res)`，考虑每轮遍历 `nums[k]` 时，通过二分法遍历 `[0,res)` 列表区间，找出 `nums[k]` 的大小分界点，会出现两种情况：

    - 区间中存在 `tails[i]>nums[k]`： 将第一个满足 `tails[i]>nums[k]` 执行 `tails[i]=nums[k]` ；因为更小的 `nums[k]` 后更可能接一个比它大的数字。
  
    - 区间中不存在 `tails[i]>nums[k] `： 意味着 `nums[k]` 可以接在前面所有长度的子序列之后，因此肯定是接到最长的后面（长度为 `res` ），新子序列长度为 `res+1`。
- 初始状态：

    令 `tails` 列表所有值 `=0`。
- 返回值：

    返回 `res` ，即最长上升子子序列长度。

[题解链接](https://leetcode.cn/problems/longest-increasing-subsequence/solutions/24173/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/)

**流程示例**

|nums|7|8|9|1|2|3|4|5|res|
|--|--|--|--|--|--|--|--|--|--|
|tails|0|0|0|0|0|0|0|0|0|
|执行到7|7|0|0|0|0|0|0|0|1|
|执行到8|7|8|0|0|0|0|0|0|2|
|执行到9|7|8|9|0|0|0|0|0|3|
|执行到1|1|8|9|0|0|0|0|0|3|
|执行到2|1|2|9|0|0|0|0|0|3|
|执行到3|1|2|3|0|0|0|0|0|3|
|执行到4|1|2|3|4|0|0|0|0|4|
|执行到5|1|2|3|4|5|0|0|0|5|