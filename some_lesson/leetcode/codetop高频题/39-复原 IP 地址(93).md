### 题目

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如：`"0.1.2.201"` 和 `"192.168.1.1"` 是 有效 IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 无效 `IP` 地址。
给定一个只包含数字的字符串 `s` ，用以表示一个 `IP` 地址，返回所有可能的有效 `IP` 地址，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 不能 重新排序或删除 `s` 中的任何数字。你可以按 任何 顺序返回答案。


**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

**示例 2：**

```
输入：s = "0000"
输出：["0.0.0.0"]
```

**示例 3：**

```
输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
``` 

**提示：**

- `1 <= s.length <= 20`
- `s` 仅由数字组成

### 代码

```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res = []
        n = len(s)

        def dfs(sub, start):
            if len(sub) == 4 and start == n:
                res.append('.'.join(sub))
                return
            if len(sub) == 4 and start < n:
                return

            for i in range(1, 4):
                if start + i > n:
                    return
                if i > 1 and s[start] == '0':
                    return
                sub_s = s[start:start+i]
                if len(sub_s) == 3 and int(sub_s) > 255:
                    return
                sub.append(sub_s)
                dfs(sub, start+i)
                sub.pop(-1)

        dfs([], 0)
        return res 
```

### 题解

**回溯**

**思路**

- 以 "`25525511135`" 为例，第一步时我们有几种选择？
    1. 选 "`2`" 作为第一个片段
    2. 选 "`25`" 作为第一个片段
    3. 选 "`255`" 作为第一个片段
- 能切三种不同的长度，切第二个片段时，又面临三种选择。
- 这会向下分支，形成一棵树，我们用 DFS 去遍历所有选择，必要时提前回溯。
    - 因为某一步的选择可能是错的，得不到正确的结果，不要往下做了。撤销最后一个选择，回到选择前的状态，去试另一个选择。
- 回溯的第一个要点：选择，它展开了一颗空间树。
  
**回溯的要点二——约束**

- 约束条件限制了当前的选项，这道题的约束条件是：
    1. 一个片段的长度是 `1~3`
    2. 片段的值范围是 `0~255`
    3. 不能是 "`0x`"、"`0xx`" 形式（测试用例告诉我们的）
- 用这些约束进行充分地剪枝，去掉一些选择，避免搜索「不会产生正确答案」的分支。


**回溯的要点三——目标**

- 目标决定了什么时候捕获答案，什么时候砍掉死支，回溯。
- 目标是生成 `4` 个有效片段，并且要耗尽 `IP` 的字符。
- 当条件满足时，说明生成了一个有效组合，加入解集，结束当前递归，继续探索别的分支。
- 如果满4个有效片段，但没耗尽字符，不是想要的解，不继续往下递归，提前回溯。


**定义 dfs 函数**

- `dfs` 函数传什么？也就是，用什么描述一个节点的状态？
- 选择切出一个片段后，继续递归剩余子串。可以传子串，也可以传指针，加上当前的片段数组，描述节点的状态。
- `dfs` 函数做的事：复原从 `start` 到末尾的子串。


[题解链接](https://leetcode.cn/problems/restore-ip-addresses/solutions/366627/shou-hua-tu-jie-huan-yuan-dfs-hui-su-de-xi-jie-by-/)
