### 题目

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```
输入：n = 1
输出：["()"]
``` 

**提示：**

- `1 <= n <= 8`

### 代码

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        res = []

        def dfs(path, l, r):
            # 递归终止条件：左右括号均用完
            if l == 0 and r == 0:
                res.append(path)
                return
            # 有左括号时，先递归左括号
            if l > 0:
                dfs(path+'(', l-1, r)
            # 右括号剩余数量大于左括号时，才递归右括号
            if r > l:
                dfs(path+')', l, r-1)
        
        dfs('', n, n)
        return res
```

### 题解

回溯+剪枝

1. 定义递归函数，传入当前路径 `path` 和 左括号剩余数量 `l` 以及右括号剩余数量 `r` 。
2. 递归终止条件：左右括号均耗尽。
3. 当有左括号时，把左括号加入到 `path` ，`l-1` 继续递归。
4. 只有当右括号数量大于左括号数量时，才递归右括号,把右括号加入到 `path` ，`r-1` 继续递归。

