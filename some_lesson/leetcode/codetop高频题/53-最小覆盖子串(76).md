### 题目

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。
 

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。
```

**示例 3:**

```
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```

**提示：**

- `m == s.length`
- `n == t.length`
- `1 <= m, n <= 105`
- `s` 和 `t` 由英文字母组成


### 代码

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        # s长度
        n = len(s)
        # t长度
        total = len(t)
        # 哈希表记录t中字符出现的频数
        mp = {}
        # 存储结果
        res = ''
        # 当前最大长度
        min_len = float('inf')
        # 遍历t，记录其字符出现频数，存储在mp中
        for x in t:
            if x not in mp:
                mp[x] = 1
            else:
                mp[x] += 1
        # 左右边界
        i, j = 0, 0
        while i < n and j < n:
            # total不为0，右边界右移直到total为0
            while j < n and total != 0:
                # 如果当前字出现在mp中
                if s[j] in mp:
                    # 其频数减一
                    mp[s[j]] -= 1
                    # 减完之后大于等于0，证明包含了一个有效的字符，total需要的值减一
                    if mp[s[j]] >= 0:
                        total -= 1
                # 未覆盖所有t中字符，右边界继续右移
                if total != 0:
                    j += 1
            # 滑动窗口已覆盖t中所有字符
            if total == 0:
                # 左边界的字符不在t中，或者在t中但是频数为负数，证明左边界可以右移，不需要这个字符
                while i < n and (s[i] not in mp or mp[s[i]] < 0):
                    # 如果左边界字符在mp中，其频数加一
                    if s[i] in mp:
                        mp[s[i]] += 1
                    # 左边界右移
                    i += 1
                # 此时滑动窗口刚好覆盖t中所有字符且长度最小，更新min_len值，为当前最小值
                min_len = min(min_len, j-i+1)
                # 如果min_len更新为最新的了，res记录当前结果
                res = s[i:j+1] if min_len == j-i+1 else res
                # 左边界对应字符频数加一，因为后面紧接着左边界要右移
                mp[s[i]] += 1
                # 同样total加一，因为左边界右移，滑动窗口中少了一个必要字符
                total += 1
                # 左右边界右移
                i += 1
                j += 1
        return res
```

### 题解

**算法流程：**

1. 初始化一个字典 mp` 用于存储 `t` 中字符的出现频率，to`tal 为 `t` 的长度。
2. 遍历 `t` ，存储字符的出现频率
3. `i` ， `j` 为滑动窗口的左右边界， `total` 不为 `0` 时 不断扩张右边界，每次扩张碰到存在于 `mp` 中的字符时：
    - 该字符出现频率 `减1`
    - 如果此时出现频率 `大于等于0` ，证明该字符是必要的字符， `total` 减一
4. `total` 为 `0` 时代表此时滑动窗口已经覆盖了满足条件的子串：
    - 左边界字符不在 `mp` 中，或 `mp` 中的频率 `小于0` ，代表这个字符可以去掉，如果在 `mp` 中，将该字符频率 `加一` 。
    - 左边界右移
5. 找到 `mp` 中该字符为 `0` 的值，如果此时右移，子串将不满足条件，此时需要记录子串：
    - 确定最小长度 `min_len`
    - 如果 `min_len == j-i+1` 代表此时的子串最短，更新结果 `res`
    - `mp` 中左边界字符对应的值 `加一`
    - `total` `加一`
    - 左右边界 `加一` ，滑动窗口右移开启下一个循环
6. 返回 res