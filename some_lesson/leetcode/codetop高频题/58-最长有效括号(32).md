### 题目

给你一个只包含 '`(`' 和 '`)`' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**示例 1：**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**示例 2：**

```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

**示例 3：**

```
输入：s = ""
输出：0
``` 

**提示：**

- `0 <= s.length <= 3 * 104`
- `s[i]` 为 '`(`' 或 '`)`'

### 代码

**辅助栈**

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack = []
        res = []
        n = len(s)
        # 遍历所有字符
        for i in range(n):
            # 左括号索引入栈
            if s[i] == '(':
                stack.append(i)
            # 如果为又括号
            else:
                # 如果栈不为空
                if stack:
                    # 暂存出栈的左括号索引
                    res.append(stack.pop(-1))
                    # 暂存右括号索引
                    res.append(i)
        
        # 结果排序
        res.sort()
        m = len(res)
        # 最大长度
        max_len = 0
        # 左边界
        i = 0
        while i < m:
            # 右边界
            j = i
            # 找到第一个不连续的位置
            while j < m-1 and res[j] + 1 == res[j+1]:
                j += 1
            # 更新最大长度
            max_len = max(max_len, j-i+1)
            # 滑动窗口左边界更新为j+1
            i = j+1
        return max_len
```

**动态规划**

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        n = len(s)
        # 初始化dp数组
        dp = [0] * n
        max_len = 0
        for i in range(1, n):
            # 如果当前位右括号
            if s[i] == ')':
                # 前一个为左括号
                if s[i-1] == '(':
                    # 情况一：这两个匹配的括号左边还有其他括号
                    if i - 2 >= 0:
                        dp[i] = 2 + dp[i-2]
                    # 情况二：这两个匹配的括号左边没有其他括号
                    else:
                        dp[i] = 2
                # 前一个括号为右括号，且前一个括号匹配部分之前存在且为左括号
                elif i - dp[i-1] - 1 >= 0 and s[i - dp[i-1] - 1] == '(':
                    # 情况三：再往前一位还有其他括号
                    if i - dp[i-1] - 2 >= 0:
                        dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]
                    # 情况四：再往前没有其他括号
                    else:
                        dp[i] = dp[i-1] + 2
            # 更新最大长度
            max_len = max(max_len, dp[i])
        return max_len
```

### 题解

**辅助栈**

- 构建辅助栈 `stack` ，结果列表 `res`
- 遍历 `s` ：
    - 如果为 '`(`' ,对应下标入栈
    - 如果为 '`)`' ,辅助栈栈顶出栈加入 `res` ，当前下标加入 `res`
- 遍历完之后， `stack` 中存储的是能够构成有效括号的下标， 对其进行排序
- 排序完，遍历获取最大连续长度，即为最长有效括号。


**动态规划**

- 状态定义 `dp[i]` ：以 `s[i]` 为结尾的子串中，所形成的最长有效子串的长度，且有效子串是以 `s[i]` 为结尾。
- 初始化：`dp` 内皆为 `0` 。
- 状态转移：
    1. `s[i]` 是 '`(`' ，以它为结尾的子串，肯定不是有效括号子串—— `dp[i] = 0`
    2. `s[i]` 是 '`)`' ，以它为结尾的子串可能是有效子串，还需考察前一个子问题的末尾 `s[i-1]` :
        - `s[i-1]` 是 '`(`' ，`s[i-1]` 和 `s[i]` 组成一对，有效长度保底为 `2`，还需考察 `s[i-2]`：
            - `s[i-2]` 不存在，则有效长度只有 `2` —— `dp[i] = 2`
            - `s[i-2]` 存在，则加上以 `s[i-2]` 为结尾的最长有效长度 ——` dp[i]=dp[i-2]+2`
        - s`[i-1]` 是 '`)`'，`s[i-1]` 和 `s[i]` 是 '`))`'，以 `s[i-1]` 为结尾的最长有效长度为 `dp[i-1]`，跨过这个长度（具体细节不用管，总之它最大能提供 `dp[i-1]` 长度），来看 `s[i-dp[i-1]-1]` 这个字符：
            - `s[i-dp[i-1]-1]` 不存在或为 '`)`'，则 `s[i]` 找不到匹配 —— `dp[i]=0`
            - `s[i-dp[i-1]-1]` 是 '`(`'，与 `s[i]` 匹配，有效长度 = `2 + 跨过的dp[i-1]+ 前方的dp[i-dp[i-1]-2]`。等一下，s[i-dp[i-1]-2]要存在才行！：
                - `s[i-dp[i-1]-2]` 存在，`dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2`
                - `s[i-dp[i-1]-2]` 不存在，`dp[i] = dp[i-1] + 2`


||(|(|)|(|)|)|
|--|--|--|--|--|--|--|
|dp|0|0|0|0|0|0|
|遍历到(时dp|0|0|0|0|0|0|
|遍历到(时dp|0|0|0|0|0|0|
|遍历到)时dp|0|0|2|0|0|0|
|遍历到(时dp|0|0|2|0|0|0|
|遍历到)时dp|0|0|2|0|4|0|
|遍历到)时dp|0|0|2|0|4|6|



