### 题目

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。

**示例 1：**

```
输入：s = "3[a]2[bc]"
输出："aaabcbc"
```

**示例 2：**

```
输入：s = "3[a2[c]]"
输出："accaccacc"
```

**示例 3：**

```
输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"
```

**示例 4：**

```
输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"
```

**提示：**

- `1 <= s.length <= 30`
- s 由小写英文字母、数字和方括号 `'[]'` 组成
- s 保证是一个 `有效` 的输入。
- s 中所有整数的取值范围为 `[1, 300] `

### 代码

```python
class Solution:
    def decodeString(self, s: str) -> str:
        # 辅助栈
        stack = []
        # 结果
        res = ''
        # 乘数
        multi = 0
        for c in s:
            # 当前字符为[，将乘数和当前结果组成元祖保存到辅助栈
            # 并将乘数和当前结果恢复为默认
            if c == '[':
                stack.append((multi, res))
                multi, res = 0, ''
            # 当前字符为]，辅助栈出栈，拼接结果为出栈的上一次结果+乘数x当前结果
            elif c == ']':
                last_multi, last_res = stack.pop()
                res = last_res + last_multi * res
            # 当前字符为数字，更新乘数
            elif '0' <= c <= '9':
                multi = multi * 10 + int(c)
            # 当前字符为字符，将字符添加到当前结果末尾
            else:
                res += c
        return res
```

### 题解

**算法流程：**

- 构建辅助栈 `stack`， 遍历字符串 `s` 中每个字符 `c`；
    - 当 `c` 为数字时，将数字字符转化为数字 `multi`，用于后续倍数计算；
    - 当 `c` 为字母时，在 `res` 尾部添加 `c`；
    - 当 `c` 为 `[` 时，将当前 `multi` 和 `res` 入栈，并分别置空置 `0`：
        - 记录此 `[` 前的临时结果 `res` 至栈，用于发现对应 `]` 后的拼接操作；
        - 记录此 `[` 前的倍数 `multi` 至栈，用于发现对应 `]` 后，获取 `multi × [...]` 字符串。
        - 进入到新 `[` 后， `res` 和 `multi` 重新记录。
    - 当 `c` 为 `]` 时， `stack` 出栈，拼接字符串 `res = last_res + last_multi * res`，其中:
        - `last_res` 是上个 `[` 到当前 `[` 的字符串，例如 `"3[a2[c]]"` 中的 `a`；
        - `last_multi` 是当前 `[` 到 `]` 内字符串的重复倍数，例如 `"3[a2[c]]"` 中的 `2`。
- 返回字符串 `res`。

